{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/baidu_verify_XMxUyW4DB7.html","path":"baidu_verify_XMxUyW4DB7.html","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/google46a3aa29a75e9ca9.html","path":"google46a3aa29a75e9ca9.html","modified":1,"renderable":0},{"_id":"source/resources/404.jpg","path":"resources/404.jpg","modified":1,"renderable":0},{"_id":"themes/yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Coding.png","path":"img/Coding.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/Quora.png","path":"img/Quora.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/niconico.png","path":"img/niconico.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/博客园.png","path":"img/博客园.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-Splus.js","path":"plugins/prettify/lang-Splus.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-aea.js","path":"plugins/prettify/lang-aea.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-agc.js","path":"plugins/prettify/lang-agc.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-apollo.js","path":"plugins/prettify/lang-apollo.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-basic.js","path":"plugins/prettify/lang-basic.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-cbm.js","path":"plugins/prettify/lang-cbm.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-cl.js","path":"plugins/prettify/lang-cl.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-clj.js","path":"plugins/prettify/lang-clj.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-css.js","path":"plugins/prettify/lang-css.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-dart.js","path":"plugins/prettify/lang-dart.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-el.js","path":"plugins/prettify/lang-el.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-erl.js","path":"plugins/prettify/lang-erl.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-erlang.js","path":"plugins/prettify/lang-erlang.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-fs.js","path":"plugins/prettify/lang-fs.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-go.js","path":"plugins/prettify/lang-go.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-hs.js","path":"plugins/prettify/lang-hs.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-lasso.js","path":"plugins/prettify/lang-lasso.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-lassoscript.js","path":"plugins/prettify/lang-lassoscript.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-latex.js","path":"plugins/prettify/lang-latex.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-lisp.js","path":"plugins/prettify/lang-lisp.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-lgt.js","path":"plugins/prettify/lang-lgt.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-ll.js","path":"plugins/prettify/lang-ll.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-llvm.js","path":"plugins/prettify/lang-llvm.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-logtalk.js","path":"plugins/prettify/lang-logtalk.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-ls.js","path":"plugins/prettify/lang-ls.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-lsp.js","path":"plugins/prettify/lang-lsp.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-lua.js","path":"plugins/prettify/lang-lua.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-matlab.js","path":"plugins/prettify/lang-matlab.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-ml.js","path":"plugins/prettify/lang-ml.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-mumps.js","path":"plugins/prettify/lang-mumps.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-nemerle.js","path":"plugins/prettify/lang-nemerle.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-n.js","path":"plugins/prettify/lang-n.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-pascal.js","path":"plugins/prettify/lang-pascal.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-proto.js","path":"plugins/prettify/lang-proto.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-r.js","path":"plugins/prettify/lang-r.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-rd.js","path":"plugins/prettify/lang-rd.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-rkt.js","path":"plugins/prettify/lang-rkt.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-rust.js","path":"plugins/prettify/lang-rust.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-s.js","path":"plugins/prettify/lang-s.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-scala.js","path":"plugins/prettify/lang-scala.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-scm.js","path":"plugins/prettify/lang-scm.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-sql.js","path":"plugins/prettify/lang-sql.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-ss.js","path":"plugins/prettify/lang-ss.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-swift.js","path":"plugins/prettify/lang-swift.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-tex.js","path":"plugins/prettify/lang-tex.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-tcl.js","path":"plugins/prettify/lang-tcl.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-vb.js","path":"plugins/prettify/lang-vb.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-vbs.js","path":"plugins/prettify/lang-vbs.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-vhd.js","path":"plugins/prettify/lang-vhd.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-wiki.js","path":"plugins/prettify/lang-wiki.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-vhdl.js","path":"plugins/prettify/lang-vhdl.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-xq.js","path":"plugins/prettify/lang-xq.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-yaml.js","path":"plugins/prettify/lang-yaml.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-xquery.js","path":"plugins/prettify/lang-xquery.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/lang-yml.js","path":"plugins/prettify/lang-yml.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/prettify.css","path":"plugins/prettify/prettify.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/prettify.js","path":"plugins/prettify/prettify.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/run_prettify.js","path":"plugins/prettify/run_prettify.js","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-dark.css","path":"plugins/prettify/themes/atelier-cave-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-dark.min.css","path":"plugins/prettify/themes/atelier-cave-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-light.css","path":"plugins/prettify/themes/atelier-cave-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-light.min.css","path":"plugins/prettify/themes/atelier-cave-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-dark.css","path":"plugins/prettify/themes/atelier-dune-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-dark.min.css","path":"plugins/prettify/themes/atelier-dune-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-light.css","path":"plugins/prettify/themes/atelier-dune-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-light.min.css","path":"plugins/prettify/themes/atelier-dune-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-dark.css","path":"plugins/prettify/themes/atelier-estuary-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-dark.min.css","path":"plugins/prettify/themes/atelier-estuary-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-light.css","path":"plugins/prettify/themes/atelier-estuary-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-light.min.css","path":"plugins/prettify/themes/atelier-estuary-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-dark.css","path":"plugins/prettify/themes/atelier-forest-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-dark.min.css","path":"plugins/prettify/themes/atelier-forest-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-light.css","path":"plugins/prettify/themes/atelier-forest-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-light.min.css","path":"plugins/prettify/themes/atelier-forest-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-dark.css","path":"plugins/prettify/themes/atelier-heath-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-dark.min.css","path":"plugins/prettify/themes/atelier-heath-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-light.css","path":"plugins/prettify/themes/atelier-heath-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-light.min.css","path":"plugins/prettify/themes/atelier-heath-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-dark.css","path":"plugins/prettify/themes/atelier-lakeside-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-dark.min.css","path":"plugins/prettify/themes/atelier-lakeside-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-light.css","path":"plugins/prettify/themes/atelier-lakeside-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-light.min.css","path":"plugins/prettify/themes/atelier-lakeside-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-dark.css","path":"plugins/prettify/themes/atelier-plateau-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-dark.min.css","path":"plugins/prettify/themes/atelier-plateau-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-light.css","path":"plugins/prettify/themes/atelier-plateau-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-light.min.css","path":"plugins/prettify/themes/atelier-plateau-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-dark.css","path":"plugins/prettify/themes/atelier-savanna-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-dark.min.css","path":"plugins/prettify/themes/atelier-savanna-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-light.css","path":"plugins/prettify/themes/atelier-savanna-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-light.min.css","path":"plugins/prettify/themes/atelier-savanna-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-dark.css","path":"plugins/prettify/themes/atelier-seaside-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-dark.min.css","path":"plugins/prettify/themes/atelier-seaside-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-light.css","path":"plugins/prettify/themes/atelier-seaside-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-dark.css","path":"plugins/prettify/themes/atelier-sulphurpool-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-light.min.css","path":"plugins/prettify/themes/atelier-seaside-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-dark.min.css","path":"plugins/prettify/themes/atelier-sulphurpool-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-light.css","path":"plugins/prettify/themes/atelier-sulphurpool-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-light.min.css","path":"plugins/prettify/themes/atelier-sulphurpool-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/github-v2.css","path":"plugins/prettify/themes/github-v2.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/github-v2.min.css","path":"plugins/prettify/themes/github-v2.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/github.css","path":"plugins/prettify/themes/github.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/github.min.css","path":"plugins/prettify/themes/github.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-dark.css","path":"plugins/prettify/themes/hemisu-dark.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-dark.min.css","path":"plugins/prettify/themes/hemisu-dark.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-light.css","path":"plugins/prettify/themes/hemisu-light.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-light.min.css","path":"plugins/prettify/themes/hemisu-light.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/prettify.css","path":"plugins/prettify/themes/prettify.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-blue.css","path":"plugins/prettify/themes/tomorrow-night-blue.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-blue.min.css","path":"plugins/prettify/themes/tomorrow-night-blue.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-bright.css","path":"plugins/prettify/themes/tomorrow-night-bright.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-bright.min.css","path":"plugins/prettify/themes/tomorrow-night-bright.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-eighties.css","path":"plugins/prettify/themes/tomorrow-night-eighties.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-eighties.min.css","path":"plugins/prettify/themes/tomorrow-night-eighties.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night.css","path":"plugins/prettify/themes/tomorrow-night.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night.min.css","path":"plugins/prettify/themes/tomorrow-night.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow.css","path":"plugins/prettify/themes/tomorrow.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow.min.css","path":"plugins/prettify/themes/tomorrow.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tranquil-heart.css","path":"plugins/prettify/themes/tranquil-heart.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/tranquil-heart.min.css","path":"plugins/prettify/themes/tranquil-heart.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/vibrant-ink.css","path":"plugins/prettify/themes/vibrant-ink.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/plugins/prettify/themes/vibrant-ink.min.css","path":"plugins/prettify/themes/vibrant-ink.min.css","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":1,"renderable":1},{"_id":"themes/yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1487410290000},{"_id":"source/CNAME","hash":"12b181162837c7ddd3d27ba58f3bb7c2080f9bcd","modified":1487410290000},{"_id":"source/baidu_verify_XMxUyW4DB7.html","hash":"1c842e9099a50dc2e818ff77ca798f0df26c5f9e","modified":1487410290000},{"_id":"source/favicon.ico","hash":"9fe362b56d30d346e39375128346ca7eedb052f8","modified":1487410290000},{"_id":"source/robots.txt","hash":"5025aa3fa080b0a3744889fdeacc029cca0bab60","modified":1487410290000},{"_id":"source/google46a3aa29a75e9ca9.html","hash":"be151f5c672e8e0397986214294488be484196dd","modified":1487410290000},{"_id":"themes/yelee/.gitignore","hash":"237760b38ce80bcc3a8b556566bef0295c145393","modified":1487410290000},{"_id":"themes/yelee/README.md","hash":"034155f3c0a9ac4a30bbdcfd549f151960f5ef8d","modified":1487410290000},{"_id":"themes/yelee/_config.yml","hash":"76a2656c5507dcf569034048274df6a352863451","modified":1487410290000},{"_id":"themes/yelee/package.json","hash":"00357ef6f24eb049074da81809e98f973f528cca","modified":1487410290000},{"_id":"source/404/index.md","hash":"ffd5fcc6a9ae68e77cbe1c8f16db14770f4999ea","modified":1487410290000},{"_id":"source/about/index.md","hash":"b272190aa34da92036b8ec76e5c2a54833bbfb4c","modified":1487410290000},{"_id":"source/_posts/AbstractFactory.md","hash":"88219316d3d7f5ec5819529e0c2790b2109b1bfe","modified":1487410290000},{"_id":"source/_posts/Adapter.md","hash":"5fd15e2acc435df2d9bb68c8354f52970ba579f7","modified":1487410290000},{"_id":"source/_posts/Builder.md","hash":"bd8da25ef2acfeedf1a42e69cd57b3be93040dff","modified":1487410290000},{"_id":"source/_posts/Composite.md","hash":"9356134d38a15a626709cb2050ee6a07f2a738b6","modified":1487410290000},{"_id":"source/_posts/Decorator.md","hash":"dfd2a8619af774f37fd8dd777a82471cb4f9e873","modified":1487410290000},{"_id":"source/_posts/Facade.md","hash":"09321323f3ef4d298cb7402d3355aefb5dbbfbcd","modified":1487410290000},{"_id":"source/_posts/FactoryMethod.md","hash":"ad70ac9d599552b63f7558c32ed1c898a8681b86","modified":1487410290000},{"_id":"source/_posts/Flyweight.md","hash":"459bb458009edf1b4f86d038a6bbd000ff4d5d15","modified":1487410290000},{"_id":"source/_posts/Interpreter.md","hash":"97f307dfa943e5b57a54bc3f65020ac5ad4b27b7","modified":1487410290000},{"_id":"source/_posts/Prototype.md","hash":"9a247ddb17522392ea9db331dd0e3cd6c7ae321f","modified":1487410290000},{"_id":"source/_posts/Singleton.md","hash":"9dc16083cfa5b3733a924a54eb3bbdfecae73b80","modified":1487410290000},{"_id":"source/_posts/TemplateMethod.md","hash":"0bef27562630a0b03d7b290c650c5f76eeac8396","modified":1487410290000},{"_id":"source/_posts/bridge.md","hash":"f0174f6986bc6f31a3a2e30a65ccb50226268209","modified":1487410290000},{"_id":"source/_posts/createquery-vs-createsqlsquery.md","hash":"4335da7685bd9eaa868aacacf579a0a111346042","modified":1487410290000},{"_id":"source/_posts/enriching-restful-services-swagger.md","hash":"b26c4756a0e8f423a655855029c3eef47bc3b77b","modified":1487410290000},{"_id":"source/_posts/gradle-usage.md","hash":"621d50ba8b30907912808c6d98dedac65c170fc6","modified":1487410290000},{"_id":"source/_posts/howto-use-markdownedit.md","hash":"84d19b9af2dd52b185c65a4b6227ebe52bb5b743","modified":1487410290000},{"_id":"source/_posts/java-encoding.md","hash":"5fcba80e84109f85ce537ef8b8bec600b26bd742","modified":1487421050000},{"_id":"source/_posts/jquery实现页面置顶功能.md","hash":"5c2bca023c828afed0f560f2e7605023163b78b1","modified":1487410290000},{"_id":"source/_posts/linux命令拾遗-1.md","hash":"fc92e65e1952032467f836876c4f85d84f5b5191","modified":1487410290000},{"_id":"source/_posts/maven_suibi.md","hash":"95732c780594ac51f77cba7643fe06e822c2758b","modified":1487410290000},{"_id":"source/_posts/md-help.md","hash":"8b501348c8e21d025e101acbe61d479a749506e5","modified":1487410290000},{"_id":"source/_posts/spring-4-mvc-single-multiple-file-upload-example-with-springboot.md","hash":"962172324694358552b5435e0a1cebef66e03ba5","modified":1487410290000},{"_id":"source/_posts/spring-boot-spring-mvc.md","hash":"4d9e6d8cf4e5c80a9fd6c1a6444a68db78782d2c","modified":1487410290000},{"_id":"source/_posts/use-and-install-prettify.md","hash":"f628def470f692a0c5637a7c46a30a05d29691d6","modified":1487410290000},{"_id":"source/_posts/zookeeper-install-deploy.md","hash":"78b0a3988b9ae22237d11cf0c6aef9e625e176a0","modified":1487410290000},{"_id":"source/tags/index.md","hash":"ab0ecb9811aa01c1fb4edb385a94ba2eafa4bdef","modified":1487410290000},{"_id":"source/resources/404.jpg","hash":"6f4d40f506d484d95058a9db0d326e73e8ef3e35","modified":1487410290000},{"_id":"themes/yelee/.github/ISSUE_TEMPLATE.md","hash":"09e2580d457ce93b4d7d554b75618036b45f8717","modified":1487410290000},{"_id":"themes/yelee/languages/default.yml","hash":"80cc17267333753accc0b1c85a73678fedcbce76","modified":1487410290000},{"_id":"themes/yelee/languages/en.yml","hash":"2c096d06c0af4ddf9c128fc8f77fb276b59a47fb","modified":1487410290000},{"_id":"themes/yelee/languages/zh-Hans.yml","hash":"b5b2d20cde04db3773962284a002d025b09134b0","modified":1487410290000},{"_id":"themes/yelee/languages/zh-Hant-HK.yml","hash":"c38a95f5076ad951839aaf7748295d7eea277c61","modified":1487410290000},{"_id":"themes/yelee/languages/zh-Hant-TW.yml","hash":"f372cc0d758a7d8bbb885aa9756d607bec26469a","modified":1487410290000},{"_id":"themes/yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1487410290000},{"_id":"themes/yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1487410290000},{"_id":"themes/yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1487410290000},{"_id":"themes/yelee/layout/layout.ejs","hash":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1487410290000},{"_id":"themes/yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487410290000},{"_id":"themes/yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1487410290000},{"_id":"themes/yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1487410290000},{"_id":"themes/yelee/source/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","hash":"d8061e9e44937746dc55899cdd898d98d173e25d","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","hash":"8af583c5f60c69ffdc97bee4e8fdac1ba34ebecd","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/article.ejs","hash":"d781737389f408a5dd57a0f9430d2704b7fe192c","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/background.ejs","hash":"a439ebf7c4798ad3830e66ccf226a60b05ffea0a","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/footer.ejs","hash":"2ea24319611a8fceeed4491c710920ab72b3e165","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/head.ejs","hash":"acf70dd31cab83ca28b12874335686faf43f330e","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/ie-updater.ejs","hash":"3e5f2e41bbb1a5b93a8a7a6cb9ccd191ced54408","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/left-col.ejs","hash":"6ea8bacacc8370ccf5af4e6f66da3bc743b88342","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","hash":"252f3757edea31d55a7e5624e2214f268bf07283","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","hash":"48696ded8e57def05d7ea58e74730f49d66ea6b5","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/open-in-new-tab.ejs","hash":"a6046bc322ce9194faa9559c70e1618a7e1e4cbc","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/page.ejs","hash":"9e504a0ec060ac3c6622855734ebea6eca2b78e9","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","hash":"190efc2e8ee037387685ff7dd24ae6db8bc77c60","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","hash":"6da102cd4a05bc6b4807b937862a7332f6845e5f","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/tab-title-change.ejs","hash":"1bebab6eb7a849319cd48fe051f3c71b9349a723","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/tag-cloud-page.ejs","hash":"432ded02bcc1f0d52cd833e8eeac688ee886169a","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/toc.ejs","hash":"a0c6362e0f0161bbb7e70d50a4d9e39f2ff8ca48","modified":1487410290000},{"_id":"themes/yelee/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1487410290000},{"_id":"themes/yelee/source/css/_variables.styl","hash":"ba8f32d2ea1358a490ab61d1e9bc308c16adcd81","modified":1487410290000},{"_id":"themes/yelee/source/css/style.styl","hash":"e3f8849c8145d43318cd0a8c48f4d42a04d3cb02","modified":1487410290000},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","hash":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1487410290000},{"_id":"themes/yelee/source/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1487410290000},{"_id":"themes/yelee/source/js/main.js","hash":"46d0397d06fdafbca2508759cb319428f77aa3aa","modified":1487410290000},{"_id":"themes/yelee/source/js/mobile.js","hash":"0f4c1fcd6df47a196ed9495c225173402aa7d769","modified":1487410290000},{"_id":"themes/yelee/source/js/pc.js","hash":"19a1660b10358046e7a1f398284491519b2ffd47","modified":1487410290000},{"_id":"themes/yelee/source/js/search.js","hash":"b456aaab98bbc3b0906f8a16d1e6e4f74dfcffda","modified":1487410290000},{"_id":"themes/yelee/source/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1487410290000},{"_id":"themes/yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1487410290000},{"_id":"themes/yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1487410290000},{"_id":"themes/yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1487410290000},{"_id":"themes/yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1487410290000},{"_id":"themes/yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1487410290000},{"_id":"themes/yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1487410290000},{"_id":"themes/yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1487410290000},{"_id":"themes/yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1487410290000},{"_id":"themes/yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1487410290000},{"_id":"themes/yelee/source/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1487410290000},{"_id":"themes/yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1487410290000},{"_id":"themes/yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1487410290000},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1487410290000},{"_id":"themes/yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1487410290000},{"_id":"themes/yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1487410290000},{"_id":"themes/yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1487410290000},{"_id":"themes/yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1487410290000},{"_id":"themes/yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1487410290000},{"_id":"themes/yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1487410290000},{"_id":"themes/yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/comments/click2show.ejs","hash":"678f3aec2980d378ea44be60eec3eb504c8ba668","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/comments/count-comment.ejs","hash":"d3c1b0b31db9d80e857f3054d010ea49c0f88134","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","hash":"b0b73b4629983b4de447418f30bf744cdf7ed044","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","hash":"15c269b81046b22ee44d38d9a08fc66618318435","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","hash":"bcf2070587645afd20a4eb046b9c8bb9c44d1cf5","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/post/category.ejs","hash":"265bb12f7cfa5e0bcbb74fdd409ba13a6d9d2e22","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/post/date.ejs","hash":"357a8de8a7ed8194efc16f55f97f7e2551b31bf9","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","hash":"593cdf0a9eca655c8a763f2d5fb22254d19b1252","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/post/share.ejs","hash":"60cb646f3bc22c46d6ff4b95bb36dad577ed76c0","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","hash":"9dad471e27de9e066666f3082137eccaede2e67b","modified":1487410290000},{"_id":"themes/yelee/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1487410290000},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1487410290000},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1487410290000},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1487410290000},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1487410290000},{"_id":"themes/yelee/source/background/bg-3.jpg","hash":"fffbee717d4f62e99b74270a5230d69c69e5258e","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/archive.styl","hash":"416786f566582fe697a12bb03a9eb2d1c604e2c7","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/article.styl","hash":"fc9170d4c02d8027ad4c2bc1927a6b36c6059142","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/footer.styl","hash":"384f9a9c017400b12f52ac33759380075e527998","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/highlight.styl","hash":"4dcf5d3e3435897de91b39473a93fb7c3ad73dde","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/instagram.styl","hash":"db9cc156c7df27f7f54b0e7ff34b5949f55f99eb","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/main.styl","hash":"b251223f7cfc66c22d9d4685b370b8f93ad7a1a3","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","hash":"034eb9605e006a0d0098bd963e9cdc11a1eaf6c3","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/mobile.styl","hash":"4681032f51fd0df6451051ba35efa1f9f745c302","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/page.styl","hash":"d05287b44c64576b8560461bc6c3b7e8ceda5539","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/scroll.styl","hash":"1932774d30b8706919342f9cf36ea2d99987ce14","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/search.styl","hash":"fcaa5deaa654aaec69e267e23b49df07f84f633a","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/share.styl","hash":"24ff28457b5e1519a8b4561284f6159bdd827ad4","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","hash":"9d7847cc899970a19d288c9eec9f24691c053ef3","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/toc.styl","hash":"eb19bbd37fc2c1abd238e2ed96b22cb1aae41ab7","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1487410290000},{"_id":"themes/yelee/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1487410290000},{"_id":"themes/yelee/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-Splus.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-aea.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-agc.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-apollo.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-basic.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-cbm.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-cl.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-clj.js","hash":"a2c893fc1b79d9c3aed59e22bcf3769bb5563b5c","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-css.js","hash":"22160ffbcd219c018c3dbef745da29cc334c6e8c","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-dart.js","hash":"be57991fbb09bd187be3cb0218bd5e9c997eea5b","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-el.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-erl.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-erlang.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-fs.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-go.js","hash":"640ffa4b3f9c5aee9414962645b9a7f0f49dd555","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-hs.js","hash":"3158902af4476578fc61eb9e47c679e663a77342","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-lasso.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-lassoscript.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-latex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-lisp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-lgt.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-ll.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-llvm.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-logtalk.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-ls.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-lsp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-lua.js","hash":"60a3dccac2fe79b0e1c38dec6be79a6ae51883fa","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-matlab.js","hash":"94c8fd7c44194dd3b1a444a3fc7c2b7fd09d9d6a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-ml.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-mumps.js","hash":"a6002126b8dfc84a167040a024aad9b6b4e406ee","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-nemerle.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-n.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-pascal.js","hash":"6630a2845b3a0951cbd4b2b8f69d538e0845a53e","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-proto.js","hash":"76ab0965b0e47de76cb5293ceafc7e5ca1588380","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-r.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-rd.js","hash":"f2c5bbaca8b6a00737dbdd30d26ea84a0c9db9bc","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-rkt.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-rust.js","hash":"4e91bf396678821d7124e45478f77662912f68a6","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-s.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-scala.js","hash":"cf07e43b333938964236f455826c335fc806aaa5","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-scm.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-sql.js","hash":"483cc0f4bd0773f6e7377f48b7a028d83790dd1b","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-ss.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-swift.js","hash":"96ecf47954b110d6f46afde474dca4a8a36de641","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-tex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-tcl.js","hash":"38c918e9a43c8975074302305b8b8e5f30d513dc","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-vb.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-vbs.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-vhd.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-wiki.js","hash":"c4090580e86c5040709e6b8fd63b661f978149a6","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-vhdl.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-xq.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-yaml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-xquery.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/lang-yml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/prettify.css","hash":"8e1c89c9a44e0e837551bdfe250a672d6c21f2b7","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/prettify.js","hash":"d24b1da342b5c2d0582f0922118aaf0b2a6840d5","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/run_prettify.js","hash":"face8177a6804506c67c5644c00f3c6e0e50f02b","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","hash":"9b96dd1c51b43a1130b3bb6eedb293b77eef8b1d","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","hash":"ebf7ca8598d93235479460ea7d1be97d44224b05","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/customise/color-scheme.styl","hash":"816044b7680514626981e945ee6be943a5de60a7","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/customise/heading.styl","hash":"f309241c1daa9b6c04aa04063307537c219fdd59","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","hash":"2014a25ec300910b8a093ec8010f6703a2142021","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/customise/list.styl","hash":"b1e564ed76d6e892556b61b4278270fc9eeea961","modified":1487410290000},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","hash":"365026a5a30bcc88bec1b46c391c7d3bce41f033","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-dark.css","hash":"09f3cd75ed03ccc20fc8f817908102ed26219125","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-dark.min.css","hash":"54c272f1d4262b8c1b6043ccc8ff4734b3b1c636","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-light.css","hash":"46bbc73ac8a735e2d907be44d964d9ba96e8a16b","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-cave-light.min.css","hash":"2bbabca35533a5922fb1774db6eed9722ef0de3b","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-dark.css","hash":"47dcb8b3b91aeedf9d74abe760a986c7a0f78a8e","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-dark.min.css","hash":"af53930094ac7a64aaf607ab57ba5b01a09e8efc","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-light.css","hash":"8237c95fc706fd01725144c7e852f586f5269b2c","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-dune-light.min.css","hash":"f7b9b5347f85a0ff22cbaca0d78949ac13fe3eb5","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-dark.css","hash":"fccbba89b0e1e42b3676291aaf3098e7c46169a6","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-dark.min.css","hash":"cbc1f5ec42e9f28af3891523f168b0899f978469","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-light.css","hash":"641351e6e00f73c0b06208dc21dde214105b5333","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-estuary-light.min.css","hash":"a93a4b8ba506b7c1e9135167c9ccf0691ee8ad07","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-dark.css","hash":"750da2899332c401e63c77f0b79c1280f060a24d","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-dark.min.css","hash":"955e4eeee93268be21cdda62c4f0e31242fc580a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-light.css","hash":"ca610b6c535dccd8442ff412683509f9b5f7d42c","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-forest-light.min.css","hash":"debca8705bb18a407dfcda63234f1f2b7aef2916","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-dark.css","hash":"9f751e5e2f741a2ca802119a0b9629456777495a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-dark.min.css","hash":"98a3fea2b8ac476b48b52b757dad939ce80d20b3","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-light.css","hash":"f7a03f2a997bba346a350bedfc860594af29768b","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-heath-light.min.css","hash":"e07b521484b1b4933c0e60ffa6bdfc29bf0c7ec2","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-dark.css","hash":"1c0a402a9f8b243f3ef18895ab4a56fbfcf49a1f","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-dark.min.css","hash":"b8208a6d6b6dcfa1c4da9a98095f4fe91b519cd5","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-light.css","hash":"74c98a39d22780b038551ab6c2a30759b5425518","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-lakeside-light.min.css","hash":"89b917373b3763d4222a5106ba784239e3912a75","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-dark.css","hash":"5be42e7c5fdc012500d13db48ddeab95ae297916","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-dark.min.css","hash":"7de8a010c6cf7d0e5e29e017ca620a24399e62ff","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-light.css","hash":"6160404d0e976cf8e4d8621e6b7e2e8814541771","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-plateau-light.min.css","hash":"84dfbe203e661725913a73f0c573fc1c73565431","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-dark.css","hash":"d34b76751cdf2d8fbb11b15af27c0a9b88d2d181","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-dark.min.css","hash":"06322bcdaa36bb45948828705456ad158415c3f8","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-light.css","hash":"1a81911ada5f680e3af2a266cbebf68c8fc032aa","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-savanna-light.min.css","hash":"e363e8b856e9048b99dcb94e416aba9e7f1a9886","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-dark.css","hash":"0e649a5526ff0e3452be4519465f9282705e68b1","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-dark.min.css","hash":"696a18e6d4d639fd14490262f9a2626203c43fea","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-light.css","hash":"4eae4f7ac1a5bc9947c403942d2fb0daef697cac","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-dark.css","hash":"e8d643b9e6276f76d0ca873da654ce1760694710","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-seaside-light.min.css","hash":"7c070b58bf089d259bf19309708452e6786e05a3","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-dark.min.css","hash":"9718078d1e2208d44bf5ea9a5bfa331f7d8d1fdb","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-light.css","hash":"ec816451c57efebb77025f04b9191a22c4e573e0","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/atelier-sulphurpool-light.min.css","hash":"4eb3ac86b14fdeb45b106580a8d80f359cbab57c","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/github-v2.css","hash":"8b9e795a1dc3e79ab68d07d007d659d685f935ee","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/github-v2.min.css","hash":"cb06bb61052646b33d19a37ad14d68cdd7405d98","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/github.css","hash":"741fde7dc9a25924f267dc251a018526525f6b98","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/github.min.css","hash":"b156639209d7b9b27d3a8cd92bdd676ad358c628","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-dark.css","hash":"dbe6c7f5effeec9c332b7d2a95505f1167027922","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-dark.min.css","hash":"ffc544c52368f725c2ab98d3e6e7a86aca1e31a2","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-light.css","hash":"923d9f6fa7b043b90a212246acdafdaf363aefc0","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/hemisu-light.min.css","hash":"ae6bb465d1f5e28366c66827b8ba4a5924898c04","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/prettify.css","hash":"8e1c89c9a44e0e837551bdfe250a672d6c21f2b7","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-blue.css","hash":"33e4483b73b72d561ec3ee6bac085a8ecfc07564","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-blue.min.css","hash":"c78e33010239894f25eac66b1f0d5a7c310313f5","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-bright.css","hash":"2a69a02e3820845a4e1f12c7ba4e00e8e61f15a9","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-bright.min.css","hash":"0cbd70932ebee3aca4a86fd0e23773e920bc0d5e","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-eighties.css","hash":"ab4a7ca393524f5c15c36ae46152a559cdcb2400","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night-eighties.min.css","hash":"f654ece8ef13e740f844ce593912e040e3f21e5f","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night.css","hash":"40d3a13e572b5e2743762aaff97738c3248acbf6","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow-night.min.css","hash":"5bb9910676b08e6d2a6eac5ef07e08754de14a01","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow.css","hash":"2b6bc58a2a889882a45be1c553f7f9a36f9b3f90","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tomorrow.min.css","hash":"1f61e1f9c60f8be82e3a8287a4f46d87b4551400","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tranquil-heart.css","hash":"cb601cf28f7ec08fd1a9700aa755f7cb1645ac4a","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/tranquil-heart.min.css","hash":"9c669545e3517de77f5cff50a58e4ef035855c87","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/vibrant-ink.css","hash":"db15bbca779664e13472a84146f7f010dc011799","modified":1487410290000},{"_id":"themes/yelee/source/plugins/prettify/themes/vibrant-ink.min.css","hash":"feca319864faa3f8a6ae878553c1d960c7ff702f","modified":1487410290000},{"_id":"themes/yelee/source/background/bg-1.jpg","hash":"48339c3652e5df7bb3abc39526d526c1f9d74128","modified":1487410290000},{"_id":"themes/yelee/source/background/bg-2.jpg","hash":"341d05b5b0243bc9a0c8cfcc57266796998ec56e","modified":1487410290000},{"_id":"themes/yelee/source/background/bg-5.jpg","hash":"0f1d4d530a687b432413d7609071ebaeafdaa8a7","modified":1487410290000},{"_id":"themes/yelee/source/background/bg-4.jpg","hash":"1b50569b1d65903a8bd220ccbb2dd882a5abbd71","modified":1487410290000},{"_id":"public/baidusitemap.xml","hash":"283f68895b4037376447f1cb7e532536753287df","modified":1495792658229},{"_id":"public/atom.xml","hash":"4225273252c85b740b60d2b7e350c2484718b936","modified":1495792658264},{"_id":"public/search.xml","hash":"650e5757066a0e07e8ae944d93dfb783f70fd0ea","modified":1495792658265},{"_id":"public/sitemap.xml","hash":"5cd3425b6d9060c15a7a2047d4b8b0424417753e","modified":1495792658265},{"_id":"public/404.html","hash":"9e723e4c65fd801bc9b51ab4b26d56a89096ce1f","modified":1495792658280},{"_id":"public/about/index.html","hash":"d9d5ddef71f39869642a5b01ff65445eef5e8339","modified":1495792658281},{"_id":"public/tags/index.html","hash":"bb20d5aee712115ee10886c560c9280770196677","modified":1495792658281},{"_id":"public/2017/02/18/java-encoding/index.html","hash":"f919499337e4586e2ea7b29b1c4d7fff4df58883","modified":1495792658281},{"_id":"public/2016/09/03/enriching-restful-services-swagger/index.html","hash":"4566102e76959032cff10ad3b3e04a3c3eb36f3f","modified":1495792658281},{"_id":"public/2016/09/02/spring-4-mvc-single-multiple-file-upload-example-with-springboot/index.html","hash":"72e3afe3d0933704bcb088ee6f73cec0d59aee4b","modified":1495792658281},{"_id":"public/2016/08/20/spring-boot-spring-mvc/index.html","hash":"7714292a85c48730774c5752bd48e20604b21d3b","modified":1495792658281},{"_id":"public/2016/08/13/zookeeper-install-deploy/index.html","hash":"1b50e7231700c4c24a24573996f72cc4891dc1ef","modified":1495792658281},{"_id":"public/2016/08/07/linux命令拾遗-1/index.html","hash":"35cb833714a62fa637fd347986bf6facc78a9d0a","modified":1495792658281},{"_id":"public/2016/07/17/gradle-usage/index.html","hash":"0e258e57db9526e21b5378364b06082b9016eb37","modified":1495792658281},{"_id":"public/2016/07/02/use-and-install-prettify/index.html","hash":"728c49700e78d60f7d4ab49ed61b0f0e4044a069","modified":1495792658281},{"_id":"public/2016/06/25/maven_suibi/index.html","hash":"a10d201bbedd1f857c973691986b5a068a953669","modified":1495792658281},{"_id":"public/2016/06/19/md-help/index.html","hash":"d412d67fb1daffe1655263587949530e6c41d7c1","modified":1495792658281},{"_id":"public/2016/06/19/howto-use-markdownedit/index.html","hash":"5b741b5c2ed7627f155f86be66c8069f21d913f1","modified":1495792658281},{"_id":"public/2014/06/04/createquery-vs-createsqlsquery/index.html","hash":"6efb416a06542740920cc122bef8cb32d0350194","modified":1495792658281},{"_id":"public/2013/11/26/jquery实现页面置顶功能/index.html","hash":"00b6eafbfa5622860a00a11371f0c4c7f77ae457","modified":1495792658281},{"_id":"public/2013/10/06/bridge/index.html","hash":"14076531ed23f64e63055f428cc8f05b1b1295fe","modified":1495792658281},{"_id":"public/2013/10/06/TemplateMethod/index.html","hash":"b7fd989743a36e4fa9abec3094a56f1e6146bf5a","modified":1495792658281},{"_id":"public/2013/10/06/Singleton/index.html","hash":"a1e80289b31ccf73f913fc6605c6c295bfb8619f","modified":1495792658281},{"_id":"public/2013/10/06/Prototype/index.html","hash":"a611d3e3bef507a8947c388df469f01bf7c87681","modified":1495792658281},{"_id":"public/2013/10/06/Builder/index.html","hash":"a63badf8668afafce55d3e3cebbeb0a52ed7ce72","modified":1495792658281},{"_id":"public/2013/10/06/AbstractFactory/index.html","hash":"e6e90b1237ccd5f9a01bc4123ea5a7eab8a48af8","modified":1495792658282},{"_id":"public/2013/10/06/Adapter/index.html","hash":"ee319f9b4d723c0fe3ca84861d65787f5d2bed79","modified":1495792658282},{"_id":"public/2013/10/06/FactoryMethod/index.html","hash":"9f3015de66129b1b5bf10e4543a41ce92b994b16","modified":1495792658282},{"_id":"public/2013/10/06/Facade/index.html","hash":"1aa11cdce890e453991d2eabcf67d53c97a7a8f1","modified":1495792658282},{"_id":"public/2013/10/06/Decorator/index.html","hash":"9c3deeda9bb8aee650d27470d83dcff9142d90ea","modified":1495792658282},{"_id":"public/2013/10/06/Composite/index.html","hash":"1d41f71bab74a1df2ac9b6119f16eabd157ec407","modified":1495792658282},{"_id":"public/2013/10/06/Interpreter/index.html","hash":"f5b69ab68cd5a46a20995f2c66565aa390672d11","modified":1495792658282},{"_id":"public/2013/10/06/Flyweight/index.html","hash":"2777a98c123b4127ed82a2a95c7e63980a90a4b4","modified":1495792658282},{"_id":"public/archives/index.html","hash":"67e6e65ccd9faa57337cecd57b44c2852e3243fe","modified":1495792658282},{"_id":"public/archives/page/2/index.html","hash":"0850a69a4dfb7453b1b8d7f440bd24f8d0d55be1","modified":1495792658282},{"_id":"public/archives/page/3/index.html","hash":"74bb0f6be8238f56fd80ca7add1257542f2785d0","modified":1495792658282},{"_id":"public/archives/2013/index.html","hash":"2f2f4991d4d06e01230516fc98baef313b76e46e","modified":1495792658282},{"_id":"public/archives/2013/page/2/index.html","hash":"adbb1e8cd14f59864522a25f781119a168e844ab","modified":1495792658282},{"_id":"public/archives/2013/10/index.html","hash":"38291df6c398c63d0c7e3257c01f3fb263a13006","modified":1495792658282},{"_id":"public/archives/2013/10/page/2/index.html","hash":"85e06f2537071d67b1bd376e76373764c10bb4d9","modified":1495792658282},{"_id":"public/archives/2013/11/index.html","hash":"fda15a816a02959f29b7d12c56e6307730471626","modified":1495792658282},{"_id":"public/archives/2014/index.html","hash":"b01e231e0c8ad594a1fe41a9a0c47b08b6f9ec43","modified":1495792658282},{"_id":"public/archives/2014/06/index.html","hash":"559bffbca9bd67547908f2297dbceb9cc10a0d60","modified":1495792658282},{"_id":"public/archives/2016/index.html","hash":"2b8f0d779d2b42f848949d4b6d1b597a3b25bb2d","modified":1495792658282},{"_id":"public/archives/2016/06/index.html","hash":"a84a4f732ddfbbdec80da5540f0b21a5a86e568f","modified":1495792658282},{"_id":"public/archives/2016/07/index.html","hash":"2dd4b00680dd91157c3b2a5a38655ef33f69eeda","modified":1495792658282},{"_id":"public/archives/2016/08/index.html","hash":"1c1343c4305891199ebc1273a6ac155830987a3e","modified":1495792658282},{"_id":"public/archives/2016/09/index.html","hash":"c21f1b566f5035c2b131b33f7e0ef9e91e854d0a","modified":1495792658283},{"_id":"public/archives/2017/index.html","hash":"9a81f5ea8843be8e41c43b839de8d1ce9f5ddea1","modified":1495792658283},{"_id":"public/archives/2017/02/index.html","hash":"8d7c65f594bf1b0cab597c5c6bc6361da0e855b8","modified":1495792658283},{"_id":"public/categories/gof23/index.html","hash":"ad13ebd47ee43508ef4b0856e95054b379987fdc","modified":1495792658283},{"_id":"public/categories/gof23/page/2/index.html","hash":"c17ac16ba0323b1cefe7c63ac70a477de0edd885","modified":1495792658283},{"_id":"public/categories/Hibernate/index.html","hash":"5b86cd677395ec09e70f2b3ffbe840b13c1fda8b","modified":1495792658283},{"_id":"public/categories/essay/index.html","hash":"b267a1990e92331b84e86f01088794fe5ccbc576","modified":1495792658283},{"_id":"public/categories/Java/index.html","hash":"5db174b2777c806f537db8f73d4a2af44623fd65","modified":1495792658283},{"_id":"public/categories/markdown/index.html","hash":"7a519319f7144526932ceee4859ea0312efb2135","modified":1495792658283},{"_id":"public/categories/code-block-list/index.html","hash":"2c9d61b9e273747954389b35cd86f260c7d93386","modified":1495792658283},{"_id":"public/categories/linux/index.html","hash":"5118af88223bca17a42b872dd0c2b4475638fdd1","modified":1495792658283},{"_id":"public/categories/cleared-knowledge/index.html","hash":"0cf4d92c5bccf712d5ac5c9619bc38e0796ed223","modified":1495792658283},{"_id":"public/categories/SpringBoot/index.html","hash":"5cb2564438e5946c650dbccf2f7ccd0d18d0208d","modified":1495792658283},{"_id":"public/categories/toss-record/index.html","hash":"cb8ba7abb11cb6e4a82ffc3e42d906d297264d12","modified":1495792658283},{"_id":"public/categories/安装部署/index.html","hash":"99efd0765a16311f24856665ad8b3679aa4cc013","modified":1495792658283},{"_id":"public/index.html","hash":"406366773ec175a617b1cd8f80227d961dbe509b","modified":1495792658283},{"_id":"public/page/2/index.html","hash":"bd4e8705dcd500f00bd7e0250b90c997436b36cb","modified":1495792658283},{"_id":"public/page/3/index.html","hash":"da6aab4c0a53194277e5c6e4b1781b67fb596c81","modified":1495792658283},{"_id":"public/tags/AbstractFactory/index.html","hash":"b81bf53f7211941aa074248365d14cc940d9ce59","modified":1495792658283},{"_id":"public/tags/抽象工厂模式/index.html","hash":"783d5134ec1fd4d3b9fb83aa0b403145a28c6324","modified":1495792658283},{"_id":"public/tags/Adapter/index.html","hash":"344bb83db40fed8c6ea92633e86c1c2b30813edd","modified":1495792658283},{"_id":"public/tags/适配器模式/index.html","hash":"4bf54daa6e06c40c56364c7a0dedc8223279aa78","modified":1495792658283},{"_id":"public/tags/Builder/index.html","hash":"f83baec69e91d05df29cc37fcdd6aed8dde9d684","modified":1495792658283},{"_id":"public/tags/生成器模式/index.html","hash":"fb6fc2b786617cd7ff35bc0f0cb929616ebfc463","modified":1495792658283},{"_id":"public/tags/Decorator/index.html","hash":"2316e85db5be8177902e33121dc7a779f457819d","modified":1495792658284},{"_id":"public/tags/组合模式/index.html","hash":"898d3495b8b4a73aa82609ba0f84be87a22acd7f","modified":1495792658284},{"_id":"public/tags/装饰模式/index.html","hash":"100b1d2b9b52a4ff0c14a2bad817fa81a121eb90","modified":1495792658284},{"_id":"public/tags/Facade/index.html","hash":"23f401ccefc454d62b371b5e71de5d64674b6b02","modified":1495792658284},{"_id":"public/tags/外观模式/index.html","hash":"2306f53fb983ad81db03302aa06025b6f67033f5","modified":1495792658284},{"_id":"public/tags/FactoryMethod/index.html","hash":"182910068aa008edd1e4d5361a891fec159c87e6","modified":1495792658284},{"_id":"public/tags/工厂方法模式/index.html","hash":"dc7e63194b51604e672b55fc0896e65cca7570cc","modified":1495792658284},{"_id":"public/tags/享元模式/index.html","hash":"e1d40b77d1ff4d93c900d59f9c5edecf94de608d","modified":1495792658284},{"_id":"public/tags/Flyweight/index.html","hash":"2f5c4adfff139de6547e3734ecc2cf17dad3bf54","modified":1495792658284},{"_id":"public/tags/解释器模式/index.html","hash":"8cf00dee30481184a9457be84fc48ebbcd6e4e30","modified":1495792658284},{"_id":"public/tags/Interpreter/index.html","hash":"1ed8cb8715da82a9b5cc1f1fc648e9b67d0d25f9","modified":1495792658284},{"_id":"public/tags/Prototype/index.html","hash":"2c1b4c59c36748b664b285338784ff594d1ffe29","modified":1495792658284},{"_id":"public/tags/原型模式/index.html","hash":"8dff39637f4d1a7240974d19034c646897f0c198","modified":1495792658284},{"_id":"public/tags/Singleton/index.html","hash":"aabc9219d380ae5163bed1a32d857ccf5ec00c2a","modified":1495792658284},{"_id":"public/tags/单例模式/index.html","hash":"ba0a86afa999ae91cde7597c3f9f15944cb4f882","modified":1495792658284},{"_id":"public/tags/模板方法/index.html","hash":"a9d794c19682fb2d1e9c5ef0ea3bccf1e99af196","modified":1495792658284},{"_id":"public/tags/TemplateMethod/index.html","hash":"fb2ac7b629761aed67375c9056227fba5fd60dc3","modified":1495792658284},{"_id":"public/tags/Bridge/index.html","hash":"78aa9dca3b5c104c8edda13717280933634d7226","modified":1495792658284},{"_id":"public/tags/桥接模式/index.html","hash":"dc43e445852a46863e534d90ccfd8bd989dcb74e","modified":1495792658284},{"_id":"public/tags/hibernate/index.html","hash":"35199b205e7dc93af79dae3b4b98cf106809a0d5","modified":1495792658284},{"_id":"public/tags/java/index.html","hash":"7911664c4156dc15371ad39ab544aa25978fe4a3","modified":1495792658284},{"_id":"public/tags/Swagger/index.html","hash":"c0d6b4871de9e3bf99a7ceac5a9cd8efd5822fb7","modified":1495792658284},{"_id":"public/tags/RESTful-Service/index.html","hash":"db794c31fdce76fbf7a792bbf368d3df6fd5094d","modified":1495792658284},{"_id":"public/tags/原创翻译/index.html","hash":"d2bed4da9c4fd9929d84dcc7b7d3f3bf4f5885d6","modified":1495792658284},{"_id":"public/tags/gradle/index.html","hash":"39381ffd09bdb1b78719bb50f146ad283ff143a2","modified":1495792658284},{"_id":"public/tags/构建工具/index.html","hash":"5cce20d735e4ff6bbd93502a53690c00eaf643f6","modified":1495792658284},{"_id":"public/tags/CmdMarkdown/index.html","hash":"b14fff8cb2a6c4de4499607ac162eaff9160e1ab","modified":1495792658284},{"_id":"public/tags/markdown/index.html","hash":"c01a4bd43a9789bbbc30f642f0e4b4d9bc559554","modified":1495792658284},{"_id":"public/tags/test/index.html","hash":"0f2c5402121f4e0735b8da4e54c268940e03ef5d","modified":1495792658284},{"_id":"public/tags/js/index.html","hash":"401868b6ddc675f569becc75fc743ecb2c62159d","modified":1495792658285},{"_id":"public/tags/linux/index.html","hash":"620fd800ab64acd60aa85493255180a69f6e450b","modified":1495792658285},{"_id":"public/tags/linux命令/index.html","hash":"735899ba009d4307f00b8ec4853cc989eb7eb9f8","modified":1495792658285},{"_id":"public/tags/maven/index.html","hash":"2ece29a1dc441adbc52b6ec99bd08669b35647ce","modified":1495792658285},{"_id":"public/tags/随笔/index.html","hash":"579717570e83c2a241536b037193d6273368bd91","modified":1495792658285},{"_id":"public/tags/maven使用教程/index.html","hash":"4f15525af63c0440d0db18be64ed816918b06da8","modified":1495792658285},{"_id":"public/tags/markdown语法/index.html","hash":"0bfdc88258bab7cab8fb415e5cdbec836d88a61a","modified":1495792658285},{"_id":"public/tags/Spring-Boot/index.html","hash":"720f010f67ddae76f6f468c2648a10efa9605ca0","modified":1495792658285},{"_id":"public/tags/文件上传/index.html","hash":"288d1afa3e0323942da3c512abc91bcaa63bad07","modified":1495792658285},{"_id":"public/tags/示例/index.html","hash":"b8488dad1a5715c9adbcfad67936c77473d32d75","modified":1495792658285},{"_id":"public/tags/SpringBoot/index.html","hash":"c49b0c882dde97f2ab1bde2b3c26099471f260c8","modified":1495792658285},{"_id":"public/tags/Java/index.html","hash":"aee1c7030340aca3786b2c961c271c1a142e3923","modified":1495792658285},{"_id":"public/tags/hexo/index.html","hash":"9944dcaf49e068eddd442e6d1e82070fc61c5b70","modified":1495792658285},{"_id":"public/tags/prettify/index.html","hash":"153d7c33c9c4287d718af02c5573df91b77894a1","modified":1495792658285},{"_id":"public/tags/高亮插件/index.html","hash":"0f01beb2a72797cbb88457156ab1810fe4eb4683","modified":1495792658285},{"_id":"public/tags/zookeeper/index.html","hash":"cd491b8be3d08b79ade76fe2344ddeb90ad9bfac","modified":1495792658285},{"_id":"public/tags/教程/index.html","hash":"024e81df32a82a3f146b788e8cf83ba79af6f8fb","modified":1495792658285},{"_id":"public/tags/环境搭建/index.html","hash":"e487c45713945229411ab1c89adb0048a560bfe7","modified":1495792658285},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495792658285},{"_id":"public/baidu_verify_XMxUyW4DB7.html","hash":"1c842e9099a50dc2e818ff77ca798f0df26c5f9e","modified":1495792658294},{"_id":"public/CNAME","hash":"12b181162837c7ddd3d27ba58f3bb7c2080f9bcd","modified":1495792658294},{"_id":"public/favicon.ico","hash":"9fe362b56d30d346e39375128346ca7eedb052f8","modified":1495792658294},{"_id":"public/robots.txt","hash":"5025aa3fa080b0a3744889fdeacc029cca0bab60","modified":1495792658294},{"_id":"public/google46a3aa29a75e9ca9.html","hash":"be151f5c672e8e0397986214294488be484196dd","modified":1495792658294},{"_id":"public/resources/404.jpg","hash":"6f4d40f506d484d95058a9db0d326e73e8ef3e35","modified":1495792658294},{"_id":"public/apple-touch-icon.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1495792658294},{"_id":"public/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1495792658294},{"_id":"public/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1495792658294},{"_id":"public/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1495792658294},{"_id":"public/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1495792658294},{"_id":"public/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1495792658295},{"_id":"public/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1495792658295},{"_id":"public/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1495792658295},{"_id":"public/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1495792658295},{"_id":"public/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1495792658295},{"_id":"public/img/avatar.png","hash":"e4bca3d60087cd6e775d8e2aa2bf0d35e3859592","modified":1495792658296},{"_id":"public/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1495792658296},{"_id":"public/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1495792658296},{"_id":"public/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1495792658296},{"_id":"public/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1495792658296},{"_id":"public/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1495792658296},{"_id":"public/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1495792658296},{"_id":"public/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1495792658296},{"_id":"public/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1495792658296},{"_id":"public/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1495792658296},{"_id":"public/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1495792658296},{"_id":"public/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1495792658296},{"_id":"public/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1495792658296},{"_id":"public/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1495792658296},{"_id":"public/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1495792658296},{"_id":"public/js/GithubRepoWidget.js","hash":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1495792659229},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1495792659229},{"_id":"public/js/mobile.js","hash":"0f4c1fcd6df47a196ed9495c225173402aa7d769","modified":1495792659229},{"_id":"public/js/main.js","hash":"46d0397d06fdafbca2508759cb319428f77aa3aa","modified":1495792659229},{"_id":"public/js/pc.js","hash":"19a1660b10358046e7a1f398284491519b2ffd47","modified":1495792659229},{"_id":"public/js/search.js","hash":"b456aaab98bbc3b0906f8a16d1e6e4f74dfcffda","modified":1495792659229},{"_id":"public/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1495792659229},{"_id":"public/plugins/prettify/lang-aea.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1495792659229},{"_id":"public/plugins/prettify/lang-Splus.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1495792659229},{"_id":"public/plugins/prettify/lang-agc.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1495792659229},{"_id":"public/plugins/prettify/lang-apollo.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1495792659229},{"_id":"public/plugins/prettify/lang-basic.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1495792659229},{"_id":"public/plugins/prettify/lang-cbm.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1495792659229},{"_id":"public/plugins/prettify/lang-cl.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1495792659229},{"_id":"public/plugins/prettify/lang-clj.js","hash":"a2c893fc1b79d9c3aed59e22bcf3769bb5563b5c","modified":1495792659229},{"_id":"public/plugins/prettify/lang-css.js","hash":"22160ffbcd219c018c3dbef745da29cc334c6e8c","modified":1495792659229},{"_id":"public/plugins/prettify/lang-dart.js","hash":"be57991fbb09bd187be3cb0218bd5e9c997eea5b","modified":1495792659230},{"_id":"public/plugins/prettify/lang-el.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1495792659230},{"_id":"public/plugins/prettify/lang-erl.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1495792659230},{"_id":"public/plugins/prettify/lang-erlang.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1495792659230},{"_id":"public/plugins/prettify/lang-fs.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1495792659230},{"_id":"public/plugins/prettify/lang-go.js","hash":"640ffa4b3f9c5aee9414962645b9a7f0f49dd555","modified":1495792659230},{"_id":"public/plugins/prettify/lang-hs.js","hash":"3158902af4476578fc61eb9e47c679e663a77342","modified":1495792659230},{"_id":"public/plugins/prettify/lang-lasso.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1495792659230},{"_id":"public/plugins/prettify/lang-lassoscript.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1495792659230},{"_id":"public/plugins/prettify/lang-latex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1495792659230},{"_id":"public/plugins/prettify/lang-lisp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1495792659230},{"_id":"public/plugins/prettify/lang-lgt.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1495792659230},{"_id":"public/plugins/prettify/lang-ll.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1495792659230},{"_id":"public/plugins/prettify/lang-logtalk.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1495792659230},{"_id":"public/plugins/prettify/lang-ls.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1495792659230},{"_id":"public/plugins/prettify/lang-llvm.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1495792659230},{"_id":"public/plugins/prettify/lang-lsp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1495792659230},{"_id":"public/plugins/prettify/lang-lua.js","hash":"60a3dccac2fe79b0e1c38dec6be79a6ae51883fa","modified":1495792659230},{"_id":"public/plugins/prettify/lang-ml.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1495792659230},{"_id":"public/plugins/prettify/lang-mumps.js","hash":"a6002126b8dfc84a167040a024aad9b6b4e406ee","modified":1495792659230},{"_id":"public/plugins/prettify/lang-nemerle.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1495792659230},{"_id":"public/plugins/prettify/lang-n.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1495792659230},{"_id":"public/plugins/prettify/lang-pascal.js","hash":"6630a2845b3a0951cbd4b2b8f69d538e0845a53e","modified":1495792659230},{"_id":"public/plugins/prettify/lang-proto.js","hash":"76ab0965b0e47de76cb5293ceafc7e5ca1588380","modified":1495792659230},{"_id":"public/plugins/prettify/lang-r.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1495792659230},{"_id":"public/plugins/prettify/lang-rd.js","hash":"f2c5bbaca8b6a00737dbdd30d26ea84a0c9db9bc","modified":1495792659230},{"_id":"public/plugins/prettify/lang-rkt.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1495792659230},{"_id":"public/plugins/prettify/lang-rust.js","hash":"4e91bf396678821d7124e45478f77662912f68a6","modified":1495792659230},{"_id":"public/plugins/prettify/lang-s.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1495792659230},{"_id":"public/plugins/prettify/lang-scala.js","hash":"cf07e43b333938964236f455826c335fc806aaa5","modified":1495792659230},{"_id":"public/plugins/prettify/lang-scm.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1495792659230},{"_id":"public/plugins/prettify/lang-sql.js","hash":"483cc0f4bd0773f6e7377f48b7a028d83790dd1b","modified":1495792659230},{"_id":"public/plugins/prettify/lang-ss.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1495792659230},{"_id":"public/plugins/prettify/lang-swift.js","hash":"96ecf47954b110d6f46afde474dca4a8a36de641","modified":1495792659230},{"_id":"public/plugins/prettify/lang-tex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1495792659230},{"_id":"public/plugins/prettify/lang-tcl.js","hash":"38c918e9a43c8975074302305b8b8e5f30d513dc","modified":1495792659230},{"_id":"public/plugins/prettify/lang-vb.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1495792659230},{"_id":"public/plugins/prettify/lang-vbs.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1495792659230},{"_id":"public/plugins/prettify/lang-vhd.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1495792659230},{"_id":"public/plugins/prettify/lang-wiki.js","hash":"c4090580e86c5040709e6b8fd63b661f978149a6","modified":1495792659230},{"_id":"public/plugins/prettify/lang-vhdl.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1495792659231},{"_id":"public/plugins/prettify/lang-yaml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1495792659231},{"_id":"public/plugins/prettify/lang-yml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1495792659231},{"_id":"public/plugins/prettify/prettify.css","hash":"8e1c89c9a44e0e837551bdfe250a672d6c21f2b7","modified":1495792659231},{"_id":"public/plugins/prettify/prettify.js","hash":"d24b1da342b5c2d0582f0922118aaf0b2a6840d5","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-cave-dark.css","hash":"09f3cd75ed03ccc20fc8f817908102ed26219125","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-cave-dark.min.css","hash":"54c272f1d4262b8c1b6043ccc8ff4734b3b1c636","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-cave-light.css","hash":"46bbc73ac8a735e2d907be44d964d9ba96e8a16b","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-cave-light.min.css","hash":"2bbabca35533a5922fb1774db6eed9722ef0de3b","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-dune-dark.css","hash":"47dcb8b3b91aeedf9d74abe760a986c7a0f78a8e","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-dune-dark.min.css","hash":"af53930094ac7a64aaf607ab57ba5b01a09e8efc","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-dune-light.css","hash":"8237c95fc706fd01725144c7e852f586f5269b2c","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-dune-light.min.css","hash":"f7b9b5347f85a0ff22cbaca0d78949ac13fe3eb5","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-estuary-dark.css","hash":"fccbba89b0e1e42b3676291aaf3098e7c46169a6","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-estuary-dark.min.css","hash":"cbc1f5ec42e9f28af3891523f168b0899f978469","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-estuary-light.css","hash":"641351e6e00f73c0b06208dc21dde214105b5333","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-estuary-light.min.css","hash":"a93a4b8ba506b7c1e9135167c9ccf0691ee8ad07","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-forest-dark.css","hash":"750da2899332c401e63c77f0b79c1280f060a24d","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-forest-dark.min.css","hash":"955e4eeee93268be21cdda62c4f0e31242fc580a","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-forest-light.css","hash":"ca610b6c535dccd8442ff412683509f9b5f7d42c","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-forest-light.min.css","hash":"debca8705bb18a407dfcda63234f1f2b7aef2916","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-heath-dark.css","hash":"9f751e5e2f741a2ca802119a0b9629456777495a","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-heath-dark.min.css","hash":"98a3fea2b8ac476b48b52b757dad939ce80d20b3","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-heath-light.css","hash":"f7a03f2a997bba346a350bedfc860594af29768b","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-heath-light.min.css","hash":"e07b521484b1b4933c0e60ffa6bdfc29bf0c7ec2","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-lakeside-dark.css","hash":"1c0a402a9f8b243f3ef18895ab4a56fbfcf49a1f","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-lakeside-dark.min.css","hash":"b8208a6d6b6dcfa1c4da9a98095f4fe91b519cd5","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-lakeside-light.css","hash":"74c98a39d22780b038551ab6c2a30759b5425518","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-lakeside-light.min.css","hash":"89b917373b3763d4222a5106ba784239e3912a75","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-plateau-dark.css","hash":"5be42e7c5fdc012500d13db48ddeab95ae297916","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-plateau-dark.min.css","hash":"7de8a010c6cf7d0e5e29e017ca620a24399e62ff","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-plateau-light.css","hash":"6160404d0e976cf8e4d8621e6b7e2e8814541771","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-plateau-light.min.css","hash":"84dfbe203e661725913a73f0c573fc1c73565431","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-savanna-dark.css","hash":"d34b76751cdf2d8fbb11b15af27c0a9b88d2d181","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-savanna-dark.min.css","hash":"06322bcdaa36bb45948828705456ad158415c3f8","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-savanna-light.css","hash":"1a81911ada5f680e3af2a266cbebf68c8fc032aa","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-savanna-light.min.css","hash":"e363e8b856e9048b99dcb94e416aba9e7f1a9886","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-seaside-dark.css","hash":"0e649a5526ff0e3452be4519465f9282705e68b1","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-seaside-dark.min.css","hash":"696a18e6d4d639fd14490262f9a2626203c43fea","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-seaside-light.css","hash":"4eae4f7ac1a5bc9947c403942d2fb0daef697cac","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-sulphurpool-dark.css","hash":"e8d643b9e6276f76d0ca873da654ce1760694710","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-seaside-light.min.css","hash":"7c070b58bf089d259bf19309708452e6786e05a3","modified":1495792659231},{"_id":"public/plugins/prettify/themes/atelier-sulphurpool-dark.min.css","hash":"9718078d1e2208d44bf5ea9a5bfa331f7d8d1fdb","modified":1495792659232},{"_id":"public/plugins/prettify/themes/atelier-sulphurpool-light.css","hash":"ec816451c57efebb77025f04b9191a22c4e573e0","modified":1495792659232},{"_id":"public/plugins/prettify/themes/atelier-sulphurpool-light.min.css","hash":"4eb3ac86b14fdeb45b106580a8d80f359cbab57c","modified":1495792659232},{"_id":"public/plugins/prettify/themes/github-v2.css","hash":"8b9e795a1dc3e79ab68d07d007d659d685f935ee","modified":1495792659232},{"_id":"public/plugins/prettify/themes/github-v2.min.css","hash":"cb06bb61052646b33d19a37ad14d68cdd7405d98","modified":1495792659232},{"_id":"public/plugins/prettify/themes/github.css","hash":"741fde7dc9a25924f267dc251a018526525f6b98","modified":1495792659232},{"_id":"public/plugins/prettify/themes/github.min.css","hash":"b156639209d7b9b27d3a8cd92bdd676ad358c628","modified":1495792659232},{"_id":"public/plugins/prettify/themes/hemisu-dark.css","hash":"dbe6c7f5effeec9c332b7d2a95505f1167027922","modified":1495792659232},{"_id":"public/plugins/prettify/themes/hemisu-dark.min.css","hash":"ffc544c52368f725c2ab98d3e6e7a86aca1e31a2","modified":1495792659232},{"_id":"public/plugins/prettify/themes/hemisu-light.css","hash":"923d9f6fa7b043b90a212246acdafdaf363aefc0","modified":1495792659232},{"_id":"public/plugins/prettify/themes/hemisu-light.min.css","hash":"ae6bb465d1f5e28366c66827b8ba4a5924898c04","modified":1495792659232},{"_id":"public/plugins/prettify/themes/prettify.css","hash":"8e1c89c9a44e0e837551bdfe250a672d6c21f2b7","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night-blue.css","hash":"33e4483b73b72d561ec3ee6bac085a8ecfc07564","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night-blue.min.css","hash":"c78e33010239894f25eac66b1f0d5a7c310313f5","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night-bright.css","hash":"2a69a02e3820845a4e1f12c7ba4e00e8e61f15a9","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night-bright.min.css","hash":"0cbd70932ebee3aca4a86fd0e23773e920bc0d5e","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night-eighties.css","hash":"ab4a7ca393524f5c15c36ae46152a559cdcb2400","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night-eighties.min.css","hash":"f654ece8ef13e740f844ce593912e040e3f21e5f","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night.css","hash":"40d3a13e572b5e2743762aaff97738c3248acbf6","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow-night.min.css","hash":"5bb9910676b08e6d2a6eac5ef07e08754de14a01","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow.css","hash":"2b6bc58a2a889882a45be1c553f7f9a36f9b3f90","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tomorrow.min.css","hash":"1f61e1f9c60f8be82e3a8287a4f46d87b4551400","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tranquil-heart.css","hash":"cb601cf28f7ec08fd1a9700aa755f7cb1645ac4a","modified":1495792659232},{"_id":"public/plugins/prettify/themes/tranquil-heart.min.css","hash":"9c669545e3517de77f5cff50a58e4ef035855c87","modified":1495792659232},{"_id":"public/plugins/prettify/themes/vibrant-ink.css","hash":"db15bbca779664e13472a84146f7f010dc011799","modified":1495792659232},{"_id":"public/plugins/prettify/themes/vibrant-ink.min.css","hash":"feca319864faa3f8a6ae878553c1d960c7ff702f","modified":1495792659232},{"_id":"public/css/style.css","hash":"8a863f69252e4866cab080b0c2ec1cd6860f00d1","modified":1495792659232},{"_id":"public/plugins/prettify/lang-matlab.js","hash":"94c8fd7c44194dd3b1a444a3fc7c2b7fd09d9d6a","modified":1495792659232},{"_id":"public/plugins/prettify/lang-xq.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1495792659232},{"_id":"public/plugins/prettify/lang-xquery.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1495792659233},{"_id":"public/plugins/prettify/run_prettify.js","hash":"face8177a6804506c67c5644c00f3c6e0e50f02b","modified":1495792659233},{"_id":"public/background/bg-3.jpg","hash":"fffbee717d4f62e99b74270a5230d69c69e5258e","modified":1495792659233},{"_id":"public/background/bg-1.jpg","hash":"48339c3652e5df7bb3abc39526d526c1f9d74128","modified":1495792659247},{"_id":"public/background/bg-2.jpg","hash":"341d05b5b0243bc9a0c8cfcc57266796998ec56e","modified":1495792659247},{"_id":"public/background/bg-5.jpg","hash":"0f1d4d530a687b432413d7609071ebaeafdaa8a7","modified":1495792659249},{"_id":"public/background/bg-4.jpg","hash":"1b50569b1d65903a8bd220ccbb2dd882a5abbd71","modified":1495792659289}],"Category":[{"name":"设计模式","_id":"cj35obsuk0005qk5cvp0px1qh"},{"name":"Hibernate","_id":"cj35obsvz0014qk5czrw30kmv"},{"name":"随笔","_id":"cj35obsw3001eqk5cfq44bspj"},{"name":"Java","_id":"cj35obsw6001kqk5cqjm3rmv9"},{"name":"markdown","_id":"cj35obswb001rqk5cax7gai62"},{"name":"代码片段","_id":"cj35obswe001wqk5cgkt1q0jc"},{"name":"linux","_id":"cj35obswi0023qk5c927ctg65"},{"name":"知识整理","_id":"cj35obswj0026qk5ch2wgln1z"},{"name":"SpringBoot","_id":"cj35obswk002eqk5c0djnrg7s"},{"name":"折腾记","_id":"cj35obswl002mqk5c7dwz3kqv"},{"name":"安装部署","_id":"cj35obswl002qqk5c1yu25ffx"}],"Data":[],"Page":[{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"fancybox":false,"_content":"\n<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n***\n\n<div class=\"pic\">\n<img src=\"/resources/404.jpg\" title=\"404\">\n</div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\">\n 稍安勿躁，以下是博主推荐的歌曲，请您欣赏....\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"http://music.163.com/outchain/player?type=0&id=402231283&auto=0&height=430\"></iframe>\n</div>\n","source":"404/index.md","raw":"---\ntitle: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\nfancybox: false\n---\n\n<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n***\n\n<div class=\"pic\">\n<img src=\"/resources/404.jpg\" title=\"404\">\n</div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\">\n 稍安勿躁，以下是博主推荐的歌曲，请您欣赏....\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"http://music.163.com/outchain/player?type=0&id=402231283&auto=0&height=430\"></iframe>\n</div>\n","date":"2017-02-18T09:31:30.000Z","updated":"2017-02-18T09:31:30.000Z","path":"/404.html","layout":"page","_id":"cj35obsu70000qk5cssthc8u4","content":"<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n<hr>\n<div class=\"pic\"><br><img src=\"/resources/404.jpg\" title=\"404\"><br></div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\"><br> 稍安勿躁，以下是博主推荐的歌曲，请您欣赏….<br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"450\" src=\"http://music.163.com/outchain/player?type=0&id=402231283&auto=0&height=430\"></iframe><br></div>\n","excerpt":"","more":"<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n<hr>\n<div class=\"pic\"><br><img src=\"/resources/404.jpg\" title=\"404\"><br></div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\"><br> 稍安勿躁，以下是博主推荐的歌曲，请您欣赏….<br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"http://music.163.com/outchain/player?type=0&id=402231283&auto=0&height=430\"></iframe><br></div>\n"},{"title":"关于博主","date":"2016-07-13T15:34:11.000Z","_content":"\n90后码农，热爱生活，热爱自由，喜欢钻研，热衷于架构设计与开源技术，崇尚开源分享的技术精神，对各种技术都时刻保持强烈而又浓厚的兴趣，在此希望通过博客与志同道合的技术爱好者相互交流和学习！\n\n#### 联系我\n\nemail:[yja886@163.com](mail://yja886@163.com)\n\n微博: [http://weibo.com/u/1952610411](http://weibo.com/u/1952610411)\n\ngithub: [https://github.com/jumpbyte](https://github.com/jumpbyte)\n\n知乎: [https://www.zhihu.com/people/zhi-liao-95-64](https://www.zhihu.com/people/zhi-liao-95-64)\n\n豆瓣: [https://www.douban.com/people/114704639](https://www.douban.com/people/114704639)\n\n<hr/>\n\n对本博客有任何问题和建议，包括并不只限于此，聊人生，聊未来，聊规划...统统都可以在下方留言一起探讨交流哦！\n","source":"about/index.md","raw":"---\ntitle: 关于博主\ndate: 2016-07-13 23:34:11\n---\n\n90后码农，热爱生活，热爱自由，喜欢钻研，热衷于架构设计与开源技术，崇尚开源分享的技术精神，对各种技术都时刻保持强烈而又浓厚的兴趣，在此希望通过博客与志同道合的技术爱好者相互交流和学习！\n\n#### 联系我\n\nemail:[yja886@163.com](mail://yja886@163.com)\n\n微博: [http://weibo.com/u/1952610411](http://weibo.com/u/1952610411)\n\ngithub: [https://github.com/jumpbyte](https://github.com/jumpbyte)\n\n知乎: [https://www.zhihu.com/people/zhi-liao-95-64](https://www.zhihu.com/people/zhi-liao-95-64)\n\n豆瓣: [https://www.douban.com/people/114704639](https://www.douban.com/people/114704639)\n\n<hr/>\n\n对本博客有任何问题和建议，包括并不只限于此，聊人生，聊未来，聊规划...统统都可以在下方留言一起探讨交流哦！\n","updated":"2017-02-18T09:31:30.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj35obsud0002qk5c4rdmo7po","content":"<p>90后码农，热爱生活，热爱自由，喜欢钻研，热衷于架构设计与开源技术，崇尚开源分享的技术精神，对各种技术都时刻保持强烈而又浓厚的兴趣，在此希望通过博客与志同道合的技术爱好者相互交流和学习！</p>\n<h4 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h4><p>email:<a href=\"mail://yja886@163.com\" target=\"_blank\" rel=\"external\">yja886@163.com</a></p>\n<p>微博: <a href=\"http://weibo.com/u/1952610411\" target=\"_blank\" rel=\"external\">http://weibo.com/u/1952610411</a></p>\n<p>github: <a href=\"https://github.com/jumpbyte\" target=\"_blank\" rel=\"external\">https://github.com/jumpbyte</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/zhi-liao-95-64\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/people/zhi-liao-95-64</a></p>\n<p>豆瓣: <a href=\"https://www.douban.com/people/114704639\" target=\"_blank\" rel=\"external\">https://www.douban.com/people/114704639</a></p>\n<hr>\n\n<p>对本博客有任何问题和建议，包括并不只限于此，聊人生，聊未来，聊规划…统统都可以在下方留言一起探讨交流哦！</p>\n","excerpt":"","more":"<p>90后码农，热爱生活，热爱自由，喜欢钻研，热衷于架构设计与开源技术，崇尚开源分享的技术精神，对各种技术都时刻保持强烈而又浓厚的兴趣，在此希望通过博客与志同道合的技术爱好者相互交流和学习！</p>\n<h4 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h4><p>email:<a href=\"mail://yja886@163.com\">yja886@163.com</a></p>\n<p>微博: <a href=\"http://weibo.com/u/1952610411\">http://weibo.com/u/1952610411</a></p>\n<p>github: <a href=\"https://github.com/jumpbyte\">https://github.com/jumpbyte</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/zhi-liao-95-64\">https://www.zhihu.com/people/zhi-liao-95-64</a></p>\n<p>豆瓣: <a href=\"https://www.douban.com/people/114704639\">https://www.douban.com/people/114704639</a></p>\n<hr/>\n\n<p>对本博客有任何问题和建议，包括并不只限于此，聊人生，聊未来，聊规划…统统都可以在下方留言一起探讨交流哦！</p>\n"},{"title":"文章分类及标签列表","toc":false,"type":"tags","comments":0,"date":"2016-07-15T03:09:54.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: 文章分类及标签列表\ntoc: false\ntype: \"tags\"\ncomments: false\ndate: 2016-07-15 11:09:54\n---\n","updated":"2017-02-18T09:31:30.000Z","path":"tags/index.html","layout":"page","_id":"cj35obsul0006qk5coghx5sbt","content":"","excerpt":"","more":""}],"Post":[{"title":"面向对象设计模式之AbstractFactory抽象工厂模式（创建型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n在软件系统中，经常面临着“系列相互依赖的对象”的创建工作：同时，由于需求的变化，往往存在更多系列对象 的创建工作；如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？\n\n<!--more-->\n\n### 意图\n\n提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。\n\n\n### 适用性\n\n1. 一个系统要独立于它的产品的创建、组合和表示时。\n2. 一个系统要由多个产品系列中的一个来配置时。\n3. 当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n4. 当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n\n\n### UML图解\n\n![AbstractFactory UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/51035923.jpg)\n\n*注：图片来源与网络，在此表示感谢*\n\n\n### 示例\n\n假设在一个游戏场景中，其中有一些场景设施，房屋，道路，隧道,丛林等等，每种设施都有几种不同的风格（古老风格，现代风格等），游戏可能会在不同的风格中进行切换，此时我们如何去应对风格切换带来游戏场景设施对象的变化？抽象工厂模式就可以运用于此。\n\n首先，对我们游戏场景的一系列设施进行对象抽象化\n```C#\n/// <summary>\n/// 路（抽象类）\n/// </summary>\npublic abstract class Road\n{\n\n}\n\n/// <summary>\n/// 房屋（抽象类）\n/// </summary>\npublic abstract class Building\n{\n\n}\n\n/// <summary>\n/// 隧道（抽象类）\n/// </summary>\npublic abstract class Tunnel\n{\n\n}\n/// <summary>\n/// 丛林（抽象类）\n/// </summary>\npublic abstract class Jungle\n{\n\n}\n```\n其具体风格的场景设施子类如下\n\n**现代风格基础场景设施子类**\n```C#\n// <summary>\n/// 现代风格的路\n/// </summary>\npublic  class ModernRoad:Road\n{\n\n}\n\n/// <summary>\n/// 现代风格的房屋\n/// </summary>\npublic class ModernBuilding:Building\n{\n\n}\n\n/// <summary>\n/// 现代风格的隧道\n/// </summary>\npublic class ModernTunnel:Tunnel\n{\n\n}\n/// <summary>\n/// 现代风格的丛林\n/// </summary>\npublic class ModernJungle:Jungle\n{\n\n}\n```\n\n**古老风格场景设施子类**\n\n```C#\n/// <summary>\n/// 古老风格的路\n/// </summary>\npublic class AncientRoad : Road\n{\n\n}\n\n/// <summary>\n/// 古老风格的房屋\n/// </summary>\npublic class AncientBuilding : Building\n{\n\n}\n\n/// <summary>\n/// 古老风格的隧道\n/// </summary>\npublic class AncientTunnel : Tunnel\n{\n\n}\n/// <summary>\n/// 古老风格的丛林\n/// </summary>\npublic class AncientJungle : Jungle\n{\n\n}\n```\n\n接下来，我们要使用工厂创建这些子类，但对于不同风格的子类，我们要用不同风格的工厂类去创建，所以我们需要定一个抽象工厂类，然后派生出不同风格的具体工厂类\n\n```C#\n/// <summary>\n/// 场景设施抽象创建工厂类\n/// </summary>\npublic abstract class FacilitiesFactory\n{\n    public abstract Road CreateRoad();\n    public abstract Building CreateBuilding();\n    public abstract Tunnel CreateTunnel();\n    public abstract Jungle CreateJungle();\n}\n```\n\n现代风格和古老风格工厂类，继承自场景设施抽象创建工厂类\n\n```C#\n/// <summary>\n/// 现代风格的对象创建工厂类\n/// </summary>\npublic class ModernFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new ModernRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new ModernBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new ModernTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new ModernJungle();\n    }\n}\n\n/// <summary>\n/// 古代风格的对象创建工厂类\n/// </summary>\npublic class AncientFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new AncientRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new AncientBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new AncientTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new AncientJungle();\n    }\n}\n```\n\n然后，客户程序中我们就可以使用不同的工厂去创建不同风格的场景设施\n\n```C#\n/// <summary>\n/// 假设此类为客户程序\n/// </summary>\npublic class GameManager\n{\n    /***\n     * 当需要增加另一种风格的场景时，只需要继承对应的抽象类实现此风格下的实例对象类和具体工厂类即可\n     * 而客户程序无需改动或改动甚少，这既是这种设计模式的优势\n     * ***/\n    FacilitiesFactory _facilitiesfactory;\n    Road road;\n    Building building;\n    Tunnel tunnel;\n    Jungle jungle;\n    public GameManager(FacilitiesFactory facilitiesfactory )\n    {\n        this._facilitiesfactory = facilitiesfactory;\n    }\n\n    /// <summary>\n    /// 创建游戏场景\n    /// </summary>\n    public void BuildGameFacilities()\n    {\n        road = _facilitiesfactory.CreateRoad();\n        building = _facilitiesfactory.CreateBuilding();\n        tunnel = _facilitiesfactory.CreateTunnel();\n        jungle = _facilitiesfactory.CreateJungle();\n    }\n\n    /// <summary>\n    /// 开始游戏\n    /// </summary>\n    public void Play()\n    {\n\n    }\n}\n\npublic class App\n{\n    public static void Main()\n    {\n        FacilitiesFactory ff = new ModernFacilitiesFactory();\n        GameManager game = new GameManager(ff);\n        game.BuildGameFacilities();\n        game.Play();\n    }\n}\n```\n如此，在客户端代码中，想使用什么风格的场景设施，只要在new的时候指定具体风格的工厂类，即可实现不同场景设施风格的切换\n\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353829.html)\n","source":"_posts/AbstractFactory.md","raw":"---\ntitle: 面向对象设计模式之AbstractFactory抽象工厂模式（创建型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['AbstractFactory','抽象工厂模式']\n---\n\n### 动机\n\n在软件系统中，经常面临着“系列相互依赖的对象”的创建工作：同时，由于需求的变化，往往存在更多系列对象 的创建工作；如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？\n\n<!--more-->\n\n### 意图\n\n提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。\n\n\n### 适用性\n\n1. 一个系统要独立于它的产品的创建、组合和表示时。\n2. 一个系统要由多个产品系列中的一个来配置时。\n3. 当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n4. 当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n\n\n### UML图解\n\n![AbstractFactory UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/51035923.jpg)\n\n*注：图片来源与网络，在此表示感谢*\n\n\n### 示例\n\n假设在一个游戏场景中，其中有一些场景设施，房屋，道路，隧道,丛林等等，每种设施都有几种不同的风格（古老风格，现代风格等），游戏可能会在不同的风格中进行切换，此时我们如何去应对风格切换带来游戏场景设施对象的变化？抽象工厂模式就可以运用于此。\n\n首先，对我们游戏场景的一系列设施进行对象抽象化\n```C#\n/// <summary>\n/// 路（抽象类）\n/// </summary>\npublic abstract class Road\n{\n\n}\n\n/// <summary>\n/// 房屋（抽象类）\n/// </summary>\npublic abstract class Building\n{\n\n}\n\n/// <summary>\n/// 隧道（抽象类）\n/// </summary>\npublic abstract class Tunnel\n{\n\n}\n/// <summary>\n/// 丛林（抽象类）\n/// </summary>\npublic abstract class Jungle\n{\n\n}\n```\n其具体风格的场景设施子类如下\n\n**现代风格基础场景设施子类**\n```C#\n// <summary>\n/// 现代风格的路\n/// </summary>\npublic  class ModernRoad:Road\n{\n\n}\n\n/// <summary>\n/// 现代风格的房屋\n/// </summary>\npublic class ModernBuilding:Building\n{\n\n}\n\n/// <summary>\n/// 现代风格的隧道\n/// </summary>\npublic class ModernTunnel:Tunnel\n{\n\n}\n/// <summary>\n/// 现代风格的丛林\n/// </summary>\npublic class ModernJungle:Jungle\n{\n\n}\n```\n\n**古老风格场景设施子类**\n\n```C#\n/// <summary>\n/// 古老风格的路\n/// </summary>\npublic class AncientRoad : Road\n{\n\n}\n\n/// <summary>\n/// 古老风格的房屋\n/// </summary>\npublic class AncientBuilding : Building\n{\n\n}\n\n/// <summary>\n/// 古老风格的隧道\n/// </summary>\npublic class AncientTunnel : Tunnel\n{\n\n}\n/// <summary>\n/// 古老风格的丛林\n/// </summary>\npublic class AncientJungle : Jungle\n{\n\n}\n```\n\n接下来，我们要使用工厂创建这些子类，但对于不同风格的子类，我们要用不同风格的工厂类去创建，所以我们需要定一个抽象工厂类，然后派生出不同风格的具体工厂类\n\n```C#\n/// <summary>\n/// 场景设施抽象创建工厂类\n/// </summary>\npublic abstract class FacilitiesFactory\n{\n    public abstract Road CreateRoad();\n    public abstract Building CreateBuilding();\n    public abstract Tunnel CreateTunnel();\n    public abstract Jungle CreateJungle();\n}\n```\n\n现代风格和古老风格工厂类，继承自场景设施抽象创建工厂类\n\n```C#\n/// <summary>\n/// 现代风格的对象创建工厂类\n/// </summary>\npublic class ModernFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new ModernRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new ModernBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new ModernTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new ModernJungle();\n    }\n}\n\n/// <summary>\n/// 古代风格的对象创建工厂类\n/// </summary>\npublic class AncientFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new AncientRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new AncientBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new AncientTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new AncientJungle();\n    }\n}\n```\n\n然后，客户程序中我们就可以使用不同的工厂去创建不同风格的场景设施\n\n```C#\n/// <summary>\n/// 假设此类为客户程序\n/// </summary>\npublic class GameManager\n{\n    /***\n     * 当需要增加另一种风格的场景时，只需要继承对应的抽象类实现此风格下的实例对象类和具体工厂类即可\n     * 而客户程序无需改动或改动甚少，这既是这种设计模式的优势\n     * ***/\n    FacilitiesFactory _facilitiesfactory;\n    Road road;\n    Building building;\n    Tunnel tunnel;\n    Jungle jungle;\n    public GameManager(FacilitiesFactory facilitiesfactory )\n    {\n        this._facilitiesfactory = facilitiesfactory;\n    }\n\n    /// <summary>\n    /// 创建游戏场景\n    /// </summary>\n    public void BuildGameFacilities()\n    {\n        road = _facilitiesfactory.CreateRoad();\n        building = _facilitiesfactory.CreateBuilding();\n        tunnel = _facilitiesfactory.CreateTunnel();\n        jungle = _facilitiesfactory.CreateJungle();\n    }\n\n    /// <summary>\n    /// 开始游戏\n    /// </summary>\n    public void Play()\n    {\n\n    }\n}\n\npublic class App\n{\n    public static void Main()\n    {\n        FacilitiesFactory ff = new ModernFacilitiesFactory();\n        GameManager game = new GameManager(ff);\n        game.BuildGameFacilities();\n        game.Play();\n    }\n}\n```\n如此，在客户端代码中，想使用什么风格的场景设施，只要在new的时候指定具体风格的工厂类，即可实现不同场景设施风格的切换\n\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353829.html)\n","slug":"AbstractFactory","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsua0001qk5c9j54wh5j","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，经常面临着“系列相互依赖的对象”的创建工作：同时，由于需求的变化，往往存在更多系列对象 的创建工作；如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li>一个系统要独立于它的产品的创建、组合和表示时。</li>\n<li>一个系统要由多个产品系列中的一个来配置时。</li>\n<li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li>\n<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/51035923.jpg\" alt=\"AbstractFactory UML图解\"></p>\n<p><em>注：图片来源与网络，在此表示感谢</em></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>假设在一个游戏场景中，其中有一些场景设施，房屋，道路，隧道,丛林等等，每种设施都有几种不同的风格（古老风格，现代风格等），游戏可能会在不同的风格中进行切换，此时我们如何去应对风格切换带来游戏场景设施对象的变化？抽象工厂模式就可以运用于此。</p>\n<p>首先，对我们游戏场景的一系列设施进行对象抽象化</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 路（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Road\n{\n\n}\n\n/// &lt;summary&gt;\n/// 房屋（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Building\n{\n\n}\n\n/// &lt;summary&gt;\n/// 隧道（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Tunnel\n{\n\n}\n/// &lt;summary&gt;\n/// 丛林（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Jungle\n{\n\n}\n</code></pre>\n<p>其具体风格的场景设施子类如下</p>\n<p><strong>现代风格基础场景设施子类</strong></p>\n<pre><code class=\"C#\">// &lt;summary&gt;\n/// 现代风格的路\n/// &lt;/summary&gt;\npublic  class ModernRoad:Road\n{\n\n}\n\n/// &lt;summary&gt;\n/// 现代风格的房屋\n/// &lt;/summary&gt;\npublic class ModernBuilding:Building\n{\n\n}\n\n/// &lt;summary&gt;\n/// 现代风格的隧道\n/// &lt;/summary&gt;\npublic class ModernTunnel:Tunnel\n{\n\n}\n/// &lt;summary&gt;\n/// 现代风格的丛林\n/// &lt;/summary&gt;\npublic class ModernJungle:Jungle\n{\n\n}\n</code></pre>\n<p><strong>古老风格场景设施子类</strong></p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 古老风格的路\n/// &lt;/summary&gt;\npublic class AncientRoad : Road\n{\n\n}\n\n/// &lt;summary&gt;\n/// 古老风格的房屋\n/// &lt;/summary&gt;\npublic class AncientBuilding : Building\n{\n\n}\n\n/// &lt;summary&gt;\n/// 古老风格的隧道\n/// &lt;/summary&gt;\npublic class AncientTunnel : Tunnel\n{\n\n}\n/// &lt;summary&gt;\n/// 古老风格的丛林\n/// &lt;/summary&gt;\npublic class AncientJungle : Jungle\n{\n\n}\n</code></pre>\n<p>接下来，我们要使用工厂创建这些子类，但对于不同风格的子类，我们要用不同风格的工厂类去创建，所以我们需要定一个抽象工厂类，然后派生出不同风格的具体工厂类</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 场景设施抽象创建工厂类\n/// &lt;/summary&gt;\npublic abstract class FacilitiesFactory\n{\n    public abstract Road CreateRoad();\n    public abstract Building CreateBuilding();\n    public abstract Tunnel CreateTunnel();\n    public abstract Jungle CreateJungle();\n}\n</code></pre>\n<p>现代风格和古老风格工厂类，继承自场景设施抽象创建工厂类</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 现代风格的对象创建工厂类\n/// &lt;/summary&gt;\npublic class ModernFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new ModernRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new ModernBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new ModernTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new ModernJungle();\n    }\n}\n\n/// &lt;summary&gt;\n/// 古代风格的对象创建工厂类\n/// &lt;/summary&gt;\npublic class AncientFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new AncientRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new AncientBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new AncientTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new AncientJungle();\n    }\n}\n</code></pre>\n<p>然后，客户程序中我们就可以使用不同的工厂去创建不同风格的场景设施</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 假设此类为客户程序\n/// &lt;/summary&gt;\npublic class GameManager\n{\n    /***\n     * 当需要增加另一种风格的场景时，只需要继承对应的抽象类实现此风格下的实例对象类和具体工厂类即可\n     * 而客户程序无需改动或改动甚少，这既是这种设计模式的优势\n     * ***/\n    FacilitiesFactory _facilitiesfactory;\n    Road road;\n    Building building;\n    Tunnel tunnel;\n    Jungle jungle;\n    public GameManager(FacilitiesFactory facilitiesfactory )\n    {\n        this._facilitiesfactory = facilitiesfactory;\n    }\n\n    /// &lt;summary&gt;\n    /// 创建游戏场景\n    /// &lt;/summary&gt;\n    public void BuildGameFacilities()\n    {\n        road = _facilitiesfactory.CreateRoad();\n        building = _facilitiesfactory.CreateBuilding();\n        tunnel = _facilitiesfactory.CreateTunnel();\n        jungle = _facilitiesfactory.CreateJungle();\n    }\n\n    /// &lt;summary&gt;\n    /// 开始游戏\n    /// &lt;/summary&gt;\n    public void Play()\n    {\n\n    }\n}\n\npublic class App\n{\n    public static void Main()\n    {\n        FacilitiesFactory ff = new ModernFacilitiesFactory();\n        GameManager game = new GameManager(ff);\n        game.BuildGameFacilities();\n        game.Play();\n    }\n}\n</code></pre>\n<p>如此，在客户端代码中，想使用什么风格的场景设施，只要在new的时候指定具体风格的工厂类，即可实现不同场景设施风格的切换</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353829.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，经常面临着“系列相互依赖的对象”的创建工作：同时，由于需求的变化，往往存在更多系列对象 的创建工作；如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li>一个系统要独立于它的产品的创建、组合和表示时。</li>\n<li>一个系统要由多个产品系列中的一个来配置时。</li>\n<li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li>\n<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/51035923.jpg\" alt=\"AbstractFactory UML图解\"></p>\n<p><em>注：图片来源与网络，在此表示感谢</em></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>假设在一个游戏场景中，其中有一些场景设施，房屋，道路，隧道,丛林等等，每种设施都有几种不同的风格（古老风格，现代风格等），游戏可能会在不同的风格中进行切换，此时我们如何去应对风格切换带来游戏场景设施对象的变化？抽象工厂模式就可以运用于此。</p>\n<p>首先，对我们游戏场景的一系列设施进行对象抽象化</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 路（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Road\n{\n\n}\n\n/// &lt;summary&gt;\n/// 房屋（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Building\n{\n\n}\n\n/// &lt;summary&gt;\n/// 隧道（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Tunnel\n{\n\n}\n/// &lt;summary&gt;\n/// 丛林（抽象类）\n/// &lt;/summary&gt;\npublic abstract class Jungle\n{\n\n}\n</code></pre>\n<p>其具体风格的场景设施子类如下</p>\n<p><strong>现代风格基础场景设施子类</strong></p>\n<pre><code class=\"C#\">// &lt;summary&gt;\n/// 现代风格的路\n/// &lt;/summary&gt;\npublic  class ModernRoad:Road\n{\n\n}\n\n/// &lt;summary&gt;\n/// 现代风格的房屋\n/// &lt;/summary&gt;\npublic class ModernBuilding:Building\n{\n\n}\n\n/// &lt;summary&gt;\n/// 现代风格的隧道\n/// &lt;/summary&gt;\npublic class ModernTunnel:Tunnel\n{\n\n}\n/// &lt;summary&gt;\n/// 现代风格的丛林\n/// &lt;/summary&gt;\npublic class ModernJungle:Jungle\n{\n\n}\n</code></pre>\n<p><strong>古老风格场景设施子类</strong></p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 古老风格的路\n/// &lt;/summary&gt;\npublic class AncientRoad : Road\n{\n\n}\n\n/// &lt;summary&gt;\n/// 古老风格的房屋\n/// &lt;/summary&gt;\npublic class AncientBuilding : Building\n{\n\n}\n\n/// &lt;summary&gt;\n/// 古老风格的隧道\n/// &lt;/summary&gt;\npublic class AncientTunnel : Tunnel\n{\n\n}\n/// &lt;summary&gt;\n/// 古老风格的丛林\n/// &lt;/summary&gt;\npublic class AncientJungle : Jungle\n{\n\n}\n</code></pre>\n<p>接下来，我们要使用工厂创建这些子类，但对于不同风格的子类，我们要用不同风格的工厂类去创建，所以我们需要定一个抽象工厂类，然后派生出不同风格的具体工厂类</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 场景设施抽象创建工厂类\n/// &lt;/summary&gt;\npublic abstract class FacilitiesFactory\n{\n    public abstract Road CreateRoad();\n    public abstract Building CreateBuilding();\n    public abstract Tunnel CreateTunnel();\n    public abstract Jungle CreateJungle();\n}\n</code></pre>\n<p>现代风格和古老风格工厂类，继承自场景设施抽象创建工厂类</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 现代风格的对象创建工厂类\n/// &lt;/summary&gt;\npublic class ModernFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new ModernRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new ModernBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new ModernTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new ModernJungle();\n    }\n}\n\n/// &lt;summary&gt;\n/// 古代风格的对象创建工厂类\n/// &lt;/summary&gt;\npublic class AncientFacilitiesFactory : FacilitiesFactory\n{\n\n    public override Road CreateRoad()\n    {\n        return new AncientRoad();\n    }\n\n    public override Building CreateBuilding()\n    {\n        return new AncientBuilding();\n    }\n\n    public override Tunnel CreateTunnel()\n    {\n        return new AncientTunnel();\n    }\n\n    public override Jungle CreateJungle()\n    {\n        return new AncientJungle();\n    }\n}\n</code></pre>\n<p>然后，客户程序中我们就可以使用不同的工厂去创建不同风格的场景设施</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 假设此类为客户程序\n/// &lt;/summary&gt;\npublic class GameManager\n{\n    /***\n     * 当需要增加另一种风格的场景时，只需要继承对应的抽象类实现此风格下的实例对象类和具体工厂类即可\n     * 而客户程序无需改动或改动甚少，这既是这种设计模式的优势\n     * ***/\n    FacilitiesFactory _facilitiesfactory;\n    Road road;\n    Building building;\n    Tunnel tunnel;\n    Jungle jungle;\n    public GameManager(FacilitiesFactory facilitiesfactory )\n    {\n        this._facilitiesfactory = facilitiesfactory;\n    }\n\n    /// &lt;summary&gt;\n    /// 创建游戏场景\n    /// &lt;/summary&gt;\n    public void BuildGameFacilities()\n    {\n        road = _facilitiesfactory.CreateRoad();\n        building = _facilitiesfactory.CreateBuilding();\n        tunnel = _facilitiesfactory.CreateTunnel();\n        jungle = _facilitiesfactory.CreateJungle();\n    }\n\n    /// &lt;summary&gt;\n    /// 开始游戏\n    /// &lt;/summary&gt;\n    public void Play()\n    {\n\n    }\n}\n\npublic class App\n{\n    public static void Main()\n    {\n        FacilitiesFactory ff = new ModernFacilitiesFactory();\n        GameManager game = new GameManager(ff);\n        game.BuildGameFacilities();\n        game.Play();\n    }\n}\n</code></pre>\n<p>如此，在客户端代码中，想使用什么风格的场景设施，只要在new的时候指定具体风格的工厂类，即可实现不同场景设施风格的切换</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353829.html\">这里</a></p>"},{"title":"面向对象设计模式之Adapter适配器模式（结构型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口使这些现存对象所不满足的。如何应对这种“迁移的变化”？如何即能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？\n\n<!--more-->\n\n### 意图\n\n将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\n\n\n### 可适用性\n\n1. 你想使用一个已经存在的类，而它的接口不符合你的需求。\n2. 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。\n3. （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口\n\n### UML图解\n\n![适配器模式UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/36475031.jpg)\n\n\n### 示例\n\n根据上面的UML图，我们可以用代码来实际演示如何具体应用此模式\n\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Adapter\n{\n    /// <summary>\n    /// 客户所需要期待的接口\n    /// </summary>\n    public abstract class  Target\n    {\n        public abstract  void Request();\n\n    }\n    /// <summary>\n    /// 需要适配的类\n    /// </summary>\n    public class Adaptee\n    {\n        public void SpecificRequest()\n        {\n            Console.WriteLine(\"特殊请求！\");\n        }\n    }\n\n    /// <summary>\n    /// 通过内部接口包装一个Adaptee对象，将源接口转换成目标接口\n    /// </summary>\n    public class Adapter:Target\n    {\n        Adaptee _adaptee = new Adaptee();//适配对象，也可通过参数传递\n\n        public override void Request()\n        {\n            //这样就可以把表面上调用Request()方法变成实际调用SpecificRequest()\n            _adaptee.SpecificRequest();  \n        }\n    }\n\n    public class Client\n    {\n       public  static void Main()\n        {\n            Target target = new Adapter();\n            target.Request();//对客户端来说，调用的就是Target的Request();\n        }\n    }\n}\n```\n\n### 适配器模式在.NET中的应用\n\n1. 在.NET中复用COM对象：COM对象不符合.NET对象的接口；它使用tlbimp.exe来创建一个Runtime Callable Wrapper(RCW)以使其符合.NET对象的接口\n2. NET数据访问类（Adapter变体）：各种数据库并没有提供DataSet接口；使用DbDataAdapter可以将任何各种数据库访问/存取适配到一个DataSet对象上。\n3. 集合类中对现有对象的排序（Adapter变体）：现有对象未实现IComparable接口；实现一个排序适配器（继承IComparer接口），然后在其Compare方法中对两个对象进行比较\n\n### 几个要点\n\n1. Adapter模式主要应用于“希望复用一些现存的类，但是接口又于复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用\n2. GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现\n方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。\n3. Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的\n4. Adapter模式本身要求我们尽可能的使用“面向接口的编程”风格，这样才能在后期很方便地适配\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178774.html)\n","source":"_posts/Adapter.md","raw":"---\ntitle: 面向对象设计模式之Adapter适配器模式（结构型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Adapter','适配器模式']\n---\n\n### 动机\n\n在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口使这些现存对象所不满足的。如何应对这种“迁移的变化”？如何即能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？\n\n<!--more-->\n\n### 意图\n\n将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\n\n\n### 可适用性\n\n1. 你想使用一个已经存在的类，而它的接口不符合你的需求。\n2. 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。\n3. （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口\n\n### UML图解\n\n![适配器模式UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/36475031.jpg)\n\n\n### 示例\n\n根据上面的UML图，我们可以用代码来实际演示如何具体应用此模式\n\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Adapter\n{\n    /// <summary>\n    /// 客户所需要期待的接口\n    /// </summary>\n    public abstract class  Target\n    {\n        public abstract  void Request();\n\n    }\n    /// <summary>\n    /// 需要适配的类\n    /// </summary>\n    public class Adaptee\n    {\n        public void SpecificRequest()\n        {\n            Console.WriteLine(\"特殊请求！\");\n        }\n    }\n\n    /// <summary>\n    /// 通过内部接口包装一个Adaptee对象，将源接口转换成目标接口\n    /// </summary>\n    public class Adapter:Target\n    {\n        Adaptee _adaptee = new Adaptee();//适配对象，也可通过参数传递\n\n        public override void Request()\n        {\n            //这样就可以把表面上调用Request()方法变成实际调用SpecificRequest()\n            _adaptee.SpecificRequest();  \n        }\n    }\n\n    public class Client\n    {\n       public  static void Main()\n        {\n            Target target = new Adapter();\n            target.Request();//对客户端来说，调用的就是Target的Request();\n        }\n    }\n}\n```\n\n### 适配器模式在.NET中的应用\n\n1. 在.NET中复用COM对象：COM对象不符合.NET对象的接口；它使用tlbimp.exe来创建一个Runtime Callable Wrapper(RCW)以使其符合.NET对象的接口\n2. NET数据访问类（Adapter变体）：各种数据库并没有提供DataSet接口；使用DbDataAdapter可以将任何各种数据库访问/存取适配到一个DataSet对象上。\n3. 集合类中对现有对象的排序（Adapter变体）：现有对象未实现IComparable接口；实现一个排序适配器（继承IComparer接口），然后在其Compare方法中对两个对象进行比较\n\n### 几个要点\n\n1. Adapter模式主要应用于“希望复用一些现存的类，但是接口又于复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用\n2. GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现\n方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。\n3. Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的\n4. Adapter模式本身要求我们尽可能的使用“面向接口的编程”风格，这样才能在后期很方便地适配\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178774.html)\n","slug":"Adapter","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsuf0003qk5ceylbzee0","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口使这些现存对象所不满足的。如何应对这种“迁移的变化”？如何即能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>\n<h3 id=\"可适用性\"><a href=\"#可适用性\" class=\"headerlink\" title=\"可适用性\"></a>可适用性</h3><ol>\n<li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li>\n<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li>\n<li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/36475031.jpg\" alt=\"适配器模式UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>根据上面的UML图，我们可以用代码来实际演示如何具体应用此模式</p>\n<pre><code class=\"C#\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Adapter\n{\n    /// &lt;summary&gt;\n    /// 客户所需要期待的接口\n    /// &lt;/summary&gt;\n    public abstract class  Target\n    {\n        public abstract  void Request();\n\n    }\n    /// &lt;summary&gt;\n    /// 需要适配的类\n    /// &lt;/summary&gt;\n    public class Adaptee\n    {\n        public void SpecificRequest()\n        {\n            Console.WriteLine(&quot;特殊请求！&quot;);\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 通过内部接口包装一个Adaptee对象，将源接口转换成目标接口\n    /// &lt;/summary&gt;\n    public class Adapter:Target\n    {\n        Adaptee _adaptee = new Adaptee();//适配对象，也可通过参数传递\n\n        public override void Request()\n        {\n            //这样就可以把表面上调用Request()方法变成实际调用SpecificRequest()\n            _adaptee.SpecificRequest();  \n        }\n    }\n\n    public class Client\n    {\n       public  static void Main()\n        {\n            Target target = new Adapter();\n            target.Request();//对客户端来说，调用的就是Target的Request();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"适配器模式在-NET中的应用\"><a href=\"#适配器模式在-NET中的应用\" class=\"headerlink\" title=\"适配器模式在.NET中的应用\"></a>适配器模式在.NET中的应用</h3><ol>\n<li>在.NET中复用COM对象：COM对象不符合.NET对象的接口；它使用tlbimp.exe来创建一个Runtime Callable Wrapper(RCW)以使其符合.NET对象的接口</li>\n<li>NET数据访问类（Adapter变体）：各种数据库并没有提供DataSet接口；使用DbDataAdapter可以将任何各种数据库访问/存取适配到一个DataSet对象上。</li>\n<li>集合类中对现有对象的排序（Adapter变体）：现有对象未实现IComparable接口；实现一个排序适配器（继承IComparer接口），然后在其Compare方法中对两个对象进行比较</li>\n</ol>\n<h3 id=\"几个要点\"><a href=\"#几个要点\" class=\"headerlink\" title=\"几个要点\"></a>几个要点</h3><ol>\n<li>Adapter模式主要应用于“希望复用一些现存的类，但是接口又于复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用</li>\n<li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现<br>方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</li>\n<li>Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的</li>\n<li>Adapter模式本身要求我们尽可能的使用“面向接口的编程”风格，这样才能在后期很方便地适配</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178774.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口使这些现存对象所不满足的。如何应对这种“迁移的变化”？如何即能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>\n<h3 id=\"可适用性\"><a href=\"#可适用性\" class=\"headerlink\" title=\"可适用性\"></a>可适用性</h3><ol>\n<li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li>\n<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li>\n<li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/36475031.jpg\" alt=\"适配器模式UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>根据上面的UML图，我们可以用代码来实际演示如何具体应用此模式</p>\n<pre><code class=\"C#\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Adapter\n{\n    /// &lt;summary&gt;\n    /// 客户所需要期待的接口\n    /// &lt;/summary&gt;\n    public abstract class  Target\n    {\n        public abstract  void Request();\n\n    }\n    /// &lt;summary&gt;\n    /// 需要适配的类\n    /// &lt;/summary&gt;\n    public class Adaptee\n    {\n        public void SpecificRequest()\n        {\n            Console.WriteLine(&quot;特殊请求！&quot;);\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 通过内部接口包装一个Adaptee对象，将源接口转换成目标接口\n    /// &lt;/summary&gt;\n    public class Adapter:Target\n    {\n        Adaptee _adaptee = new Adaptee();//适配对象，也可通过参数传递\n\n        public override void Request()\n        {\n            //这样就可以把表面上调用Request()方法变成实际调用SpecificRequest()\n            _adaptee.SpecificRequest();  \n        }\n    }\n\n    public class Client\n    {\n       public  static void Main()\n        {\n            Target target = new Adapter();\n            target.Request();//对客户端来说，调用的就是Target的Request();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"适配器模式在-NET中的应用\"><a href=\"#适配器模式在-NET中的应用\" class=\"headerlink\" title=\"适配器模式在.NET中的应用\"></a>适配器模式在.NET中的应用</h3><ol>\n<li>在.NET中复用COM对象：COM对象不符合.NET对象的接口；它使用tlbimp.exe来创建一个Runtime Callable Wrapper(RCW)以使其符合.NET对象的接口</li>\n<li>NET数据访问类（Adapter变体）：各种数据库并没有提供DataSet接口；使用DbDataAdapter可以将任何各种数据库访问/存取适配到一个DataSet对象上。</li>\n<li>集合类中对现有对象的排序（Adapter变体）：现有对象未实现IComparable接口；实现一个排序适配器（继承IComparer接口），然后在其Compare方法中对两个对象进行比较</li>\n</ol>\n<h3 id=\"几个要点\"><a href=\"#几个要点\" class=\"headerlink\" title=\"几个要点\"></a>几个要点</h3><ol>\n<li>Adapter模式主要应用于“希望复用一些现存的类，但是接口又于复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用</li>\n<li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现<br>方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</li>\n<li>Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的</li>\n<li>Adapter模式本身要求我们尽可能的使用“面向接口的编程”风格，这样才能在后期很方便地适配</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178774.html\">这里</a></p>"},{"title":"面向对象设计模式之Builder生成器模式（创建型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n在软件系统中，有时候面临着“一个复杂对象”的创建工作， 其通常由各个部分的子对象用一定的算法构成；由于需求的变化， 这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起 的算法却相对稳定；如何应对这种变化？如何提供一种“封装机制”来隔离复杂对象的各个部分的变化，从而保持系统中的“稳定构建算法不随需求的 改变而改变\n\n<!--more-->\n\n### 意图\n\n将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。——《设计模式》GOF\n\n### 适用性\n\n当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。当构造过程必须允许被构造的对象有不同的表示时。\n\n\n### UML图解\n\n![Builder模式UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/70604525.jpg)\n\n\n### 示例\n\n假设我们有一个游戏场景，在进入游戏场景时，我们需要构建一个游戏的房屋，房屋由两扇门，四面墙，四个窗户，两个地板，一个天花板构成，我们目的在于如何在游戏进入时去构造这些对象从而构建一个完整的房屋\n\n首先将房屋进行抽象，定一个广泛意义的房屋和和构成房屋的基础设施(门，墙，窗户，地板，天花板)\n\n`house.cs文件代码`\n```C#\npublic abstract class House\n{\n\n}\n//房屋\npublic abstract class Door\n{\n\n}\n//窗户\npublic abstract class Windows\n{\n\n}\n//地板\npublic abstract class Floor\n{\n\n}\n//墙\npublic abstract class Wall\n{\n\n}\n//天花板\npublic abstract class HouseCeiling\n{\n\n}\n```\n`RomainHouse.cs文件代码`\n```C#\n//罗马屋\npublic class RomainHouse:House\n{\n\n}\npublic class RomainDoor : Door\n{\n\n}\npublic class RomainWindows : Windows\n{\n\n}\npublic class RomainWall : Wall\n{\n\n}\n\npublic class RomainFloor : Floor\n{\n\n}\npublic class RomainHouseCeiling: HouseCeiling\n{\n\n}\n```\n`Builder.cs文件代码`\n```C#\n/// <summary>\n/// 游戏中的房屋生成器（抽象层次）\n/// </summary>\npublic abstract class Builder\n{\n    public abstract void BuildDoor();\n    public abstract void BuildWall();\n    public abstract void BuildWindows();\n    public abstract void BuildFloor();\n    public abstract void BuildHouseCeiling();\n\n    public abstract House GetHouse();\n}\n\n/// <summary>\n/// 具体罗马房屋生成器\n/// </summary>\npublic class RomainHouseBuilder : Builder\n{\n    private House house=new RomainHouse();\n\n    public override void BuildDoor()\n    {\n       //TODO:door...\n    }\n    public override void BuildWall()\n    {\n        //TODO:wall...\n    }\n    public override void BuildWindows()\n    {\n        //TODO:windows...\n    }\n    public override void BuildFloor()\n    {\n        //TODO:floor...\n    }\n    public override void BuildHouseCeiling()\n    {\n        //TODO:build a HouseCeiling...\n    }\n    public override House GetHouse()\n    {\n        return  house;\n    }\n}\n```\n\n定一个GameManager，用构造一个房屋\n\n```C#\n/// <summary>\n///GameManager,包含房屋的构建及过程实现，这里的构建过程算法是不经常变化的，是稳定的\n/// </summary>\npublic class GameManager\n{\n    //构建过程(即算法是不经常变化的)是稳定的...\n    public static House CreateHouse(Builder builder)\n    {\n        //两扇门\n        builder.BuildDoor();\n        builder.BuildDoor();\n        //四个窗户\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        //四面墙\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        //两块地板\n        builder.BuildFloor();\n        builder.BuildFloor();\n        //一个天花板\n        builder.BuildHouseCeiling();\n\n        return builder.GetHouse();\n    }\n}\n\n```\n\n最后做的事情就是在具体客户端去使用和调用\n```C#\n/// <summary>\n///客户端，直接使用GameManager来获取一个房屋\n/// </summary>\npublic class App\n{\n    public  static void Main()\n    {\n       //从配置文件中动态加载具体房屋生成器dll，保证了客户代码的稳定性；即当你的应用程序\n       //版本升级时，你只需要将改变的dll给用户，另者再修改一下配置文件即可扩展此程序\n        string assemblyName=ConfigurationManager.AppSettings[\"BuilderAssembly\"];\n        string builderName=ConfigurationManager.AppSettings[\"BuilderName\"];\n        Assembly builderAssembly = Assembly.Load(assemblyName);\n        Type builderType = builderAssembly.GetType(builderName);\n        Builder builder =(Builder)Activator.CreateInstance(builderType);\n\n        House house = GameManager.CreateHouse(builder);\n\n        //House house=GameManager.CreateHouse(new RomainHouseBuilder());\n    }\n}\n```\n在上述客户端调用的代码中，我们使用了反射来解决耦合，即便当房屋的风格变化时,只需要继承Builder实现其对应的具体风格房屋的生成器即可而客户代码可以通过配置文件的形式，通过.NET的反射机制调用改变后的具体生成器\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178776.html)\n","source":"_posts/Builder.md","raw":"---\ntitle: 面向对象设计模式之Builder生成器模式（创建型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Builder','生成器模式']\n---\n\n### 动机\n\n在软件系统中，有时候面临着“一个复杂对象”的创建工作， 其通常由各个部分的子对象用一定的算法构成；由于需求的变化， 这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起 的算法却相对稳定；如何应对这种变化？如何提供一种“封装机制”来隔离复杂对象的各个部分的变化，从而保持系统中的“稳定构建算法不随需求的 改变而改变\n\n<!--more-->\n\n### 意图\n\n将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。——《设计模式》GOF\n\n### 适用性\n\n当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。当构造过程必须允许被构造的对象有不同的表示时。\n\n\n### UML图解\n\n![Builder模式UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/70604525.jpg)\n\n\n### 示例\n\n假设我们有一个游戏场景，在进入游戏场景时，我们需要构建一个游戏的房屋，房屋由两扇门，四面墙，四个窗户，两个地板，一个天花板构成，我们目的在于如何在游戏进入时去构造这些对象从而构建一个完整的房屋\n\n首先将房屋进行抽象，定一个广泛意义的房屋和和构成房屋的基础设施(门，墙，窗户，地板，天花板)\n\n`house.cs文件代码`\n```C#\npublic abstract class House\n{\n\n}\n//房屋\npublic abstract class Door\n{\n\n}\n//窗户\npublic abstract class Windows\n{\n\n}\n//地板\npublic abstract class Floor\n{\n\n}\n//墙\npublic abstract class Wall\n{\n\n}\n//天花板\npublic abstract class HouseCeiling\n{\n\n}\n```\n`RomainHouse.cs文件代码`\n```C#\n//罗马屋\npublic class RomainHouse:House\n{\n\n}\npublic class RomainDoor : Door\n{\n\n}\npublic class RomainWindows : Windows\n{\n\n}\npublic class RomainWall : Wall\n{\n\n}\n\npublic class RomainFloor : Floor\n{\n\n}\npublic class RomainHouseCeiling: HouseCeiling\n{\n\n}\n```\n`Builder.cs文件代码`\n```C#\n/// <summary>\n/// 游戏中的房屋生成器（抽象层次）\n/// </summary>\npublic abstract class Builder\n{\n    public abstract void BuildDoor();\n    public abstract void BuildWall();\n    public abstract void BuildWindows();\n    public abstract void BuildFloor();\n    public abstract void BuildHouseCeiling();\n\n    public abstract House GetHouse();\n}\n\n/// <summary>\n/// 具体罗马房屋生成器\n/// </summary>\npublic class RomainHouseBuilder : Builder\n{\n    private House house=new RomainHouse();\n\n    public override void BuildDoor()\n    {\n       //TODO:door...\n    }\n    public override void BuildWall()\n    {\n        //TODO:wall...\n    }\n    public override void BuildWindows()\n    {\n        //TODO:windows...\n    }\n    public override void BuildFloor()\n    {\n        //TODO:floor...\n    }\n    public override void BuildHouseCeiling()\n    {\n        //TODO:build a HouseCeiling...\n    }\n    public override House GetHouse()\n    {\n        return  house;\n    }\n}\n```\n\n定一个GameManager，用构造一个房屋\n\n```C#\n/// <summary>\n///GameManager,包含房屋的构建及过程实现，这里的构建过程算法是不经常变化的，是稳定的\n/// </summary>\npublic class GameManager\n{\n    //构建过程(即算法是不经常变化的)是稳定的...\n    public static House CreateHouse(Builder builder)\n    {\n        //两扇门\n        builder.BuildDoor();\n        builder.BuildDoor();\n        //四个窗户\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        //四面墙\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        //两块地板\n        builder.BuildFloor();\n        builder.BuildFloor();\n        //一个天花板\n        builder.BuildHouseCeiling();\n\n        return builder.GetHouse();\n    }\n}\n\n```\n\n最后做的事情就是在具体客户端去使用和调用\n```C#\n/// <summary>\n///客户端，直接使用GameManager来获取一个房屋\n/// </summary>\npublic class App\n{\n    public  static void Main()\n    {\n       //从配置文件中动态加载具体房屋生成器dll，保证了客户代码的稳定性；即当你的应用程序\n       //版本升级时，你只需要将改变的dll给用户，另者再修改一下配置文件即可扩展此程序\n        string assemblyName=ConfigurationManager.AppSettings[\"BuilderAssembly\"];\n        string builderName=ConfigurationManager.AppSettings[\"BuilderName\"];\n        Assembly builderAssembly = Assembly.Load(assemblyName);\n        Type builderType = builderAssembly.GetType(builderName);\n        Builder builder =(Builder)Activator.CreateInstance(builderType);\n\n        House house = GameManager.CreateHouse(builder);\n\n        //House house=GameManager.CreateHouse(new RomainHouseBuilder());\n    }\n}\n```\n在上述客户端调用的代码中，我们使用了反射来解决耦合，即便当房屋的风格变化时,只需要继承Builder实现其对应的具体风格房屋的生成器即可而客户代码可以通过配置文件的形式，通过.NET的反射机制调用改变后的具体生成器\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178776.html)\n","slug":"Builder","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsun0007qk5cjabb66ri","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，有时候面临着“一个复杂对象”的创建工作， 其通常由各个部分的子对象用一定的算法构成；由于需求的变化， 这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起 的算法却相对稳定；如何应对这种变化？如何提供一种“封装机制”来隔离复杂对象的各个部分的变化，从而保持系统中的“稳定构建算法不随需求的 改变而改变</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。——《设计模式》GOF</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。当构造过程必须允许被构造的对象有不同的表示时。</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/70604525.jpg\" alt=\"Builder模式UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>假设我们有一个游戏场景，在进入游戏场景时，我们需要构建一个游戏的房屋，房屋由两扇门，四面墙，四个窗户，两个地板，一个天花板构成，我们目的在于如何在游戏进入时去构造这些对象从而构建一个完整的房屋</p>\n<p>首先将房屋进行抽象，定一个广泛意义的房屋和和构成房屋的基础设施(门，墙，窗户，地板，天花板)</p>\n<p><code>house.cs文件代码</code></p>\n<pre><code class=\"C#\">public abstract class House\n{\n\n}\n//房屋\npublic abstract class Door\n{\n\n}\n//窗户\npublic abstract class Windows\n{\n\n}\n//地板\npublic abstract class Floor\n{\n\n}\n//墙\npublic abstract class Wall\n{\n\n}\n//天花板\npublic abstract class HouseCeiling\n{\n\n}\n</code></pre>\n<p><code>RomainHouse.cs文件代码</code></p>\n<pre><code class=\"C#\">//罗马屋\npublic class RomainHouse:House\n{\n\n}\npublic class RomainDoor : Door\n{\n\n}\npublic class RomainWindows : Windows\n{\n\n}\npublic class RomainWall : Wall\n{\n\n}\n\npublic class RomainFloor : Floor\n{\n\n}\npublic class RomainHouseCeiling: HouseCeiling\n{\n\n}\n</code></pre>\n<p><code>Builder.cs文件代码</code></p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 游戏中的房屋生成器（抽象层次）\n/// &lt;/summary&gt;\npublic abstract class Builder\n{\n    public abstract void BuildDoor();\n    public abstract void BuildWall();\n    public abstract void BuildWindows();\n    public abstract void BuildFloor();\n    public abstract void BuildHouseCeiling();\n\n    public abstract House GetHouse();\n}\n\n/// &lt;summary&gt;\n/// 具体罗马房屋生成器\n/// &lt;/summary&gt;\npublic class RomainHouseBuilder : Builder\n{\n    private House house=new RomainHouse();\n\n    public override void BuildDoor()\n    {\n       //TODO:door...\n    }\n    public override void BuildWall()\n    {\n        //TODO:wall...\n    }\n    public override void BuildWindows()\n    {\n        //TODO:windows...\n    }\n    public override void BuildFloor()\n    {\n        //TODO:floor...\n    }\n    public override void BuildHouseCeiling()\n    {\n        //TODO:build a HouseCeiling...\n    }\n    public override House GetHouse()\n    {\n        return  house;\n    }\n}\n</code></pre>\n<p>定一个GameManager，用构造一个房屋</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n///GameManager,包含房屋的构建及过程实现，这里的构建过程算法是不经常变化的，是稳定的\n/// &lt;/summary&gt;\npublic class GameManager\n{\n    //构建过程(即算法是不经常变化的)是稳定的...\n    public static House CreateHouse(Builder builder)\n    {\n        //两扇门\n        builder.BuildDoor();\n        builder.BuildDoor();\n        //四个窗户\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        //四面墙\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        //两块地板\n        builder.BuildFloor();\n        builder.BuildFloor();\n        //一个天花板\n        builder.BuildHouseCeiling();\n\n        return builder.GetHouse();\n    }\n}\n</code></pre>\n<p>最后做的事情就是在具体客户端去使用和调用</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n///客户端，直接使用GameManager来获取一个房屋\n/// &lt;/summary&gt;\npublic class App\n{\n    public  static void Main()\n    {\n       //从配置文件中动态加载具体房屋生成器dll，保证了客户代码的稳定性；即当你的应用程序\n       //版本升级时，你只需要将改变的dll给用户，另者再修改一下配置文件即可扩展此程序\n        string assemblyName=ConfigurationManager.AppSettings[&quot;BuilderAssembly&quot;];\n        string builderName=ConfigurationManager.AppSettings[&quot;BuilderName&quot;];\n        Assembly builderAssembly = Assembly.Load(assemblyName);\n        Type builderType = builderAssembly.GetType(builderName);\n        Builder builder =(Builder)Activator.CreateInstance(builderType);\n\n        House house = GameManager.CreateHouse(builder);\n\n        //House house=GameManager.CreateHouse(new RomainHouseBuilder());\n    }\n}\n</code></pre>\n<p>在上述客户端调用的代码中，我们使用了反射来解决耦合，即便当房屋的风格变化时,只需要继承Builder实现其对应的具体风格房屋的生成器即可而客户代码可以通过配置文件的形式，通过.NET的反射机制调用改变后的具体生成器</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178776.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，有时候面临着“一个复杂对象”的创建工作， 其通常由各个部分的子对象用一定的算法构成；由于需求的变化， 这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起 的算法却相对稳定；如何应对这种变化？如何提供一种“封装机制”来隔离复杂对象的各个部分的变化，从而保持系统中的“稳定构建算法不随需求的 改变而改变</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。——《设计模式》GOF</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。当构造过程必须允许被构造的对象有不同的表示时。</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/70604525.jpg\" alt=\"Builder模式UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>假设我们有一个游戏场景，在进入游戏场景时，我们需要构建一个游戏的房屋，房屋由两扇门，四面墙，四个窗户，两个地板，一个天花板构成，我们目的在于如何在游戏进入时去构造这些对象从而构建一个完整的房屋</p>\n<p>首先将房屋进行抽象，定一个广泛意义的房屋和和构成房屋的基础设施(门，墙，窗户，地板，天花板)</p>\n<p><code>house.cs文件代码</code></p>\n<pre><code class=\"C#\">public abstract class House\n{\n\n}\n//房屋\npublic abstract class Door\n{\n\n}\n//窗户\npublic abstract class Windows\n{\n\n}\n//地板\npublic abstract class Floor\n{\n\n}\n//墙\npublic abstract class Wall\n{\n\n}\n//天花板\npublic abstract class HouseCeiling\n{\n\n}\n</code></pre>\n<p><code>RomainHouse.cs文件代码</code></p>\n<pre><code class=\"C#\">//罗马屋\npublic class RomainHouse:House\n{\n\n}\npublic class RomainDoor : Door\n{\n\n}\npublic class RomainWindows : Windows\n{\n\n}\npublic class RomainWall : Wall\n{\n\n}\n\npublic class RomainFloor : Floor\n{\n\n}\npublic class RomainHouseCeiling: HouseCeiling\n{\n\n}\n</code></pre>\n<p><code>Builder.cs文件代码</code></p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 游戏中的房屋生成器（抽象层次）\n/// &lt;/summary&gt;\npublic abstract class Builder\n{\n    public abstract void BuildDoor();\n    public abstract void BuildWall();\n    public abstract void BuildWindows();\n    public abstract void BuildFloor();\n    public abstract void BuildHouseCeiling();\n\n    public abstract House GetHouse();\n}\n\n/// &lt;summary&gt;\n/// 具体罗马房屋生成器\n/// &lt;/summary&gt;\npublic class RomainHouseBuilder : Builder\n{\n    private House house=new RomainHouse();\n\n    public override void BuildDoor()\n    {\n       //TODO:door...\n    }\n    public override void BuildWall()\n    {\n        //TODO:wall...\n    }\n    public override void BuildWindows()\n    {\n        //TODO:windows...\n    }\n    public override void BuildFloor()\n    {\n        //TODO:floor...\n    }\n    public override void BuildHouseCeiling()\n    {\n        //TODO:build a HouseCeiling...\n    }\n    public override House GetHouse()\n    {\n        return  house;\n    }\n}\n</code></pre>\n<p>定一个GameManager，用构造一个房屋</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n///GameManager,包含房屋的构建及过程实现，这里的构建过程算法是不经常变化的，是稳定的\n/// &lt;/summary&gt;\npublic class GameManager\n{\n    //构建过程(即算法是不经常变化的)是稳定的...\n    public static House CreateHouse(Builder builder)\n    {\n        //两扇门\n        builder.BuildDoor();\n        builder.BuildDoor();\n        //四个窗户\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        builder.BuildWindows();\n        //四面墙\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        builder.BuildWall();\n        //两块地板\n        builder.BuildFloor();\n        builder.BuildFloor();\n        //一个天花板\n        builder.BuildHouseCeiling();\n\n        return builder.GetHouse();\n    }\n}\n</code></pre>\n<p>最后做的事情就是在具体客户端去使用和调用</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n///客户端，直接使用GameManager来获取一个房屋\n/// &lt;/summary&gt;\npublic class App\n{\n    public  static void Main()\n    {\n       //从配置文件中动态加载具体房屋生成器dll，保证了客户代码的稳定性；即当你的应用程序\n       //版本升级时，你只需要将改变的dll给用户，另者再修改一下配置文件即可扩展此程序\n        string assemblyName=ConfigurationManager.AppSettings[&quot;BuilderAssembly&quot;];\n        string builderName=ConfigurationManager.AppSettings[&quot;BuilderName&quot;];\n        Assembly builderAssembly = Assembly.Load(assemblyName);\n        Type builderType = builderAssembly.GetType(builderName);\n        Builder builder =(Builder)Activator.CreateInstance(builderType);\n\n        House house = GameManager.CreateHouse(builder);\n\n        //House house=GameManager.CreateHouse(new RomainHouseBuilder());\n    }\n}\n</code></pre>\n<p>在上述客户端调用的代码中，我们使用了反射来解决耦合，即便当房屋的风格变化时,只需要继承Builder实现其对应的具体风格房屋的生成器即可而客户代码可以通过配置文件的形式，通过.NET的反射机制调用改变后的具体生成器</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178776.html\">这里</a></p>"},{"title":"面向对象设计模式之Composite组合模式（结构型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n在面向对象系统中，我们常常会遇到一类具有“容器”特征的对象——即他们在充当对象的同时,又是其他对象的容器。\n\n例如：\n\n``` C#\npublic class SingleBox:IBox      \n{                                \n    public void Process(){....}       \n}                                                \n                                  \npublic class ContainerBox:IBox\n{\n    public void Process(){....}\n    public ArrayList GetBoxes(){....}                            \n}\n```\n<!--more-->\n\n我们如何对这样的对象容器进行处理:\n\n``` C#\nIBox box=Factory.GetBox();\nif(box is ContainerBOx)\n{\nbox.Process();\nArrayList list=((ContainerBox)box).GetBoxes();//将面临比较复杂的递归处理\n}\nelse if(box is SingleBox)\n{\nbox.Process();\n}\n```\n这样的处理过程显然将其类结构过多的暴露给客户，而且让客户的代码依赖于对象容器复杂的内部实现结构。\n\n对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。\n\n如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器\n\n### 意图\n\n将对象组合成树形结构以表示“部分”与“整体”的层次结构。组合模式是使得用户对单个对象和组合对象的使用一致性\n\n\n### 适用性\n\n1. 你想表示对象的部分-整体层次结构。\n2. 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n\n\n### UML图解\n\n![Decorator UML图](http://oaefo3hoy.bkt.clouddn.com/16-8-2/19235324.jpg)\n\n### 示例\n\n按照上面的UML图，我们可以按照组合模式实现下\n\n#### 示例代码\n\n```C#\nnamespace Composite\n{\n    /// <summary>\n    /// 树容器对象接口\n    /// </summary>\n    public abstract class  IBox\n    {\n      \n        public abstract void Process();\n        public abstract void Add(IBox box);\n        public abstract void Remove(IBox box);\n        public abstract IBox GetChild(int index);\n    }\n\n    /// <summary>\n    /// 单个容器（里面没有子容器）\n    /// </summary>\n    public class SingleBox : IBox\n    {\n\n        public override void Process()\n        {\n            //do something processing...\n        }\n\n        public override void Add(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override void Remove(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override IBox GetChild(int index)\n        {\n            return this;\n        }\n    }\n\n    /// <summary>\n    /// 容器（有子容器）\n    /// </summary>\n    public class ContainerBox : IBox\n    {\n        ArrayList boxList = null;\n\n        public override void Process()\n        {\n            //do process for myself。。\n            //......\n            //do process for the box in boxList\n            foreach (IBox item in boxList)\n            {\n                item.Process();\n            }\n        }\n\n        public override void Add(IBox box)\n        {\n            if (boxList == null)\n            {\n                boxList = new ArrayList();\n            }\n            boxList.Add(box);\n        }\n\n        public override void Remove(IBox box)\n        {\n            boxList.Remove(box);\n        }\n\n        public override IBox GetChild(int index)\n        {\n            if (boxList == null)\n            {\n                throw new  NullReferenceException();\n            }\n            else if (index < 0 || index > boxList.Count)\n            {\n                throw new ArgumentOutOfRangeException();\n            }\n            return (IBox)boxList[index];\n        }\n    }\n\n    public class App\n    {\n        public static void Main()\n        {\n            IBox box = new ContainerBox();\n            box.Add(new SingleBox());\n            box.Add(new ContainerBox());\n\n            box.Process();\n        }\n    }\n\n   }\n```\n\n通过此组合模式，我们发现一开始描述的问题就没有了，客户端程序只需调用Process()方法就足够处理每个子容器\n\n### Composite模式的几个要点 \n\n1. Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关系处理      的是单个对象，还是组合的对象容器。    \n\n2. 将“客户代码与复杂的对象容器结构”解耦是Composite模式的核心思想，解耦之后，客户代码将于纯粹的抽象接口——而非对象容器的复杂内部实现结构——发生依赖关系，从而更能“应对变化”   \n\n3. Composite模式中，是将Add和Remove等和对象容器相关的方法定义在了表示抽象对象的Component类中，还是将其定义在表示对象容器的Composite类中，是一个关乎透明性和安全性的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。ASP.NET控件的实现在这方面为我们提供了一个很好的示范。 \n\n4. Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历要求，可使用缓存技巧改善效率\n\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html)\n","source":"_posts/Composite.md","raw":"---\ntitle: 面向对象设计模式之Composite组合模式（结构型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Decorator','组合模式']\n---\n\n### 动机\n\n在面向对象系统中，我们常常会遇到一类具有“容器”特征的对象——即他们在充当对象的同时,又是其他对象的容器。\n\n例如：\n\n``` C#\npublic class SingleBox:IBox      \n{                                \n    public void Process(){....}       \n}                                                \n                                  \npublic class ContainerBox:IBox\n{\n    public void Process(){....}\n    public ArrayList GetBoxes(){....}                            \n}\n```\n<!--more-->\n\n我们如何对这样的对象容器进行处理:\n\n``` C#\nIBox box=Factory.GetBox();\nif(box is ContainerBOx)\n{\nbox.Process();\nArrayList list=((ContainerBox)box).GetBoxes();//将面临比较复杂的递归处理\n}\nelse if(box is SingleBox)\n{\nbox.Process();\n}\n```\n这样的处理过程显然将其类结构过多的暴露给客户，而且让客户的代码依赖于对象容器复杂的内部实现结构。\n\n对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。\n\n如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器\n\n### 意图\n\n将对象组合成树形结构以表示“部分”与“整体”的层次结构。组合模式是使得用户对单个对象和组合对象的使用一致性\n\n\n### 适用性\n\n1. 你想表示对象的部分-整体层次结构。\n2. 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n\n\n### UML图解\n\n![Decorator UML图](http://oaefo3hoy.bkt.clouddn.com/16-8-2/19235324.jpg)\n\n### 示例\n\n按照上面的UML图，我们可以按照组合模式实现下\n\n#### 示例代码\n\n```C#\nnamespace Composite\n{\n    /// <summary>\n    /// 树容器对象接口\n    /// </summary>\n    public abstract class  IBox\n    {\n      \n        public abstract void Process();\n        public abstract void Add(IBox box);\n        public abstract void Remove(IBox box);\n        public abstract IBox GetChild(int index);\n    }\n\n    /// <summary>\n    /// 单个容器（里面没有子容器）\n    /// </summary>\n    public class SingleBox : IBox\n    {\n\n        public override void Process()\n        {\n            //do something processing...\n        }\n\n        public override void Add(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override void Remove(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override IBox GetChild(int index)\n        {\n            return this;\n        }\n    }\n\n    /// <summary>\n    /// 容器（有子容器）\n    /// </summary>\n    public class ContainerBox : IBox\n    {\n        ArrayList boxList = null;\n\n        public override void Process()\n        {\n            //do process for myself。。\n            //......\n            //do process for the box in boxList\n            foreach (IBox item in boxList)\n            {\n                item.Process();\n            }\n        }\n\n        public override void Add(IBox box)\n        {\n            if (boxList == null)\n            {\n                boxList = new ArrayList();\n            }\n            boxList.Add(box);\n        }\n\n        public override void Remove(IBox box)\n        {\n            boxList.Remove(box);\n        }\n\n        public override IBox GetChild(int index)\n        {\n            if (boxList == null)\n            {\n                throw new  NullReferenceException();\n            }\n            else if (index < 0 || index > boxList.Count)\n            {\n                throw new ArgumentOutOfRangeException();\n            }\n            return (IBox)boxList[index];\n        }\n    }\n\n    public class App\n    {\n        public static void Main()\n        {\n            IBox box = new ContainerBox();\n            box.Add(new SingleBox());\n            box.Add(new ContainerBox());\n\n            box.Process();\n        }\n    }\n\n   }\n```\n\n通过此组合模式，我们发现一开始描述的问题就没有了，客户端程序只需调用Process()方法就足够处理每个子容器\n\n### Composite模式的几个要点 \n\n1. Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关系处理      的是单个对象，还是组合的对象容器。    \n\n2. 将“客户代码与复杂的对象容器结构”解耦是Composite模式的核心思想，解耦之后，客户代码将于纯粹的抽象接口——而非对象容器的复杂内部实现结构——发生依赖关系，从而更能“应对变化”   \n\n3. Composite模式中，是将Add和Remove等和对象容器相关的方法定义在了表示抽象对象的Component类中，还是将其定义在表示对象容器的Composite类中，是一个关乎透明性和安全性的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。ASP.NET控件的实现在这方面为我们提供了一个很好的示范。 \n\n4. Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历要求，可使用缓存技巧改善效率\n\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html)\n","slug":"Composite","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsuq0008qk5cz7gp8wni","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在面向对象系统中，我们常常会遇到一类具有“容器”特征的对象——即他们在充当对象的同时,又是其他对象的容器。</p>\n<p>例如：</p>\n<pre><code class=\"C#\">public class SingleBox:IBox      \n{                                \n    public void Process(){....}       \n}                                                \n\npublic class ContainerBox:IBox\n{\n    public void Process(){....}\n    public ArrayList GetBoxes(){....}                            \n}\n</code></pre>\n<a id=\"more\"></a>\n<p>我们如何对这样的对象容器进行处理:</p>\n<pre><code class=\"C#\">IBox box=Factory.GetBox();\nif(box is ContainerBOx)\n{\nbox.Process();\nArrayList list=((ContainerBox)box).GetBoxes();//将面临比较复杂的递归处理\n}\nelse if(box is SingleBox)\n{\nbox.Process();\n}\n</code></pre>\n<p>这样的处理过程显然将其类结构过多的暴露给客户，而且让客户的代码依赖于对象容器复杂的内部实现结构。</p>\n<p>对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</p>\n<p>如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器</p>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>将对象组合成树形结构以表示“部分”与“整体”的层次结构。组合模式是使得用户对单个对象和组合对象的使用一致性</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li>你想表示对象的部分-整体层次结构。</li>\n<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-2/19235324.jpg\" alt=\"Decorator UML图\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>按照上面的UML图，我们可以按照组合模式实现下</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><pre><code class=\"C#\">namespace Composite\n{\n    /// &lt;summary&gt;\n    /// 树容器对象接口\n    /// &lt;/summary&gt;\n    public abstract class  IBox\n    {\n\n        public abstract void Process();\n        public abstract void Add(IBox box);\n        public abstract void Remove(IBox box);\n        public abstract IBox GetChild(int index);\n    }\n\n    /// &lt;summary&gt;\n    /// 单个容器（里面没有子容器）\n    /// &lt;/summary&gt;\n    public class SingleBox : IBox\n    {\n\n        public override void Process()\n        {\n            //do something processing...\n        }\n\n        public override void Add(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override void Remove(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override IBox GetChild(int index)\n        {\n            return this;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 容器（有子容器）\n    /// &lt;/summary&gt;\n    public class ContainerBox : IBox\n    {\n        ArrayList boxList = null;\n\n        public override void Process()\n        {\n            //do process for myself。。\n            //......\n            //do process for the box in boxList\n            foreach (IBox item in boxList)\n            {\n                item.Process();\n            }\n        }\n\n        public override void Add(IBox box)\n        {\n            if (boxList == null)\n            {\n                boxList = new ArrayList();\n            }\n            boxList.Add(box);\n        }\n\n        public override void Remove(IBox box)\n        {\n            boxList.Remove(box);\n        }\n\n        public override IBox GetChild(int index)\n        {\n            if (boxList == null)\n            {\n                throw new  NullReferenceException();\n            }\n            else if (index &lt; 0 || index &gt; boxList.Count)\n            {\n                throw new ArgumentOutOfRangeException();\n            }\n            return (IBox)boxList[index];\n        }\n    }\n\n    public class App\n    {\n        public static void Main()\n        {\n            IBox box = new ContainerBox();\n            box.Add(new SingleBox());\n            box.Add(new ContainerBox());\n\n            box.Process();\n        }\n    }\n\n   }\n</code></pre>\n<p>通过此组合模式，我们发现一开始描述的问题就没有了，客户端程序只需调用Process()方法就足够处理每个子容器</p>\n<h3 id=\"Composite模式的几个要点\"><a href=\"#Composite模式的几个要点\" class=\"headerlink\" title=\"Composite模式的几个要点\"></a>Composite模式的几个要点</h3><ol>\n<li><p>Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关系处理      的是单个对象，还是组合的对象容器。    </p>\n</li>\n<li><p>将“客户代码与复杂的对象容器结构”解耦是Composite模式的核心思想，解耦之后，客户代码将于纯粹的抽象接口——而非对象容器的复杂内部实现结构——发生依赖关系，从而更能“应对变化”   </p>\n</li>\n<li><p>Composite模式中，是将Add和Remove等和对象容器相关的方法定义在了表示抽象对象的Component类中，还是将其定义在表示对象容器的Composite类中，是一个关乎透明性和安全性的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。ASP.NET控件的实现在这方面为我们提供了一个很好的示范。 </p>\n</li>\n<li><p>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历要求，可使用缓存技巧改善效率</p>\n</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在面向对象系统中，我们常常会遇到一类具有“容器”特征的对象——即他们在充当对象的同时,又是其他对象的容器。</p>\n<p>例如：</p>\n<pre><code class=\"C#\">public class SingleBox:IBox      \n{                                \n    public void Process(){....}       \n}                                                \n\npublic class ContainerBox:IBox\n{\n    public void Process(){....}\n    public ArrayList GetBoxes(){....}                            \n}\n</code></pre>","more":"<p>我们如何对这样的对象容器进行处理:</p>\n<pre><code class=\"C#\">IBox box=Factory.GetBox();\nif(box is ContainerBOx)\n{\nbox.Process();\nArrayList list=((ContainerBox)box).GetBoxes();//将面临比较复杂的递归处理\n}\nelse if(box is SingleBox)\n{\nbox.Process();\n}\n</code></pre>\n<p>这样的处理过程显然将其类结构过多的暴露给客户，而且让客户的代码依赖于对象容器复杂的内部实现结构。</p>\n<p>对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</p>\n<p>如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器</p>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>将对象组合成树形结构以表示“部分”与“整体”的层次结构。组合模式是使得用户对单个对象和组合对象的使用一致性</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li>你想表示对象的部分-整体层次结构。</li>\n<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-2/19235324.jpg\" alt=\"Decorator UML图\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>按照上面的UML图，我们可以按照组合模式实现下</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><pre><code class=\"C#\">namespace Composite\n{\n    /// &lt;summary&gt;\n    /// 树容器对象接口\n    /// &lt;/summary&gt;\n    public abstract class  IBox\n    {\n\n        public abstract void Process();\n        public abstract void Add(IBox box);\n        public abstract void Remove(IBox box);\n        public abstract IBox GetChild(int index);\n    }\n\n    /// &lt;summary&gt;\n    /// 单个容器（里面没有子容器）\n    /// &lt;/summary&gt;\n    public class SingleBox : IBox\n    {\n\n        public override void Process()\n        {\n            //do something processing...\n        }\n\n        public override void Add(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override void Remove(IBox box)\n        {\n            throw new NotSupportedException();\n        }\n\n        public override IBox GetChild(int index)\n        {\n            return this;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 容器（有子容器）\n    /// &lt;/summary&gt;\n    public class ContainerBox : IBox\n    {\n        ArrayList boxList = null;\n\n        public override void Process()\n        {\n            //do process for myself。。\n            //......\n            //do process for the box in boxList\n            foreach (IBox item in boxList)\n            {\n                item.Process();\n            }\n        }\n\n        public override void Add(IBox box)\n        {\n            if (boxList == null)\n            {\n                boxList = new ArrayList();\n            }\n            boxList.Add(box);\n        }\n\n        public override void Remove(IBox box)\n        {\n            boxList.Remove(box);\n        }\n\n        public override IBox GetChild(int index)\n        {\n            if (boxList == null)\n            {\n                throw new  NullReferenceException();\n            }\n            else if (index &lt; 0 || index &gt; boxList.Count)\n            {\n                throw new ArgumentOutOfRangeException();\n            }\n            return (IBox)boxList[index];\n        }\n    }\n\n    public class App\n    {\n        public static void Main()\n        {\n            IBox box = new ContainerBox();\n            box.Add(new SingleBox());\n            box.Add(new ContainerBox());\n\n            box.Process();\n        }\n    }\n\n   }\n</code></pre>\n<p>通过此组合模式，我们发现一开始描述的问题就没有了，客户端程序只需调用Process()方法就足够处理每个子容器</p>\n<h3 id=\"Composite模式的几个要点\"><a href=\"#Composite模式的几个要点\" class=\"headerlink\" title=\"Composite模式的几个要点\"></a>Composite模式的几个要点</h3><ol>\n<li><p>Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关系处理      的是单个对象，还是组合的对象容器。    </p>\n</li>\n<li><p>将“客户代码与复杂的对象容器结构”解耦是Composite模式的核心思想，解耦之后，客户代码将于纯粹的抽象接口——而非对象容器的复杂内部实现结构——发生依赖关系，从而更能“应对变化”   </p>\n</li>\n<li><p>Composite模式中，是将Add和Remove等和对象容器相关的方法定义在了表示抽象对象的Component类中，还是将其定义在表示对象容器的Composite类中，是一个关乎透明性和安全性的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。ASP.NET控件的实现在这方面为我们提供了一个很好的示范。 </p>\n</li>\n<li><p>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历要求，可使用缓存技巧改善效率</p>\n</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html\">这里</a></p>"},{"title":"面向对象设计模式之Decorator装饰模式（结构型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n对象应对某种功能的增加或细微的变化，就要做对其本身或者子类做很大的变化，致使子类急剧 膨胀；如何使对象功能的扩展根据需要在运行时动态的实现？如何避免扩展功能的增多带来子类的膨胀问题，从而使任何功能的变化导致的影响降为最低\n\n<!--more-->\n\n### 意图\n\n运行时动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活解决主体类在多个方向的扩展\n\n### 适用性\n\n1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n\n2. 处理那些可以撤消的职责。\n\n3. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类\n\n### UML图解\n\n![Decorator UML图](http://oaefo3hoy.bkt.clouddn.com/Decorator.gif)\n\n\n### 示例\n\n#### 示例场景\n\n假设一个坦克游戏，而坦克在游戏开发的过程中，会随着对坦克功能的变化，而要随时进行扩展，比如随时增加功能：射击、潜水、消音、红外线...\n\n#### 示例代码\n\n##### 定义一个抽象坦克\n```C#\n    /// <summary>\n    /// 坦克（抽象层次）\n    /// </summary>\n    public abstract class Tank\n    {\n        public abstract void Shot();\n        public abstract void Run();\n    }\n\n```\n\n##### 实现坦克几个子类\n\n```C#\n   public class T50 : Tank\n    {\n        /// <summary>\n        /// 实际射击的方法\n        /// </summary>\n        public override void Shot()\n        {\n            \n        }\n\n        /// <summary>\n        /// 实际行走的方法\n        /// </summary>\n        public override void Run()\n        {\n             \n        }\n    }\n \n    public class T79 : Tank\n    {\n \n        public override void Shot()\n        {\n \n        }\n        public override void Run()\n        {\n \n        }\n    }\n \n    public class T80 : Tank\n    {\n \n        public override void Shot()\n        {\n \n        }\n \n        public override void Run()\n        {\n \n        }\n    }\n```\n\n\n#####  定义一个抽象装饰类\n\n按照UML图的理解，我们再定义装饰类，定义一个抽象装饰类,继承Tank\n\n```C#\n    /// <summary>\n    /// 从行为上是一种接口继承而不是类继承，不能把Decorator和Tank理解成is-a关系，从某种意义上应该为do-as或者\n    /// do-like的关系\n    /// </summary>\n    public abstract class Decorator : Tank\n    {\n        private Tank _tank;//has-a对象组合\n        public Decorator(Tank tank)\n        {\n            this._tank = tank;\n        }\n \n        public override void Shot()\n        {\n            _tank.Shot();\n        }\n \n        public override void Run()\n        {\n            _tank.Run();\n        }\n    }\n\n```\n\n##### 实现几个具有实际饰行为的类\n\n实现几个具有具体装饰行为的类，继承自抽象的装饰类\n\n```C#\n public class DecoratorA : Decorator\n    {  \n        public DecoratorA(Tank tank)\n            : base(tank)\n        {\n           \n        }\n         \n        /// <summary>\n        /// 在此只是装饰行走的功能，并不是实际坦克的行走；但通过base.Run()最终会执行T50、T79、T80对象的Run()方法\n        /// </summary>\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n \n        /// <summary>\n        /// 在此只是装饰射击的功能，并不是实际坦克的射击;但通过base.Run()最终要执行T50、T79、T80对象的Shot()方法\n        /// </summary>\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n             \n        }\n    }\n \n    public class DecoratorB : Decorator\n    {\n        public DecoratorB(Tank tank)\n            : base(tank)\n        {\n \n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n \n        }\n    }\n \n    public class DecoratorC : Decorator\n    {\n        public DecoratorC(Tank tank)\n            : base(tank)\n        {\n \n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n \n        }\n    }\n\n\n```\n\n##### 在客户端中应用\n\n然后我们可以直接在客户端程序调用，来实现游戏中给坦克加各种技能了\n\n```C#\n    //调用实现\n    public class App\n    {\n        public static void Main()\n        {\n            Tank T50 = new T50();\n            DecoratorA da= new DecoratorA(T50);//装饰一种红外功能\n            DecoratorB db = new DecoratorB(da);//装饰一种消音功能;此时具有了红外、消音两种扩展功能\n            DecoratorC dc = new DecoratorC(db);//装饰一种水陆两栖功能;此时具有了红外、消音和水陆两栖三种扩展功能了\n            dc.Run();\n            dc.Shot();            \n        }\n    }\n\n```\n\n### 装饰模式在.Net中应用\n\n```C#\n    //.NET装饰模式的应用\n    MemoryStream ms = new MemoryStream(new byte[] {87,90,78,60});//MemoryStream主体类\n    BufferedStream bs = new BufferedStream(ms);//装饰类;缓冲功能\n    CryptoStream cs = new CryptoStream(bs,new ToBase64Transform(),CryptoStreamMode.Write);//装饰类;缓冲、加密功能\n```\n\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html)\n","source":"_posts/Decorator.md","raw":"---\ntitle: 面向对象设计模式之Decorator装饰模式（结构型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Decorator','装饰模式']\n---\n\n### 动机\n\n对象应对某种功能的增加或细微的变化，就要做对其本身或者子类做很大的变化，致使子类急剧 膨胀；如何使对象功能的扩展根据需要在运行时动态的实现？如何避免扩展功能的增多带来子类的膨胀问题，从而使任何功能的变化导致的影响降为最低\n\n<!--more-->\n\n### 意图\n\n运行时动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活解决主体类在多个方向的扩展\n\n### 适用性\n\n1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n\n2. 处理那些可以撤消的职责。\n\n3. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类\n\n### UML图解\n\n![Decorator UML图](http://oaefo3hoy.bkt.clouddn.com/Decorator.gif)\n\n\n### 示例\n\n#### 示例场景\n\n假设一个坦克游戏，而坦克在游戏开发的过程中，会随着对坦克功能的变化，而要随时进行扩展，比如随时增加功能：射击、潜水、消音、红外线...\n\n#### 示例代码\n\n##### 定义一个抽象坦克\n```C#\n    /// <summary>\n    /// 坦克（抽象层次）\n    /// </summary>\n    public abstract class Tank\n    {\n        public abstract void Shot();\n        public abstract void Run();\n    }\n\n```\n\n##### 实现坦克几个子类\n\n```C#\n   public class T50 : Tank\n    {\n        /// <summary>\n        /// 实际射击的方法\n        /// </summary>\n        public override void Shot()\n        {\n            \n        }\n\n        /// <summary>\n        /// 实际行走的方法\n        /// </summary>\n        public override void Run()\n        {\n             \n        }\n    }\n \n    public class T79 : Tank\n    {\n \n        public override void Shot()\n        {\n \n        }\n        public override void Run()\n        {\n \n        }\n    }\n \n    public class T80 : Tank\n    {\n \n        public override void Shot()\n        {\n \n        }\n \n        public override void Run()\n        {\n \n        }\n    }\n```\n\n\n#####  定义一个抽象装饰类\n\n按照UML图的理解，我们再定义装饰类，定义一个抽象装饰类,继承Tank\n\n```C#\n    /// <summary>\n    /// 从行为上是一种接口继承而不是类继承，不能把Decorator和Tank理解成is-a关系，从某种意义上应该为do-as或者\n    /// do-like的关系\n    /// </summary>\n    public abstract class Decorator : Tank\n    {\n        private Tank _tank;//has-a对象组合\n        public Decorator(Tank tank)\n        {\n            this._tank = tank;\n        }\n \n        public override void Shot()\n        {\n            _tank.Shot();\n        }\n \n        public override void Run()\n        {\n            _tank.Run();\n        }\n    }\n\n```\n\n##### 实现几个具有实际饰行为的类\n\n实现几个具有具体装饰行为的类，继承自抽象的装饰类\n\n```C#\n public class DecoratorA : Decorator\n    {  \n        public DecoratorA(Tank tank)\n            : base(tank)\n        {\n           \n        }\n         \n        /// <summary>\n        /// 在此只是装饰行走的功能，并不是实际坦克的行走；但通过base.Run()最终会执行T50、T79、T80对象的Run()方法\n        /// </summary>\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n \n        /// <summary>\n        /// 在此只是装饰射击的功能，并不是实际坦克的射击;但通过base.Run()最终要执行T50、T79、T80对象的Shot()方法\n        /// </summary>\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n             \n        }\n    }\n \n    public class DecoratorB : Decorator\n    {\n        public DecoratorB(Tank tank)\n            : base(tank)\n        {\n \n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n \n        }\n    }\n \n    public class DecoratorC : Decorator\n    {\n        public DecoratorC(Tank tank)\n            : base(tank)\n        {\n \n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n \n        }\n    }\n\n\n```\n\n##### 在客户端中应用\n\n然后我们可以直接在客户端程序调用，来实现游戏中给坦克加各种技能了\n\n```C#\n    //调用实现\n    public class App\n    {\n        public static void Main()\n        {\n            Tank T50 = new T50();\n            DecoratorA da= new DecoratorA(T50);//装饰一种红外功能\n            DecoratorB db = new DecoratorB(da);//装饰一种消音功能;此时具有了红外、消音两种扩展功能\n            DecoratorC dc = new DecoratorC(db);//装饰一种水陆两栖功能;此时具有了红外、消音和水陆两栖三种扩展功能了\n            dc.Run();\n            dc.Shot();            \n        }\n    }\n\n```\n\n### 装饰模式在.Net中应用\n\n```C#\n    //.NET装饰模式的应用\n    MemoryStream ms = new MemoryStream(new byte[] {87,90,78,60});//MemoryStream主体类\n    BufferedStream bs = new BufferedStream(ms);//装饰类;缓冲功能\n    CryptoStream cs = new CryptoStream(bs,new ToBase64Transform(),CryptoStreamMode.Write);//装饰类;缓冲、加密功能\n```\n\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html)\n","slug":"Decorator","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsus000aqk5c5z4ljlrr","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>对象应对某种功能的增加或细微的变化，就要做对其本身或者子类做很大的变化，致使子类急剧 膨胀；如何使对象功能的扩展根据需要在运行时动态的实现？如何避免扩展功能的增多带来子类的膨胀问题，从而使任何功能的变化导致的影响降为最低</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>运行时动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活解决主体类在多个方向的扩展</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>\n</li>\n<li><p>处理那些可以撤消的职责。</p>\n</li>\n<li><p>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类</p>\n</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Decorator.gif\" alt=\"Decorator UML图\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>假设一个坦克游戏，而坦克在游戏开发的过程中，会随着对坦克功能的变化，而要随时进行扩展，比如随时增加功能：射击、潜水、消音、红外线…</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><h5 id=\"定义一个抽象坦克\"><a href=\"#定义一个抽象坦克\" class=\"headerlink\" title=\"定义一个抽象坦克\"></a>定义一个抽象坦克</h5><pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 坦克（抽象层次）\n    /// &lt;/summary&gt;\n    public abstract class Tank\n    {\n        public abstract void Shot();\n        public abstract void Run();\n    }\n</code></pre>\n<h5 id=\"实现坦克几个子类\"><a href=\"#实现坦克几个子类\" class=\"headerlink\" title=\"实现坦克几个子类\"></a>实现坦克几个子类</h5><pre><code class=\"C#\">   public class T50 : Tank\n    {\n        /// &lt;summary&gt;\n        /// 实际射击的方法\n        /// &lt;/summary&gt;\n        public override void Shot()\n        {\n\n        }\n\n        /// &lt;summary&gt;\n        /// 实际行走的方法\n        /// &lt;/summary&gt;\n        public override void Run()\n        {\n\n        }\n    }\n\n    public class T79 : Tank\n    {\n\n        public override void Shot()\n        {\n\n        }\n        public override void Run()\n        {\n\n        }\n    }\n\n    public class T80 : Tank\n    {\n\n        public override void Shot()\n        {\n\n        }\n\n        public override void Run()\n        {\n\n        }\n    }\n</code></pre>\n<h5 id=\"定义一个抽象装饰类\"><a href=\"#定义一个抽象装饰类\" class=\"headerlink\" title=\"定义一个抽象装饰类\"></a>定义一个抽象装饰类</h5><p>按照UML图的理解，我们再定义装饰类，定义一个抽象装饰类,继承Tank</p>\n<pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 从行为上是一种接口继承而不是类继承，不能把Decorator和Tank理解成is-a关系，从某种意义上应该为do-as或者\n    /// do-like的关系\n    /// &lt;/summary&gt;\n    public abstract class Decorator : Tank\n    {\n        private Tank _tank;//has-a对象组合\n        public Decorator(Tank tank)\n        {\n            this._tank = tank;\n        }\n\n        public override void Shot()\n        {\n            _tank.Shot();\n        }\n\n        public override void Run()\n        {\n            _tank.Run();\n        }\n    }\n</code></pre>\n<h5 id=\"实现几个具有实际饰行为的类\"><a href=\"#实现几个具有实际饰行为的类\" class=\"headerlink\" title=\"实现几个具有实际饰行为的类\"></a>实现几个具有实际饰行为的类</h5><p>实现几个具有具体装饰行为的类，继承自抽象的装饰类</p>\n<pre><code class=\"C#\"> public class DecoratorA : Decorator\n    {  \n        public DecoratorA(Tank tank)\n            : base(tank)\n        {\n\n        }\n\n        /// &lt;summary&gt;\n        /// 在此只是装饰行走的功能，并不是实际坦克的行走；但通过base.Run()最终会执行T50、T79、T80对象的Run()方法\n        /// &lt;/summary&gt;\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n\n        /// &lt;summary&gt;\n        /// 在此只是装饰射击的功能，并不是实际坦克的射击;但通过base.Run()最终要执行T50、T79、T80对象的Shot()方法\n        /// &lt;/summary&gt;\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n\n        }\n    }\n\n    public class DecoratorB : Decorator\n    {\n        public DecoratorB(Tank tank)\n            : base(tank)\n        {\n\n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n\n        }\n    }\n\n    public class DecoratorC : Decorator\n    {\n        public DecoratorC(Tank tank)\n            : base(tank)\n        {\n\n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n\n        }\n    }\n</code></pre>\n<h5 id=\"在客户端中应用\"><a href=\"#在客户端中应用\" class=\"headerlink\" title=\"在客户端中应用\"></a>在客户端中应用</h5><p>然后我们可以直接在客户端程序调用，来实现游戏中给坦克加各种技能了</p>\n<pre><code class=\"C#\">    //调用实现\n    public class App\n    {\n        public static void Main()\n        {\n            Tank T50 = new T50();\n            DecoratorA da= new DecoratorA(T50);//装饰一种红外功能\n            DecoratorB db = new DecoratorB(da);//装饰一种消音功能;此时具有了红外、消音两种扩展功能\n            DecoratorC dc = new DecoratorC(db);//装饰一种水陆两栖功能;此时具有了红外、消音和水陆两栖三种扩展功能了\n            dc.Run();\n            dc.Shot();            \n        }\n    }\n</code></pre>\n<h3 id=\"装饰模式在-Net中应用\"><a href=\"#装饰模式在-Net中应用\" class=\"headerlink\" title=\"装饰模式在.Net中应用\"></a>装饰模式在.Net中应用</h3><pre><code class=\"C#\">    //.NET装饰模式的应用\n    MemoryStream ms = new MemoryStream(new byte[] {87,90,78,60});//MemoryStream主体类\n    BufferedStream bs = new BufferedStream(ms);//装饰类;缓冲功能\n    CryptoStream cs = new CryptoStream(bs,new ToBase64Transform(),CryptoStreamMode.Write);//装饰类;缓冲、加密功能\n</code></pre>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>对象应对某种功能的增加或细微的变化，就要做对其本身或者子类做很大的变化，致使子类急剧 膨胀；如何使对象功能的扩展根据需要在运行时动态的实现？如何避免扩展功能的增多带来子类的膨胀问题，从而使任何功能的变化导致的影响降为最低</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>运行时动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活解决主体类在多个方向的扩展</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>\n</li>\n<li><p>处理那些可以撤消的职责。</p>\n</li>\n<li><p>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类</p>\n</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Decorator.gif\" alt=\"Decorator UML图\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>假设一个坦克游戏，而坦克在游戏开发的过程中，会随着对坦克功能的变化，而要随时进行扩展，比如随时增加功能：射击、潜水、消音、红外线…</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><h5 id=\"定义一个抽象坦克\"><a href=\"#定义一个抽象坦克\" class=\"headerlink\" title=\"定义一个抽象坦克\"></a>定义一个抽象坦克</h5><pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 坦克（抽象层次）\n    /// &lt;/summary&gt;\n    public abstract class Tank\n    {\n        public abstract void Shot();\n        public abstract void Run();\n    }\n</code></pre>\n<h5 id=\"实现坦克几个子类\"><a href=\"#实现坦克几个子类\" class=\"headerlink\" title=\"实现坦克几个子类\"></a>实现坦克几个子类</h5><pre><code class=\"C#\">   public class T50 : Tank\n    {\n        /// &lt;summary&gt;\n        /// 实际射击的方法\n        /// &lt;/summary&gt;\n        public override void Shot()\n        {\n\n        }\n\n        /// &lt;summary&gt;\n        /// 实际行走的方法\n        /// &lt;/summary&gt;\n        public override void Run()\n        {\n\n        }\n    }\n\n    public class T79 : Tank\n    {\n\n        public override void Shot()\n        {\n\n        }\n        public override void Run()\n        {\n\n        }\n    }\n\n    public class T80 : Tank\n    {\n\n        public override void Shot()\n        {\n\n        }\n\n        public override void Run()\n        {\n\n        }\n    }\n</code></pre>\n<h5 id=\"定义一个抽象装饰类\"><a href=\"#定义一个抽象装饰类\" class=\"headerlink\" title=\"定义一个抽象装饰类\"></a>定义一个抽象装饰类</h5><p>按照UML图的理解，我们再定义装饰类，定义一个抽象装饰类,继承Tank</p>\n<pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 从行为上是一种接口继承而不是类继承，不能把Decorator和Tank理解成is-a关系，从某种意义上应该为do-as或者\n    /// do-like的关系\n    /// &lt;/summary&gt;\n    public abstract class Decorator : Tank\n    {\n        private Tank _tank;//has-a对象组合\n        public Decorator(Tank tank)\n        {\n            this._tank = tank;\n        }\n\n        public override void Shot()\n        {\n            _tank.Shot();\n        }\n\n        public override void Run()\n        {\n            _tank.Run();\n        }\n    }\n</code></pre>\n<h5 id=\"实现几个具有实际饰行为的类\"><a href=\"#实现几个具有实际饰行为的类\" class=\"headerlink\" title=\"实现几个具有实际饰行为的类\"></a>实现几个具有实际饰行为的类</h5><p>实现几个具有具体装饰行为的类，继承自抽象的装饰类</p>\n<pre><code class=\"C#\"> public class DecoratorA : Decorator\n    {  \n        public DecoratorA(Tank tank)\n            : base(tank)\n        {\n\n        }\n\n        /// &lt;summary&gt;\n        /// 在此只是装饰行走的功能，并不是实际坦克的行走；但通过base.Run()最终会执行T50、T79、T80对象的Run()方法\n        /// &lt;/summary&gt;\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n\n        /// &lt;summary&gt;\n        /// 在此只是装饰射击的功能，并不是实际坦克的射击;但通过base.Run()最终要执行T50、T79、T80对象的Shot()方法\n        /// &lt;/summary&gt;\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n\n        }\n    }\n\n    public class DecoratorB : Decorator\n    {\n        public DecoratorB(Tank tank)\n            : base(tank)\n        {\n\n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n\n        }\n    }\n\n    public class DecoratorC : Decorator\n    {\n        public DecoratorC(Tank tank)\n            : base(tank)\n        {\n\n        }\n        public override void Run()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现潜水功能的扩展\n            base.Run();\n        }\n        public override void Shot()\n        {\n            //dosomething...相当于为其增加某种功能（即装饰）,比如在此可实现射击消音的扩展\n            base.Shot();\n\n        }\n    }\n</code></pre>\n<h5 id=\"在客户端中应用\"><a href=\"#在客户端中应用\" class=\"headerlink\" title=\"在客户端中应用\"></a>在客户端中应用</h5><p>然后我们可以直接在客户端程序调用，来实现游戏中给坦克加各种技能了</p>\n<pre><code class=\"C#\">    //调用实现\n    public class App\n    {\n        public static void Main()\n        {\n            Tank T50 = new T50();\n            DecoratorA da= new DecoratorA(T50);//装饰一种红外功能\n            DecoratorB db = new DecoratorB(da);//装饰一种消音功能;此时具有了红外、消音两种扩展功能\n            DecoratorC dc = new DecoratorC(db);//装饰一种水陆两栖功能;此时具有了红外、消音和水陆两栖三种扩展功能了\n            dc.Run();\n            dc.Shot();            \n        }\n    }\n</code></pre>\n<h3 id=\"装饰模式在-Net中应用\"><a href=\"#装饰模式在-Net中应用\" class=\"headerlink\" title=\"装饰模式在.Net中应用\"></a>装饰模式在.Net中应用</h3><pre><code class=\"C#\">    //.NET装饰模式的应用\n    MemoryStream ms = new MemoryStream(new byte[] {87,90,78,60});//MemoryStream主体类\n    BufferedStream bs = new BufferedStream(ms);//装饰类;缓冲功能\n    CryptoStream cs = new CryptoStream(bs,new ToBase64Transform(),CryptoStreamMode.Write);//装饰类;缓冲、加密功能\n</code></pre>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178771.html\">这里</a></p>"},{"title":"面向对象设计模式之Facade外观模式（结构型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n有些系统组件的客户和组件中各种复杂的子系统有了过多的的耦合，随着外部客户程序\n和个子系统的演化，这种过多的耦合面临很多变化的挑战；如何简化外部客户程序和系统的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦\n\n<!--more-->\n\n### 意图\n\n为子系统的一组接口提供一个一致的界面，Facade模式定义了了一个高层接口，这个接口使得这一子系统更加容易使用\n\n### 适用性\n\n1. 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 \n\n2. 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 \n\n3、当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。\n\n### UML图解\n\n![](http://oaefo3hoy.bkt.clouddn.com/Facade.jpg)\n\n\n### 示例\n\n#### 示例场景\n\n假设我们需要开发一个坦克模拟系统用于模拟坦克车在各种作战环境中的行为，其中坦克系统由引擎、控制器、车轮、车身等各种子系统构成。\n\n#### 示例代码\n\n\n#### 定义坦克几个部件\n\n假设将下面每个类看做是各个子系统的话，接着我们就用Facade模式设计一个高层的系统\n\n```C#\nnamespace Facade\n{\n     \n    /// <summary>\n    /// 车轮\n    /// </summary>\n    public class Wheel\n    {\n        public void WAction1()\n        {\n        }\n        public void WAction2()\n        {\n        }\n    }\n \n    /// <summary>\n    /// 引擎\n    /// </summary>\n    public class Engine\n    {\n        public void EAction1()\n        {\n        }\n        public void EAction2()\n        {\n        }\n    }\n \n    /// <summary>\n    /// 控制器\n    /// </summary>\n    public class Controler\n    {\n        public void CAction1()\n        {\n        }\n        public void CAction2()\n        {\n        }\n \n    }\n    \n    /// <summary>\n    /// 车身\n    /// </summary>\n    public class Bodywork\n    {\n        public void BAction1()\n        {\n        }\n        public void BAction2()\n        {\n        }\n    }\n}\n```\n\n#### 定义高级的系统外观\n\n利用组合的模式组装各个子系统\n\n```C#\npublic class TankFacade\n{\n   Wheel[] wheels=new Wheel[4];\n   Engine[] engines = new Engine[4];\n   Bodywork body = new Bodywork();\n   Controler control = new Controler();\n   public void Start()\n   {\n       //使用子系统Engine的某些方法...\n   }\n   public void Run()\n   {\n       //使用子系统Wheel的某些方法...\n   }\n   public void Shot()\n   {\n       //....\n   }\n   public void Stop()\n   {\n     //....\n   }\n}\n```\n\n#### 总结\n\n以上设计好TankFacade类，这样就可以将系统解耦，我们使用坦克时并不需要关注其引擎、控制器、车轮、车身具体怎么工作的我们只需要知道坦克能做什么就可以，TankFacade类简化了客户程序使用的复杂性也同时隐藏了子系的内部实现，以对象组合的方式来达到解耦的目的；虽然子系统和TankFacade同在一个DLL里，但客户程序只能透过TankFacade类来使用各个子系统的功能\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353755.html)\n","source":"_posts/Facade.md","raw":"---\ntitle: 面向对象设计模式之Facade外观模式（结构型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Facade','外观模式']\n---\n\n### 动机\n\n有些系统组件的客户和组件中各种复杂的子系统有了过多的的耦合，随着外部客户程序\n和个子系统的演化，这种过多的耦合面临很多变化的挑战；如何简化外部客户程序和系统的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦\n\n<!--more-->\n\n### 意图\n\n为子系统的一组接口提供一个一致的界面，Facade模式定义了了一个高层接口，这个接口使得这一子系统更加容易使用\n\n### 适用性\n\n1. 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 \n\n2. 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 \n\n3、当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。\n\n### UML图解\n\n![](http://oaefo3hoy.bkt.clouddn.com/Facade.jpg)\n\n\n### 示例\n\n#### 示例场景\n\n假设我们需要开发一个坦克模拟系统用于模拟坦克车在各种作战环境中的行为，其中坦克系统由引擎、控制器、车轮、车身等各种子系统构成。\n\n#### 示例代码\n\n\n#### 定义坦克几个部件\n\n假设将下面每个类看做是各个子系统的话，接着我们就用Facade模式设计一个高层的系统\n\n```C#\nnamespace Facade\n{\n     \n    /// <summary>\n    /// 车轮\n    /// </summary>\n    public class Wheel\n    {\n        public void WAction1()\n        {\n        }\n        public void WAction2()\n        {\n        }\n    }\n \n    /// <summary>\n    /// 引擎\n    /// </summary>\n    public class Engine\n    {\n        public void EAction1()\n        {\n        }\n        public void EAction2()\n        {\n        }\n    }\n \n    /// <summary>\n    /// 控制器\n    /// </summary>\n    public class Controler\n    {\n        public void CAction1()\n        {\n        }\n        public void CAction2()\n        {\n        }\n \n    }\n    \n    /// <summary>\n    /// 车身\n    /// </summary>\n    public class Bodywork\n    {\n        public void BAction1()\n        {\n        }\n        public void BAction2()\n        {\n        }\n    }\n}\n```\n\n#### 定义高级的系统外观\n\n利用组合的模式组装各个子系统\n\n```C#\npublic class TankFacade\n{\n   Wheel[] wheels=new Wheel[4];\n   Engine[] engines = new Engine[4];\n   Bodywork body = new Bodywork();\n   Controler control = new Controler();\n   public void Start()\n   {\n       //使用子系统Engine的某些方法...\n   }\n   public void Run()\n   {\n       //使用子系统Wheel的某些方法...\n   }\n   public void Shot()\n   {\n       //....\n   }\n   public void Stop()\n   {\n     //....\n   }\n}\n```\n\n#### 总结\n\n以上设计好TankFacade类，这样就可以将系统解耦，我们使用坦克时并不需要关注其引擎、控制器、车轮、车身具体怎么工作的我们只需要知道坦克能做什么就可以，TankFacade类简化了客户程序使用的复杂性也同时隐藏了子系的内部实现，以对象组合的方式来达到解耦的目的；虽然子系统和TankFacade同在一个DLL里，但客户程序只能透过TankFacade类来使用各个子系统的功能\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353755.html)\n","slug":"Facade","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsuy000cqk5ci23cde3m","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>有些系统组件的客户和组件中各种复杂的子系统有了过多的的耦合，随着外部客户程序<br>和个子系统的演化，这种过多的耦合面临很多变化的挑战；如何简化外部客户程序和系统的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>为子系统的一组接口提供一个一致的界面，Facade模式定义了了一个高层接口，这个接口使得这一子系统更加容易使用</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li><p>当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 </p>\n</li>\n<li><p>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 </p>\n</li>\n</ol>\n<p>3、当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Facade.jpg\" alt=\"\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>假设我们需要开发一个坦克模拟系统用于模拟坦克车在各种作战环境中的行为，其中坦克系统由引擎、控制器、车轮、车身等各种子系统构成。</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><h4 id=\"定义坦克几个部件\"><a href=\"#定义坦克几个部件\" class=\"headerlink\" title=\"定义坦克几个部件\"></a>定义坦克几个部件</h4><p>假设将下面每个类看做是各个子系统的话，接着我们就用Facade模式设计一个高层的系统</p>\n<pre><code class=\"C#\">namespace Facade\n{\n\n    /// &lt;summary&gt;\n    /// 车轮\n    /// &lt;/summary&gt;\n    public class Wheel\n    {\n        public void WAction1()\n        {\n        }\n        public void WAction2()\n        {\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 引擎\n    /// &lt;/summary&gt;\n    public class Engine\n    {\n        public void EAction1()\n        {\n        }\n        public void EAction2()\n        {\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 控制器\n    /// &lt;/summary&gt;\n    public class Controler\n    {\n        public void CAction1()\n        {\n        }\n        public void CAction2()\n        {\n        }\n\n    }\n\n    /// &lt;summary&gt;\n    /// 车身\n    /// &lt;/summary&gt;\n    public class Bodywork\n    {\n        public void BAction1()\n        {\n        }\n        public void BAction2()\n        {\n        }\n    }\n}\n</code></pre>\n<h4 id=\"定义高级的系统外观\"><a href=\"#定义高级的系统外观\" class=\"headerlink\" title=\"定义高级的系统外观\"></a>定义高级的系统外观</h4><p>利用组合的模式组装各个子系统</p>\n<pre><code class=\"C#\">public class TankFacade\n{\n   Wheel[] wheels=new Wheel[4];\n   Engine[] engines = new Engine[4];\n   Bodywork body = new Bodywork();\n   Controler control = new Controler();\n   public void Start()\n   {\n       //使用子系统Engine的某些方法...\n   }\n   public void Run()\n   {\n       //使用子系统Wheel的某些方法...\n   }\n   public void Shot()\n   {\n       //....\n   }\n   public void Stop()\n   {\n     //....\n   }\n}\n</code></pre>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>以上设计好TankFacade类，这样就可以将系统解耦，我们使用坦克时并不需要关注其引擎、控制器、车轮、车身具体怎么工作的我们只需要知道坦克能做什么就可以，TankFacade类简化了客户程序使用的复杂性也同时隐藏了子系的内部实现，以对象组合的方式来达到解耦的目的；虽然子系统和TankFacade同在一个DLL里，但客户程序只能透过TankFacade类来使用各个子系统的功能</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353755.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>有些系统组件的客户和组件中各种复杂的子系统有了过多的的耦合，随着外部客户程序<br>和个子系统的演化，这种过多的耦合面临很多变化的挑战；如何简化外部客户程序和系统的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>为子系统的一组接口提供一个一致的界面，Facade模式定义了了一个高层接口，这个接口使得这一子系统更加容易使用</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li><p>当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 </p>\n</li>\n<li><p>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 </p>\n</li>\n</ol>\n<p>3、当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Facade.jpg\" alt=\"\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>假设我们需要开发一个坦克模拟系统用于模拟坦克车在各种作战环境中的行为，其中坦克系统由引擎、控制器、车轮、车身等各种子系统构成。</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><h4 id=\"定义坦克几个部件\"><a href=\"#定义坦克几个部件\" class=\"headerlink\" title=\"定义坦克几个部件\"></a>定义坦克几个部件</h4><p>假设将下面每个类看做是各个子系统的话，接着我们就用Facade模式设计一个高层的系统</p>\n<pre><code class=\"C#\">namespace Facade\n{\n\n    /// &lt;summary&gt;\n    /// 车轮\n    /// &lt;/summary&gt;\n    public class Wheel\n    {\n        public void WAction1()\n        {\n        }\n        public void WAction2()\n        {\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 引擎\n    /// &lt;/summary&gt;\n    public class Engine\n    {\n        public void EAction1()\n        {\n        }\n        public void EAction2()\n        {\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 控制器\n    /// &lt;/summary&gt;\n    public class Controler\n    {\n        public void CAction1()\n        {\n        }\n        public void CAction2()\n        {\n        }\n\n    }\n\n    /// &lt;summary&gt;\n    /// 车身\n    /// &lt;/summary&gt;\n    public class Bodywork\n    {\n        public void BAction1()\n        {\n        }\n        public void BAction2()\n        {\n        }\n    }\n}\n</code></pre>\n<h4 id=\"定义高级的系统外观\"><a href=\"#定义高级的系统外观\" class=\"headerlink\" title=\"定义高级的系统外观\"></a>定义高级的系统外观</h4><p>利用组合的模式组装各个子系统</p>\n<pre><code class=\"C#\">public class TankFacade\n{\n   Wheel[] wheels=new Wheel[4];\n   Engine[] engines = new Engine[4];\n   Bodywork body = new Bodywork();\n   Controler control = new Controler();\n   public void Start()\n   {\n       //使用子系统Engine的某些方法...\n   }\n   public void Run()\n   {\n       //使用子系统Wheel的某些方法...\n   }\n   public void Shot()\n   {\n       //....\n   }\n   public void Stop()\n   {\n     //....\n   }\n}\n</code></pre>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>以上设计好TankFacade类，这样就可以将系统解耦，我们使用坦克时并不需要关注其引擎、控制器、车轮、车身具体怎么工作的我们只需要知道坦克能做什么就可以，TankFacade类简化了客户程序使用的复杂性也同时隐藏了子系的内部实现，以对象组合的方式来达到解耦的目的；虽然子系统和TankFacade同在一个DLL里，但客户程序只能透过TankFacade类来使用各个子系统的功能</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353755.html\">这里</a></p>"},{"title":"面向对象设计模式之FactoryMethod工厂方法模式（创建型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n当一个类不知道它所必须创建的对象的类的时候。当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个， 并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。\n\n<!--more-->\n\n### 意图\n\n定义一个用于创建对象的接口，让子类决定实例化 哪个子类。FactoryMethod使得一个类的实例化延迟到子类\n\n### UML图解\n\n![FactoryMethod UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/96915445.jpg)\n\n### 示例\n\n有一个汽车软件测试框架，该框架需要提供一套标准接口(包括启动，行驶，转向，鸣笛，刹车等规范接口)，来为不同汽车厂商提供统一的汽车测试标准规范接口,下面就用运行工厂方法模式实现此示例\n\n```C#\npublic enum Direction\n{\n  Right,Left\n}\npublic abstract class AbstractCar\n{\n    //启动\n    public abstract void Startup();\n    //行驶\n    public abstract void Run();\n    //转向\n    public abstract void Turn(Direction dire);\n    //鸣笛\n    public abstract void Deep();\n    //刹车\n    public abstract void Stop();\n\n}\n\n/// <summary>\n/// 汽车工厂（抽象层） 具体实现交由具体汽车厂商\n/// </summary>\npublic abstract class CarFactory\n{\n    public abstract AbstractCar CreateCar();\n\n}\npublic class CarTestFramework\n{\n    AbstractCar car;\n    public void BuildTestContext(CarFactory carfactory)\n    {\n        car = carfactory.CreateCar();\n    }\n\n    public void TestRun() { car.Run(); }\n    public void TestTurn(Direction d) { car.Turn(d); }\n    public void TestDeep() { car.Deep(); }\n    public void TestStop() { car.Stop(); }\n}\n```\n\n客户端调用\n```\nclass AppClient  \n{\n  public static void Main(string[] args)\n  {\n      //从配置文件中动态加载具体汽车生产工厂的dll，保证了客户代码的稳定性；即当你的应用程序\n      //版本升级时，你只需要将改变的dll给用户，或者再修改一下配置文件即可扩展此程序\n      string assemblyName = ConfigurationManager.AppSettings[\"CarFactoryAssembly\"];\n      string factoryName = ConfigurationManager.AppSettings[\"CarFactoryName\"];\n      Assembly factoryAssembly = Assembly.Load(assemblyName);\n      Type factoryType = factoryAssembly.GetType(factoryName);\n      CarTestFramework carTest = new CarTestFramework();\n      //carTest.BuildTestContext(new DaZhongFactory());\n      carTest.BuildTestContext((DaZhongFactory)Activator.CreateInstance(factoryType));\n      carTest.TestRun();\n      carTest.TestStop();\n      carTest.TestTurn(Direction.Right);\n  }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178778.html)\n","source":"_posts/FactoryMethod.md","raw":"---\ntitle: 面向对象设计模式之FactoryMethod工厂方法模式（创建型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['FactoryMethod','工厂方法模式']\n---\n\n### 动机\n\n当一个类不知道它所必须创建的对象的类的时候。当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个， 并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。\n\n<!--more-->\n\n### 意图\n\n定义一个用于创建对象的接口，让子类决定实例化 哪个子类。FactoryMethod使得一个类的实例化延迟到子类\n\n### UML图解\n\n![FactoryMethod UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/96915445.jpg)\n\n### 示例\n\n有一个汽车软件测试框架，该框架需要提供一套标准接口(包括启动，行驶，转向，鸣笛，刹车等规范接口)，来为不同汽车厂商提供统一的汽车测试标准规范接口,下面就用运行工厂方法模式实现此示例\n\n```C#\npublic enum Direction\n{\n  Right,Left\n}\npublic abstract class AbstractCar\n{\n    //启动\n    public abstract void Startup();\n    //行驶\n    public abstract void Run();\n    //转向\n    public abstract void Turn(Direction dire);\n    //鸣笛\n    public abstract void Deep();\n    //刹车\n    public abstract void Stop();\n\n}\n\n/// <summary>\n/// 汽车工厂（抽象层） 具体实现交由具体汽车厂商\n/// </summary>\npublic abstract class CarFactory\n{\n    public abstract AbstractCar CreateCar();\n\n}\npublic class CarTestFramework\n{\n    AbstractCar car;\n    public void BuildTestContext(CarFactory carfactory)\n    {\n        car = carfactory.CreateCar();\n    }\n\n    public void TestRun() { car.Run(); }\n    public void TestTurn(Direction d) { car.Turn(d); }\n    public void TestDeep() { car.Deep(); }\n    public void TestStop() { car.Stop(); }\n}\n```\n\n客户端调用\n```\nclass AppClient  \n{\n  public static void Main(string[] args)\n  {\n      //从配置文件中动态加载具体汽车生产工厂的dll，保证了客户代码的稳定性；即当你的应用程序\n      //版本升级时，你只需要将改变的dll给用户，或者再修改一下配置文件即可扩展此程序\n      string assemblyName = ConfigurationManager.AppSettings[\"CarFactoryAssembly\"];\n      string factoryName = ConfigurationManager.AppSettings[\"CarFactoryName\"];\n      Assembly factoryAssembly = Assembly.Load(assemblyName);\n      Type factoryType = factoryAssembly.GetType(factoryName);\n      CarTestFramework carTest = new CarTestFramework();\n      //carTest.BuildTestContext(new DaZhongFactory());\n      carTest.BuildTestContext((DaZhongFactory)Activator.CreateInstance(factoryType));\n      carTest.TestRun();\n      carTest.TestStop();\n      carTest.TestTurn(Direction.Right);\n  }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178778.html)\n","slug":"FactoryMethod","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsv2000eqk5cs4oums3y","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>当一个类不知道它所必须创建的对象的类的时候。当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个， 并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>定义一个用于创建对象的接口，让子类决定实例化 哪个子类。FactoryMethod使得一个类的实例化延迟到子类</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/96915445.jpg\" alt=\"FactoryMethod UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>有一个汽车软件测试框架，该框架需要提供一套标准接口(包括启动，行驶，转向，鸣笛，刹车等规范接口)，来为不同汽车厂商提供统一的汽车测试标准规范接口,下面就用运行工厂方法模式实现此示例</p>\n<pre><code class=\"C#\">public enum Direction\n{\n  Right,Left\n}\npublic abstract class AbstractCar\n{\n    //启动\n    public abstract void Startup();\n    //行驶\n    public abstract void Run();\n    //转向\n    public abstract void Turn(Direction dire);\n    //鸣笛\n    public abstract void Deep();\n    //刹车\n    public abstract void Stop();\n\n}\n\n/// &lt;summary&gt;\n/// 汽车工厂（抽象层） 具体实现交由具体汽车厂商\n/// &lt;/summary&gt;\npublic abstract class CarFactory\n{\n    public abstract AbstractCar CreateCar();\n\n}\npublic class CarTestFramework\n{\n    AbstractCar car;\n    public void BuildTestContext(CarFactory carfactory)\n    {\n        car = carfactory.CreateCar();\n    }\n\n    public void TestRun() { car.Run(); }\n    public void TestTurn(Direction d) { car.Turn(d); }\n    public void TestDeep() { car.Deep(); }\n    public void TestStop() { car.Stop(); }\n}\n</code></pre>\n<p>客户端调用</p>\n<pre><code>class AppClient  \n{\n  public static void Main(string[] args)\n  {\n      //从配置文件中动态加载具体汽车生产工厂的dll，保证了客户代码的稳定性；即当你的应用程序\n      //版本升级时，你只需要将改变的dll给用户，或者再修改一下配置文件即可扩展此程序\n      string assemblyName = ConfigurationManager.AppSettings[&quot;CarFactoryAssembly&quot;];\n      string factoryName = ConfigurationManager.AppSettings[&quot;CarFactoryName&quot;];\n      Assembly factoryAssembly = Assembly.Load(assemblyName);\n      Type factoryType = factoryAssembly.GetType(factoryName);\n      CarTestFramework carTest = new CarTestFramework();\n      //carTest.BuildTestContext(new DaZhongFactory());\n      carTest.BuildTestContext((DaZhongFactory)Activator.CreateInstance(factoryType));\n      carTest.TestRun();\n      carTest.TestStop();\n      carTest.TestTurn(Direction.Right);\n  }\n}\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178778.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>当一个类不知道它所必须创建的对象的类的时候。当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个， 并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>定义一个用于创建对象的接口，让子类决定实例化 哪个子类。FactoryMethod使得一个类的实例化延迟到子类</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/96915445.jpg\" alt=\"FactoryMethod UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>有一个汽车软件测试框架，该框架需要提供一套标准接口(包括启动，行驶，转向，鸣笛，刹车等规范接口)，来为不同汽车厂商提供统一的汽车测试标准规范接口,下面就用运行工厂方法模式实现此示例</p>\n<pre><code class=\"C#\">public enum Direction\n{\n  Right,Left\n}\npublic abstract class AbstractCar\n{\n    //启动\n    public abstract void Startup();\n    //行驶\n    public abstract void Run();\n    //转向\n    public abstract void Turn(Direction dire);\n    //鸣笛\n    public abstract void Deep();\n    //刹车\n    public abstract void Stop();\n\n}\n\n/// &lt;summary&gt;\n/// 汽车工厂（抽象层） 具体实现交由具体汽车厂商\n/// &lt;/summary&gt;\npublic abstract class CarFactory\n{\n    public abstract AbstractCar CreateCar();\n\n}\npublic class CarTestFramework\n{\n    AbstractCar car;\n    public void BuildTestContext(CarFactory carfactory)\n    {\n        car = carfactory.CreateCar();\n    }\n\n    public void TestRun() { car.Run(); }\n    public void TestTurn(Direction d) { car.Turn(d); }\n    public void TestDeep() { car.Deep(); }\n    public void TestStop() { car.Stop(); }\n}\n</code></pre>\n<p>客户端调用</p>\n<pre><code>class AppClient  \n{\n  public static void Main(string[] args)\n  {\n      //从配置文件中动态加载具体汽车生产工厂的dll，保证了客户代码的稳定性；即当你的应用程序\n      //版本升级时，你只需要将改变的dll给用户，或者再修改一下配置文件即可扩展此程序\n      string assemblyName = ConfigurationManager.AppSettings[&quot;CarFactoryAssembly&quot;];\n      string factoryName = ConfigurationManager.AppSettings[&quot;CarFactoryName&quot;];\n      Assembly factoryAssembly = Assembly.Load(assemblyName);\n      Type factoryType = factoryAssembly.GetType(factoryName);\n      CarTestFramework carTest = new CarTestFramework();\n      //carTest.BuildTestContext(new DaZhongFactory());\n      carTest.BuildTestContext((DaZhongFactory)Activator.CreateInstance(factoryType));\n      carTest.TestRun();\n      carTest.TestStop();\n      carTest.TestTurn(Direction.Right);\n  }\n}\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178778.html\">这里</a></p>"},{"title":"面向对象设计模式之Flyweight享元模式（结构型）","date":"2013-10-06T07:54:00.000Z","_content":"\n### 动机\n\n采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行代价——主要指内存需求方面的代价。如何在避免大量细粒度对象问题的同 时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？\n\n\n### UML图解\n\n![](http://oaefo3hoy.bkt.clouddn.com/Flyweight.jpg)\n\n\n<!--more-->\n\n### Flyweight模式现实中的应用\n\n1. 现行的博客、企业、商务网站中其网站的代码本质上是一样的，不一样的只是具体的数据和模板而代码核心和数据库却是共享的；所以现行的做法是将每个用户的博客或网站整合到一个网站中，共享其相关的代码和数据，这样对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源的浪费，而对于代码，由于是一份实例，维护和扩展都更加容易\n\n2. 再比如，.NET下字符串string 对象的也是运用了Flyweight模式，\n    ```C#\n    string a=\"享元设计模式\";\n    string b=\"享元设计模式\";\n    Object.ReferenceEquals(a,b);//返回结果是true\n    ```\n3. 像围棋、五子棋、跳棋等等，它们都有大量的棋子对象，而它们的内部状态（如颜色，大小）都是恒定的； 而外部状态（坐标）却是变化的，就围棋而论，一盘棋理论上有361个空位可以放棋子，如果用常规的面向对象方式编程，每盘棋可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，所以，现行的设计是采用享元设计模式解决这种服务器空间有限问题，采用此设计模式至少棋子对象可以减少到只有两个实例。\n\n### 示例\n\n#### 示例场景\n\n下面，我们就以五子棋为例，看看如何利用Flyweight模式，减少棋子的对象实例数目的\n\n\n#### 示例代码\n\n\n**定义一个抽象棋子类**\n\n``` C#\n    namespace Flyweight\n    {\n        /// <summary>\n        /// 抽象棋子类\n        /// </summary>\n        public abstract class Chess\n        {\n            Color color;\n            public string nickName { get; set; }\n     \n            /// <summary>\n            /// 棋子颜色\n            /// </summary>\n            public Color Color\n            {\n                get { return color; }\n            }\n     \n            /// <summary>\n            /// 棋子名称\n            /// </summary>\n            public string NickName\n            {\n                get { return nickName; }\n            }\n     \n     \n            protected Chess(Color c, string nickname)\n            {\n                color = c;\n                nickName = nickname;\n            }\n     \n            /// <summary>\n            /// 在棋盘上画出自身\n            /// </summary>\n            /// <param name=\"p\"></param>\n            /// <param name=\"radius\"></param>\n            public abstract void Draw(Point p, int radius);\n     \n        }\n    }\n```\n\n**五子棋子类，继承Chess**\n \n```C#\n    /// <summary>\n    /// 五子棋\n    /// </summary>\n    public class FiveChess:Chess\n    {\n        public FiveChess(Color c,string name)\n            : base(c, name)\n        {\n           \n        }\n \n \n        public override void Draw(Point p, int radius)\n        {\n            //画五子棋代码实现....\n        }\n    }\n ```\n\n**采用工厂模式生产五子棋棋子**\n\n其实里面控制了同一种颜色棋子只存在一个实例对象\n\n ```C#\n    /// <summary>\n    /// 生产五子棋棋子工厂类\n    /// </summary>\n    public static class FiveChessFactory\n    {\n        private static Hashtable chessTable = new Hashtable();\n \n        public static Chess GetChess(Color key)\n        {\n            if (!chessTable.ContainsKey(key))\n            {\n               chessTable.Add(key, new FiveChess(key,key.Name+\"方\"));\n            }\n            return (Chess)chessTable[key];\n        }\n    }\n ```\n\n**客户端程序调用**\n\n在程序实现里，我们就可以看出在实际下棋中，无论红方和黑方下多少棋子，只有红棋子和黑棋子两个具体实例对象，大大降低了系统的消耗\n\n```C#\n/// <summary>\n/// 客户程序\n/// </summary>\npublic class FiveChessGame\n{\n    public static void Main()\n    {\n        //红方VS黑方 可以将坐标位置用两个集合来储存，用来判断输赢\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 5), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5, 10), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 0), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5,15 ), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(10,5 ), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(20, 5), 3);\n      \n    }\n}\n```\n\n### Flyweight模式的几个要点\n\n1. 面向对象很好滴解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。\n\n2. Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体 实现方面，要注意对象状态的处理\n\n3. 对象的数量太大从而导致对象内存开销大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断\n\n##### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353782.html)\n","source":"_posts/Flyweight.md","raw":"---\ntitle: 面向对象设计模式之Flyweight享元模式（结构型）\ndate: 2013-10-06 15:54\ncategories: 设计模式\ntags: ['享元模式','Flyweight']\n---\n\n### 动机\n\n采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行代价——主要指内存需求方面的代价。如何在避免大量细粒度对象问题的同 时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？\n\n\n### UML图解\n\n![](http://oaefo3hoy.bkt.clouddn.com/Flyweight.jpg)\n\n\n<!--more-->\n\n### Flyweight模式现实中的应用\n\n1. 现行的博客、企业、商务网站中其网站的代码本质上是一样的，不一样的只是具体的数据和模板而代码核心和数据库却是共享的；所以现行的做法是将每个用户的博客或网站整合到一个网站中，共享其相关的代码和数据，这样对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源的浪费，而对于代码，由于是一份实例，维护和扩展都更加容易\n\n2. 再比如，.NET下字符串string 对象的也是运用了Flyweight模式，\n    ```C#\n    string a=\"享元设计模式\";\n    string b=\"享元设计模式\";\n    Object.ReferenceEquals(a,b);//返回结果是true\n    ```\n3. 像围棋、五子棋、跳棋等等，它们都有大量的棋子对象，而它们的内部状态（如颜色，大小）都是恒定的； 而外部状态（坐标）却是变化的，就围棋而论，一盘棋理论上有361个空位可以放棋子，如果用常规的面向对象方式编程，每盘棋可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，所以，现行的设计是采用享元设计模式解决这种服务器空间有限问题，采用此设计模式至少棋子对象可以减少到只有两个实例。\n\n### 示例\n\n#### 示例场景\n\n下面，我们就以五子棋为例，看看如何利用Flyweight模式，减少棋子的对象实例数目的\n\n\n#### 示例代码\n\n\n**定义一个抽象棋子类**\n\n``` C#\n    namespace Flyweight\n    {\n        /// <summary>\n        /// 抽象棋子类\n        /// </summary>\n        public abstract class Chess\n        {\n            Color color;\n            public string nickName { get; set; }\n     \n            /// <summary>\n            /// 棋子颜色\n            /// </summary>\n            public Color Color\n            {\n                get { return color; }\n            }\n     \n            /// <summary>\n            /// 棋子名称\n            /// </summary>\n            public string NickName\n            {\n                get { return nickName; }\n            }\n     \n     \n            protected Chess(Color c, string nickname)\n            {\n                color = c;\n                nickName = nickname;\n            }\n     \n            /// <summary>\n            /// 在棋盘上画出自身\n            /// </summary>\n            /// <param name=\"p\"></param>\n            /// <param name=\"radius\"></param>\n            public abstract void Draw(Point p, int radius);\n     \n        }\n    }\n```\n\n**五子棋子类，继承Chess**\n \n```C#\n    /// <summary>\n    /// 五子棋\n    /// </summary>\n    public class FiveChess:Chess\n    {\n        public FiveChess(Color c,string name)\n            : base(c, name)\n        {\n           \n        }\n \n \n        public override void Draw(Point p, int radius)\n        {\n            //画五子棋代码实现....\n        }\n    }\n ```\n\n**采用工厂模式生产五子棋棋子**\n\n其实里面控制了同一种颜色棋子只存在一个实例对象\n\n ```C#\n    /// <summary>\n    /// 生产五子棋棋子工厂类\n    /// </summary>\n    public static class FiveChessFactory\n    {\n        private static Hashtable chessTable = new Hashtable();\n \n        public static Chess GetChess(Color key)\n        {\n            if (!chessTable.ContainsKey(key))\n            {\n               chessTable.Add(key, new FiveChess(key,key.Name+\"方\"));\n            }\n            return (Chess)chessTable[key];\n        }\n    }\n ```\n\n**客户端程序调用**\n\n在程序实现里，我们就可以看出在实际下棋中，无论红方和黑方下多少棋子，只有红棋子和黑棋子两个具体实例对象，大大降低了系统的消耗\n\n```C#\n/// <summary>\n/// 客户程序\n/// </summary>\npublic class FiveChessGame\n{\n    public static void Main()\n    {\n        //红方VS黑方 可以将坐标位置用两个集合来储存，用来判断输赢\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 5), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5, 10), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 0), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5,15 ), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(10,5 ), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(20, 5), 3);\n      \n    }\n}\n```\n\n### Flyweight模式的几个要点\n\n1. 面向对象很好滴解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。\n\n2. Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体 实现方面，要注意对象状态的处理\n\n3. 对象的数量太大从而导致对象内存开销大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断\n\n##### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353782.html)\n","slug":"Flyweight","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsv7000jqk5c8vgxj63v","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行代价——主要指内存需求方面的代价。如何在避免大量细粒度对象问题的同 时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Flyweight.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"Flyweight模式现实中的应用\"><a href=\"#Flyweight模式现实中的应用\" class=\"headerlink\" title=\"Flyweight模式现实中的应用\"></a>Flyweight模式现实中的应用</h3><ol>\n<li><p>现行的博客、企业、商务网站中其网站的代码本质上是一样的，不一样的只是具体的数据和模板而代码核心和数据库却是共享的；所以现行的做法是将每个用户的博客或网站整合到一个网站中，共享其相关的代码和数据，这样对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源的浪费，而对于代码，由于是一份实例，维护和扩展都更加容易</p>\n</li>\n<li><p>再比如，.NET下字符串string 对象的也是运用了Flyweight模式，</p>\n<pre><code class=\"C#\"> string a=&quot;享元设计模式&quot;;\n string b=&quot;享元设计模式&quot;;\n Object.ReferenceEquals(a,b);//返回结果是true\n</code></pre>\n</li>\n<li>像围棋、五子棋、跳棋等等，它们都有大量的棋子对象，而它们的内部状态（如颜色，大小）都是恒定的； 而外部状态（坐标）却是变化的，就围棋而论，一盘棋理论上有361个空位可以放棋子，如果用常规的面向对象方式编程，每盘棋可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，所以，现行的设计是采用享元设计模式解决这种服务器空间有限问题，采用此设计模式至少棋子对象可以减少到只有两个实例。</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>下面，我们就以五子棋为例，看看如何利用Flyweight模式，减少棋子的对象实例数目的</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><p><strong>定义一个抽象棋子类</strong></p>\n<pre><code class=\"C#\">    namespace Flyweight\n    {\n        /// &lt;summary&gt;\n        /// 抽象棋子类\n        /// &lt;/summary&gt;\n        public abstract class Chess\n        {\n            Color color;\n            public string nickName { get; set; }\n\n            /// &lt;summary&gt;\n            /// 棋子颜色\n            /// &lt;/summary&gt;\n            public Color Color\n            {\n                get { return color; }\n            }\n\n            /// &lt;summary&gt;\n            /// 棋子名称\n            /// &lt;/summary&gt;\n            public string NickName\n            {\n                get { return nickName; }\n            }\n\n\n            protected Chess(Color c, string nickname)\n            {\n                color = c;\n                nickName = nickname;\n            }\n\n            /// &lt;summary&gt;\n            /// 在棋盘上画出自身\n            /// &lt;/summary&gt;\n            /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;\n            /// &lt;param name=&quot;radius&quot;&gt;&lt;/param&gt;\n            public abstract void Draw(Point p, int radius);\n\n        }\n    }\n</code></pre>\n<p><strong>五子棋子类，继承Chess</strong></p>\n<pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 五子棋\n    /// &lt;/summary&gt;\n    public class FiveChess:Chess\n    {\n        public FiveChess(Color c,string name)\n            : base(c, name)\n        {\n\n        }\n\n\n        public override void Draw(Point p, int radius)\n        {\n            //画五子棋代码实现....\n        }\n    }\n</code></pre>\n<p><strong>采用工厂模式生产五子棋棋子</strong></p>\n<p>其实里面控制了同一种颜色棋子只存在一个实例对象</p>\n<pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 生产五子棋棋子工厂类\n    /// &lt;/summary&gt;\n    public static class FiveChessFactory\n    {\n        private static Hashtable chessTable = new Hashtable();\n\n        public static Chess GetChess(Color key)\n        {\n            if (!chessTable.ContainsKey(key))\n            {\n               chessTable.Add(key, new FiveChess(key,key.Name+&quot;方&quot;));\n            }\n            return (Chess)chessTable[key];\n        }\n    }\n</code></pre>\n<p><strong>客户端程序调用</strong></p>\n<p>在程序实现里，我们就可以看出在实际下棋中，无论红方和黑方下多少棋子，只有红棋子和黑棋子两个具体实例对象，大大降低了系统的消耗</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 客户程序\n/// &lt;/summary&gt;\npublic class FiveChessGame\n{\n    public static void Main()\n    {\n        //红方VS黑方 可以将坐标位置用两个集合来储存，用来判断输赢\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 5), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5, 10), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 0), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5,15 ), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(10,5 ), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(20, 5), 3);\n\n    }\n}\n</code></pre>\n<h3 id=\"Flyweight模式的几个要点\"><a href=\"#Flyweight模式的几个要点\" class=\"headerlink\" title=\"Flyweight模式的几个要点\"></a>Flyweight模式的几个要点</h3><ol>\n<li><p>面向对象很好滴解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</p>\n</li>\n<li><p>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体 实现方面，要注意对象状态的处理</p>\n</li>\n<li><p>对象的数量太大从而导致对象内存开销大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断</p>\n</li>\n</ol>\n<h5 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h5><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353782.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行代价——主要指内存需求方面的代价。如何在避免大量细粒度对象问题的同 时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Flyweight.jpg\" alt=\"\"></p>","more":"<h3 id=\"Flyweight模式现实中的应用\"><a href=\"#Flyweight模式现实中的应用\" class=\"headerlink\" title=\"Flyweight模式现实中的应用\"></a>Flyweight模式现实中的应用</h3><ol>\n<li><p>现行的博客、企业、商务网站中其网站的代码本质上是一样的，不一样的只是具体的数据和模板而代码核心和数据库却是共享的；所以现行的做法是将每个用户的博客或网站整合到一个网站中，共享其相关的代码和数据，这样对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源的浪费，而对于代码，由于是一份实例，维护和扩展都更加容易</p>\n</li>\n<li><p>再比如，.NET下字符串string 对象的也是运用了Flyweight模式，</p>\n<pre><code class=\"C#\"> string a=&quot;享元设计模式&quot;;\n string b=&quot;享元设计模式&quot;;\n Object.ReferenceEquals(a,b);//返回结果是true\n</code></pre>\n</li>\n<li>像围棋、五子棋、跳棋等等，它们都有大量的棋子对象，而它们的内部状态（如颜色，大小）都是恒定的； 而外部状态（坐标）却是变化的，就围棋而论，一盘棋理论上有361个空位可以放棋子，如果用常规的面向对象方式编程，每盘棋可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，所以，现行的设计是采用享元设计模式解决这种服务器空间有限问题，采用此设计模式至少棋子对象可以减少到只有两个实例。</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>下面，我们就以五子棋为例，看看如何利用Flyweight模式，减少棋子的对象实例数目的</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><p><strong>定义一个抽象棋子类</strong></p>\n<pre><code class=\"C#\">    namespace Flyweight\n    {\n        /// &lt;summary&gt;\n        /// 抽象棋子类\n        /// &lt;/summary&gt;\n        public abstract class Chess\n        {\n            Color color;\n            public string nickName { get; set; }\n\n            /// &lt;summary&gt;\n            /// 棋子颜色\n            /// &lt;/summary&gt;\n            public Color Color\n            {\n                get { return color; }\n            }\n\n            /// &lt;summary&gt;\n            /// 棋子名称\n            /// &lt;/summary&gt;\n            public string NickName\n            {\n                get { return nickName; }\n            }\n\n\n            protected Chess(Color c, string nickname)\n            {\n                color = c;\n                nickName = nickname;\n            }\n\n            /// &lt;summary&gt;\n            /// 在棋盘上画出自身\n            /// &lt;/summary&gt;\n            /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;\n            /// &lt;param name=&quot;radius&quot;&gt;&lt;/param&gt;\n            public abstract void Draw(Point p, int radius);\n\n        }\n    }\n</code></pre>\n<p><strong>五子棋子类，继承Chess</strong></p>\n<pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 五子棋\n    /// &lt;/summary&gt;\n    public class FiveChess:Chess\n    {\n        public FiveChess(Color c,string name)\n            : base(c, name)\n        {\n\n        }\n\n\n        public override void Draw(Point p, int radius)\n        {\n            //画五子棋代码实现....\n        }\n    }\n</code></pre>\n<p><strong>采用工厂模式生产五子棋棋子</strong></p>\n<p>其实里面控制了同一种颜色棋子只存在一个实例对象</p>\n<pre><code class=\"C#\">    /// &lt;summary&gt;\n    /// 生产五子棋棋子工厂类\n    /// &lt;/summary&gt;\n    public static class FiveChessFactory\n    {\n        private static Hashtable chessTable = new Hashtable();\n\n        public static Chess GetChess(Color key)\n        {\n            if (!chessTable.ContainsKey(key))\n            {\n               chessTable.Add(key, new FiveChess(key,key.Name+&quot;方&quot;));\n            }\n            return (Chess)chessTable[key];\n        }\n    }\n</code></pre>\n<p><strong>客户端程序调用</strong></p>\n<p>在程序实现里，我们就可以看出在实际下棋中，无论红方和黑方下多少棋子，只有红棋子和黑棋子两个具体实例对象，大大降低了系统的消耗</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 客户程序\n/// &lt;/summary&gt;\npublic class FiveChessGame\n{\n    public static void Main()\n    {\n        //红方VS黑方 可以将坐标位置用两个集合来储存，用来判断输赢\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 5), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5, 10), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(5, 0), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(5,15 ), 3);\n\n        FiveChessFactory.GetChess(Color.Red).Draw(new Point(10,5 ), 3);\n        FiveChessFactory.GetChess(Color.Black).Draw(new Point(20, 5), 3);\n\n    }\n}\n</code></pre>\n<h3 id=\"Flyweight模式的几个要点\"><a href=\"#Flyweight模式的几个要点\" class=\"headerlink\" title=\"Flyweight模式的几个要点\"></a>Flyweight模式的几个要点</h3><ol>\n<li><p>面向对象很好滴解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</p>\n</li>\n<li><p>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体 实现方面，要注意对象状态的处理</p>\n</li>\n<li><p>对象的数量太大从而导致对象内存开销大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断</p>\n</li>\n</ol>\n<h5 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h5><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353782.html\">这里</a></p>"},{"title":"面向对象设计模式之Interpreter解释器模式（行为型）","date":"2013-10-06T08:17:00.000Z","_content":"\n### 动机\n\n在软件构建过程中 ，如果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。\n意图：给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。\n\n<!--more-->\n\n### Interpreter模式的几个要点\n\n1.Interpreter模式的应用场景是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且 类似的模式不断重复出现，并且容易抽象为语法规则的问题”才合适使用Interpreter模式。\n\n2.使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法。\n\n3.Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类 层次结构，需要求助于语法分析生成器这样的标准工具。\n\n### UML图解\n\n![](http://oaefo3hoy.bkt.clouddn.com/Interpreter.jpg)\n\n\n### 示例\n\n\n####  示例说明\n接收中文形式的数字表示并能以罗马形式数字输出，应用解释器模式设计，如：四百七十一万六千四百五十二 =》4716452。\n\n\n#### 示例代码\n\n代码都在命名空间Interpreter编写\n\n##### 首先定义一个上下文，存放解析器解析过程中的中间数据\n\n```C#\nnamespace Interpreter\n{\n    /// <summary>\n    /// 定义一个数据上下文\n    /// </summary>\n    public class Context\n    {\n        string statement=\"\";//待解释的数据\n        int data;//解释之后的数据\n        public Context (string statement)\n        {\n            this.statement = statement;\n        }\n        public int Data\n        {\n            get { return data; }\n            set { data = value; }\n        }\n        public string Statement\n        {\n            get { return statement; }\n            set { statement = value; }\n        }\n \n \n    }\n```\n\n\n##### 抽象表达式解释器\n\n```C#\n/// <summary>\n/// 抽象表达式解释器\n/// </summary>\npublic abstract class Expression\n{\n    protected Dictionary<string, int> table = new Dictionary<string, int>(9);\n    public Expression()\n    {\n        table.Add(\"一\", 1);\n        table.Add(\"二\", 2);\n        table.Add(\"三\", 3);\n        table.Add(\"四\", 4);\n        table.Add(\"五\", 5);\n        table.Add(\"六\", 6);\n        table.Add(\"七\", 7);\n        table.Add(\"八\", 8);\n        table.Add(\"九\", 9);\n    }\n\n    /// <summary>\n    /// 解释给定的中文表示数字上下文对象\n    /// </summary>\n    /// <param name=\"context\"></param>\n    public virtual void Interpreter(Context context)\n    {\n        if (context.Statement.Length == 0)\n        {\n            return;\n        }\n        foreach (string key in table.Keys)\n        {\n            int value=table[key];\n            if (context.Statement.EndsWith(key+GetPostfix()))\n            {\n                context.Data += value * this.Multiplier();\n                context.Statement = context.Statement.Substring(0, context.Statement.Length - GetLength());\n            }\n            if (context.Statement.EndsWith(\"零\"))//应对如\"四百七十一万零六千四百零五十二\"中出现'零'的情况\n            {\n                context.Statement=context.Statement.Substring(0,context.Statement.Length-1);\n            }\n        }\n    }\n\n    /// <summary>\n    /// 获取如“六千四百五十二”中，获取千位的'千'字，百位的'百'字，十位的'十'字\n    /// </summary>\n    /// <returns></returns>\n    public abstract string GetPostfix();\n\n    /// <summary>\n    /// 陪增级数（个-1,十位-10,百位-100,千位-1000）\n    /// </summary>\n    /// <returns></returns>\n    public abstract int Multiplier();\n\n    /// <summary>\n    /// 获取符合文法的一组长度（如获取“四百”，“五十”的长度）\n    /// </summary>\n    /// <returns></returns>\n    public virtual int GetLength()\n    {\n        return this.GetPostfix().Length + 1;\n    }\n}\n```\n\n\n##### 个十百千万解释器实现\n\n**个位解释器**\n```C#\n/// <summary>\n/// 个位解释器 解析个位\n/// </summary>\npublic class GeExpression : Expression\n{\n\n    public override string GetPostfix()\n    {\n        return \"\";\n    }\n\n    public override int Multiplier()\n    {\n        return 1;\n    }\n\n\n    public override int GetLength()\n    {\n        return  1;\n    }\n}\n ````\n\n**十位解释器**\n\n ```c#\n    /// <summary>\n    /// 十位解释器 解析个位+十位\n    /// </summary>\n    public class ShiExpression : Expression\n    {\n \n        public override string GetPostfix()\n        {\n            return \"十\";\n        }\n \n        public override int Multiplier()\n        {\n            return 10;\n        }\n    }\n ```\n\n**百位解释器**\n\n ```\n    /// <summary>\n    /// 百位解释器 解析个位+十位+百位\n    /// </summary>\n    public class BaiExpresssion : Expression\n    {\n \n        public override string GetPostfix()\n        {\n            return \"百\";\n        }\n \n        public override int Multiplier()\n        {\n            return 100;\n        }\n    }\n ```\n\n**千位解释器**\n ```\n    /// <summary>\n    /// 千位解释器 解析个位+十位+百位+千位\n    /// </summary>\n    public class QianExpression : Expression\n    {\n \n        public override string GetPostfix()\n        {\n            return \"千\";\n        }\n \n        public override int Multiplier()\n        {\n            return 1000;\n        }\n    }\n\n```\n\n**万位解释器**\n\n```\n \n    /// <summary>\n    /// 万位解释器 解析个位+十位+百位+千位+万位\n    /// </summary>\n    public class WanExpression : Expression\n    {\n        public override void Interpreter(Context context)\n        {\n            if (context.Statement.Length == 0)\n            {\n                return;\n            }\n            ArrayList tree = new ArrayList();\n            tree.Add(new GeExpression());\n            tree.Add(new ShiExpression());\n            tree.Add(new BaiExpresssion());\n            tree.Add(new QianExpression());\n \n            foreach (string key in table.Keys)\n            {\n                if (context.Statement.EndsWith(this.GetPostfix()))\n                {\n                    int temp = context.Data;\n                    context.Data = 0;\n                    context.Statement=context.Statement.Substring(0, context.Statement.Length - 1);\n                    foreach(Expression expression in tree)\n                    {\n                        expression.Interpreter(context);\n                    }\n                    context.Data = temp+this.Multiplier()*context.Data;\n                }\n            }\n            \n             \n        }\n \n        public override string GetPostfix()\n        {\n            return \"万\";\n        }\n \n        public override int Multiplier()\n        {\n            return 10000;\n        }\n    }\n```\n\n以上，我们可以很轻松通过Interpreter模式扩展亿位相对的YiExpression类\n\n\n**主程序调用**\n``` \npublic class App\n{\n    public static void Main()\n    {\n\n        string chinese=\"四百七十一万六千四百五十二\";\n        Context context =new Context(chinese);\n        ArrayList tree = new ArrayList();//需按顺序添加个十百千万等解释表达式对象\n        tree.Add(new GeExpression());\n        tree.Add(new ShiExpression());\n        tree.Add(new BaiExpresssion());\n        tree.Add(new QianExpression());\n        tree.Add(new WanExpression());\n        foreach (Expression exp in tree)\n        {\n            exp.Interpreter(context);\n        }\n        Console.WriteLine(\"{0}={1}\",chinese,context.Data);\n    }\n}\n\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353829.html)\n","source":"_posts/Interpreter.md","raw":"---\ntitle: 面向对象设计模式之Interpreter解释器模式（行为型）\ndate: 2013-10-06 16:17\ncategories: 设计模式\ntags: ['解释器模式','Interpreter']\n---\n\n### 动机\n\n在软件构建过程中 ，如果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。\n意图：给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。\n\n<!--more-->\n\n### Interpreter模式的几个要点\n\n1.Interpreter模式的应用场景是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且 类似的模式不断重复出现，并且容易抽象为语法规则的问题”才合适使用Interpreter模式。\n\n2.使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法。\n\n3.Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类 层次结构，需要求助于语法分析生成器这样的标准工具。\n\n### UML图解\n\n![](http://oaefo3hoy.bkt.clouddn.com/Interpreter.jpg)\n\n\n### 示例\n\n\n####  示例说明\n接收中文形式的数字表示并能以罗马形式数字输出，应用解释器模式设计，如：四百七十一万六千四百五十二 =》4716452。\n\n\n#### 示例代码\n\n代码都在命名空间Interpreter编写\n\n##### 首先定义一个上下文，存放解析器解析过程中的中间数据\n\n```C#\nnamespace Interpreter\n{\n    /// <summary>\n    /// 定义一个数据上下文\n    /// </summary>\n    public class Context\n    {\n        string statement=\"\";//待解释的数据\n        int data;//解释之后的数据\n        public Context (string statement)\n        {\n            this.statement = statement;\n        }\n        public int Data\n        {\n            get { return data; }\n            set { data = value; }\n        }\n        public string Statement\n        {\n            get { return statement; }\n            set { statement = value; }\n        }\n \n \n    }\n```\n\n\n##### 抽象表达式解释器\n\n```C#\n/// <summary>\n/// 抽象表达式解释器\n/// </summary>\npublic abstract class Expression\n{\n    protected Dictionary<string, int> table = new Dictionary<string, int>(9);\n    public Expression()\n    {\n        table.Add(\"一\", 1);\n        table.Add(\"二\", 2);\n        table.Add(\"三\", 3);\n        table.Add(\"四\", 4);\n        table.Add(\"五\", 5);\n        table.Add(\"六\", 6);\n        table.Add(\"七\", 7);\n        table.Add(\"八\", 8);\n        table.Add(\"九\", 9);\n    }\n\n    /// <summary>\n    /// 解释给定的中文表示数字上下文对象\n    /// </summary>\n    /// <param name=\"context\"></param>\n    public virtual void Interpreter(Context context)\n    {\n        if (context.Statement.Length == 0)\n        {\n            return;\n        }\n        foreach (string key in table.Keys)\n        {\n            int value=table[key];\n            if (context.Statement.EndsWith(key+GetPostfix()))\n            {\n                context.Data += value * this.Multiplier();\n                context.Statement = context.Statement.Substring(0, context.Statement.Length - GetLength());\n            }\n            if (context.Statement.EndsWith(\"零\"))//应对如\"四百七十一万零六千四百零五十二\"中出现'零'的情况\n            {\n                context.Statement=context.Statement.Substring(0,context.Statement.Length-1);\n            }\n        }\n    }\n\n    /// <summary>\n    /// 获取如“六千四百五十二”中，获取千位的'千'字，百位的'百'字，十位的'十'字\n    /// </summary>\n    /// <returns></returns>\n    public abstract string GetPostfix();\n\n    /// <summary>\n    /// 陪增级数（个-1,十位-10,百位-100,千位-1000）\n    /// </summary>\n    /// <returns></returns>\n    public abstract int Multiplier();\n\n    /// <summary>\n    /// 获取符合文法的一组长度（如获取“四百”，“五十”的长度）\n    /// </summary>\n    /// <returns></returns>\n    public virtual int GetLength()\n    {\n        return this.GetPostfix().Length + 1;\n    }\n}\n```\n\n\n##### 个十百千万解释器实现\n\n**个位解释器**\n```C#\n/// <summary>\n/// 个位解释器 解析个位\n/// </summary>\npublic class GeExpression : Expression\n{\n\n    public override string GetPostfix()\n    {\n        return \"\";\n    }\n\n    public override int Multiplier()\n    {\n        return 1;\n    }\n\n\n    public override int GetLength()\n    {\n        return  1;\n    }\n}\n ````\n\n**十位解释器**\n\n ```c#\n    /// <summary>\n    /// 十位解释器 解析个位+十位\n    /// </summary>\n    public class ShiExpression : Expression\n    {\n \n        public override string GetPostfix()\n        {\n            return \"十\";\n        }\n \n        public override int Multiplier()\n        {\n            return 10;\n        }\n    }\n ```\n\n**百位解释器**\n\n ```\n    /// <summary>\n    /// 百位解释器 解析个位+十位+百位\n    /// </summary>\n    public class BaiExpresssion : Expression\n    {\n \n        public override string GetPostfix()\n        {\n            return \"百\";\n        }\n \n        public override int Multiplier()\n        {\n            return 100;\n        }\n    }\n ```\n\n**千位解释器**\n ```\n    /// <summary>\n    /// 千位解释器 解析个位+十位+百位+千位\n    /// </summary>\n    public class QianExpression : Expression\n    {\n \n        public override string GetPostfix()\n        {\n            return \"千\";\n        }\n \n        public override int Multiplier()\n        {\n            return 1000;\n        }\n    }\n\n```\n\n**万位解释器**\n\n```\n \n    /// <summary>\n    /// 万位解释器 解析个位+十位+百位+千位+万位\n    /// </summary>\n    public class WanExpression : Expression\n    {\n        public override void Interpreter(Context context)\n        {\n            if (context.Statement.Length == 0)\n            {\n                return;\n            }\n            ArrayList tree = new ArrayList();\n            tree.Add(new GeExpression());\n            tree.Add(new ShiExpression());\n            tree.Add(new BaiExpresssion());\n            tree.Add(new QianExpression());\n \n            foreach (string key in table.Keys)\n            {\n                if (context.Statement.EndsWith(this.GetPostfix()))\n                {\n                    int temp = context.Data;\n                    context.Data = 0;\n                    context.Statement=context.Statement.Substring(0, context.Statement.Length - 1);\n                    foreach(Expression expression in tree)\n                    {\n                        expression.Interpreter(context);\n                    }\n                    context.Data = temp+this.Multiplier()*context.Data;\n                }\n            }\n            \n             \n        }\n \n        public override string GetPostfix()\n        {\n            return \"万\";\n        }\n \n        public override int Multiplier()\n        {\n            return 10000;\n        }\n    }\n```\n\n以上，我们可以很轻松通过Interpreter模式扩展亿位相对的YiExpression类\n\n\n**主程序调用**\n``` \npublic class App\n{\n    public static void Main()\n    {\n\n        string chinese=\"四百七十一万六千四百五十二\";\n        Context context =new Context(chinese);\n        ArrayList tree = new ArrayList();//需按顺序添加个十百千万等解释表达式对象\n        tree.Add(new GeExpression());\n        tree.Add(new ShiExpression());\n        tree.Add(new BaiExpresssion());\n        tree.Add(new QianExpression());\n        tree.Add(new WanExpression());\n        foreach (Expression exp in tree)\n        {\n            exp.Interpreter(context);\n        }\n        Console.WriteLine(\"{0}={1}\",chinese,context.Data);\n    }\n}\n\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353829.html)\n","slug":"Interpreter","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsv9000mqk5cp7iildfe","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件构建过程中 ，如果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。<br>意图：给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</p>\n<a id=\"more\"></a>\n<h3 id=\"Interpreter模式的几个要点\"><a href=\"#Interpreter模式的几个要点\" class=\"headerlink\" title=\"Interpreter模式的几个要点\"></a>Interpreter模式的几个要点</h3><p>1.Interpreter模式的应用场景是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且 类似的模式不断重复出现，并且容易抽象为语法规则的问题”才合适使用Interpreter模式。</p>\n<p>2.使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法。</p>\n<p>3.Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类 层次结构，需要求助于语法分析生成器这样的标准工具。</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Interpreter.jpg\" alt=\"\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h4><p>接收中文形式的数字表示并能以罗马形式数字输出，应用解释器模式设计，如：四百七十一万六千四百五十二 =》4716452。</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><p>代码都在命名空间Interpreter编写</p>\n<h5 id=\"首先定义一个上下文，存放解析器解析过程中的中间数据\"><a href=\"#首先定义一个上下文，存放解析器解析过程中的中间数据\" class=\"headerlink\" title=\"首先定义一个上下文，存放解析器解析过程中的中间数据\"></a>首先定义一个上下文，存放解析器解析过程中的中间数据</h5><pre><code class=\"C#\">namespace Interpreter\n{\n    /// &lt;summary&gt;\n    /// 定义一个数据上下文\n    /// &lt;/summary&gt;\n    public class Context\n    {\n        string statement=&quot;&quot;;//待解释的数据\n        int data;//解释之后的数据\n        public Context (string statement)\n        {\n            this.statement = statement;\n        }\n        public int Data\n        {\n            get { return data; }\n            set { data = value; }\n        }\n        public string Statement\n        {\n            get { return statement; }\n            set { statement = value; }\n        }\n\n\n    }\n</code></pre>\n<h5 id=\"抽象表达式解释器\"><a href=\"#抽象表达式解释器\" class=\"headerlink\" title=\"抽象表达式解释器\"></a>抽象表达式解释器</h5><pre><code class=\"C#\">/// &lt;summary&gt;\n/// 抽象表达式解释器\n/// &lt;/summary&gt;\npublic abstract class Expression\n{\n    protected Dictionary&lt;string, int&gt; table = new Dictionary&lt;string, int&gt;(9);\n    public Expression()\n    {\n        table.Add(&quot;一&quot;, 1);\n        table.Add(&quot;二&quot;, 2);\n        table.Add(&quot;三&quot;, 3);\n        table.Add(&quot;四&quot;, 4);\n        table.Add(&quot;五&quot;, 5);\n        table.Add(&quot;六&quot;, 6);\n        table.Add(&quot;七&quot;, 7);\n        table.Add(&quot;八&quot;, 8);\n        table.Add(&quot;九&quot;, 9);\n    }\n\n    /// &lt;summary&gt;\n    /// 解释给定的中文表示数字上下文对象\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;\n    public virtual void Interpreter(Context context)\n    {\n        if (context.Statement.Length == 0)\n        {\n            return;\n        }\n        foreach (string key in table.Keys)\n        {\n            int value=table[key];\n            if (context.Statement.EndsWith(key+GetPostfix()))\n            {\n                context.Data += value * this.Multiplier();\n                context.Statement = context.Statement.Substring(0, context.Statement.Length - GetLength());\n            }\n            if (context.Statement.EndsWith(&quot;零&quot;))//应对如&quot;四百七十一万零六千四百零五十二&quot;中出现&#39;零&#39;的情况\n            {\n                context.Statement=context.Statement.Substring(0,context.Statement.Length-1);\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 获取如“六千四百五十二”中，获取千位的&#39;千&#39;字，百位的&#39;百&#39;字，十位的&#39;十&#39;字\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public abstract string GetPostfix();\n\n    /// &lt;summary&gt;\n    /// 陪增级数（个-1,十位-10,百位-100,千位-1000）\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public abstract int Multiplier();\n\n    /// &lt;summary&gt;\n    /// 获取符合文法的一组长度（如获取“四百”，“五十”的长度）\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public virtual int GetLength()\n    {\n        return this.GetPostfix().Length + 1;\n    }\n}\n</code></pre>\n<h5 id=\"个十百千万解释器实现\"><a href=\"#个十百千万解释器实现\" class=\"headerlink\" title=\"个十百千万解释器实现\"></a>个十百千万解释器实现</h5><p><strong>个位解释器</strong></p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 个位解释器 解析个位\n/// &lt;/summary&gt;\npublic class GeExpression : Expression\n{\n\n    public override string GetPostfix()\n    {\n        return &quot;&quot;;\n    }\n\n    public override int Multiplier()\n    {\n        return 1;\n    }\n\n\n    public override int GetLength()\n    {\n        return  1;\n    }\n}\n `\n</code></pre>\n<p><strong>十位解释器</strong></p>\n<pre><code class=\"c#\">    /// &lt;summary&gt;\n    /// 十位解释器 解析个位+十位\n    /// &lt;/summary&gt;\n    public class ShiExpression : Expression\n    {\n\n        public override string GetPostfix()\n        {\n            return &quot;十&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 10;\n        }\n    }\n</code></pre>\n<p><strong>百位解释器</strong></p>\n<pre><code>    /// &lt;summary&gt;\n    /// 百位解释器 解析个位+十位+百位\n    /// &lt;/summary&gt;\n    public class BaiExpresssion : Expression\n    {\n\n        public override string GetPostfix()\n        {\n            return &quot;百&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 100;\n        }\n    }\n</code></pre><p><strong>千位解释器</strong></p>\n<pre><code>    /// &lt;summary&gt;\n    /// 千位解释器 解析个位+十位+百位+千位\n    /// &lt;/summary&gt;\n    public class QianExpression : Expression\n    {\n\n        public override string GetPostfix()\n        {\n            return &quot;千&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 1000;\n        }\n    }\n</code></pre><p><strong>万位解释器</strong></p>\n<pre><code>\n    /// &lt;summary&gt;\n    /// 万位解释器 解析个位+十位+百位+千位+万位\n    /// &lt;/summary&gt;\n    public class WanExpression : Expression\n    {\n        public override void Interpreter(Context context)\n        {\n            if (context.Statement.Length == 0)\n            {\n                return;\n            }\n            ArrayList tree = new ArrayList();\n            tree.Add(new GeExpression());\n            tree.Add(new ShiExpression());\n            tree.Add(new BaiExpresssion());\n            tree.Add(new QianExpression());\n\n            foreach (string key in table.Keys)\n            {\n                if (context.Statement.EndsWith(this.GetPostfix()))\n                {\n                    int temp = context.Data;\n                    context.Data = 0;\n                    context.Statement=context.Statement.Substring(0, context.Statement.Length - 1);\n                    foreach(Expression expression in tree)\n                    {\n                        expression.Interpreter(context);\n                    }\n                    context.Data = temp+this.Multiplier()*context.Data;\n                }\n            }\n\n\n        }\n\n        public override string GetPostfix()\n        {\n            return &quot;万&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 10000;\n        }\n    }\n</code></pre><p>以上，我们可以很轻松通过Interpreter模式扩展亿位相对的YiExpression类</p>\n<p><strong>主程序调用</strong></p>\n<pre><code>public class App\n{\n    public static void Main()\n    {\n\n        string chinese=&quot;四百七十一万六千四百五十二&quot;;\n        Context context =new Context(chinese);\n        ArrayList tree = new ArrayList();//需按顺序添加个十百千万等解释表达式对象\n        tree.Add(new GeExpression());\n        tree.Add(new ShiExpression());\n        tree.Add(new BaiExpresssion());\n        tree.Add(new QianExpression());\n        tree.Add(new WanExpression());\n        foreach (Expression exp in tree)\n        {\n            exp.Interpreter(context);\n        }\n        Console.WriteLine(&quot;{0}={1}&quot;,chinese,context.Data);\n    }\n}\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353829.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件构建过程中 ，如果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。<br>意图：给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</p>","more":"<h3 id=\"Interpreter模式的几个要点\"><a href=\"#Interpreter模式的几个要点\" class=\"headerlink\" title=\"Interpreter模式的几个要点\"></a>Interpreter模式的几个要点</h3><p>1.Interpreter模式的应用场景是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且 类似的模式不断重复出现，并且容易抽象为语法规则的问题”才合适使用Interpreter模式。</p>\n<p>2.使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法。</p>\n<p>3.Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类 层次结构，需要求助于语法分析生成器这样的标准工具。</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/Interpreter.jpg\" alt=\"\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h4><p>接收中文形式的数字表示并能以罗马形式数字输出，应用解释器模式设计，如：四百七十一万六千四百五十二 =》4716452。</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><p>代码都在命名空间Interpreter编写</p>\n<h5 id=\"首先定义一个上下文，存放解析器解析过程中的中间数据\"><a href=\"#首先定义一个上下文，存放解析器解析过程中的中间数据\" class=\"headerlink\" title=\"首先定义一个上下文，存放解析器解析过程中的中间数据\"></a>首先定义一个上下文，存放解析器解析过程中的中间数据</h5><pre><code class=\"C#\">namespace Interpreter\n{\n    /// &lt;summary&gt;\n    /// 定义一个数据上下文\n    /// &lt;/summary&gt;\n    public class Context\n    {\n        string statement=&quot;&quot;;//待解释的数据\n        int data;//解释之后的数据\n        public Context (string statement)\n        {\n            this.statement = statement;\n        }\n        public int Data\n        {\n            get { return data; }\n            set { data = value; }\n        }\n        public string Statement\n        {\n            get { return statement; }\n            set { statement = value; }\n        }\n\n\n    }\n</code></pre>\n<h5 id=\"抽象表达式解释器\"><a href=\"#抽象表达式解释器\" class=\"headerlink\" title=\"抽象表达式解释器\"></a>抽象表达式解释器</h5><pre><code class=\"C#\">/// &lt;summary&gt;\n/// 抽象表达式解释器\n/// &lt;/summary&gt;\npublic abstract class Expression\n{\n    protected Dictionary&lt;string, int&gt; table = new Dictionary&lt;string, int&gt;(9);\n    public Expression()\n    {\n        table.Add(&quot;一&quot;, 1);\n        table.Add(&quot;二&quot;, 2);\n        table.Add(&quot;三&quot;, 3);\n        table.Add(&quot;四&quot;, 4);\n        table.Add(&quot;五&quot;, 5);\n        table.Add(&quot;六&quot;, 6);\n        table.Add(&quot;七&quot;, 7);\n        table.Add(&quot;八&quot;, 8);\n        table.Add(&quot;九&quot;, 9);\n    }\n\n    /// &lt;summary&gt;\n    /// 解释给定的中文表示数字上下文对象\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;\n    public virtual void Interpreter(Context context)\n    {\n        if (context.Statement.Length == 0)\n        {\n            return;\n        }\n        foreach (string key in table.Keys)\n        {\n            int value=table[key];\n            if (context.Statement.EndsWith(key+GetPostfix()))\n            {\n                context.Data += value * this.Multiplier();\n                context.Statement = context.Statement.Substring(0, context.Statement.Length - GetLength());\n            }\n            if (context.Statement.EndsWith(&quot;零&quot;))//应对如&quot;四百七十一万零六千四百零五十二&quot;中出现&#39;零&#39;的情况\n            {\n                context.Statement=context.Statement.Substring(0,context.Statement.Length-1);\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 获取如“六千四百五十二”中，获取千位的&#39;千&#39;字，百位的&#39;百&#39;字，十位的&#39;十&#39;字\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public abstract string GetPostfix();\n\n    /// &lt;summary&gt;\n    /// 陪增级数（个-1,十位-10,百位-100,千位-1000）\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public abstract int Multiplier();\n\n    /// &lt;summary&gt;\n    /// 获取符合文法的一组长度（如获取“四百”，“五十”的长度）\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public virtual int GetLength()\n    {\n        return this.GetPostfix().Length + 1;\n    }\n}\n</code></pre>\n<h5 id=\"个十百千万解释器实现\"><a href=\"#个十百千万解释器实现\" class=\"headerlink\" title=\"个十百千万解释器实现\"></a>个十百千万解释器实现</h5><p><strong>个位解释器</strong></p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// 个位解释器 解析个位\n/// &lt;/summary&gt;\npublic class GeExpression : Expression\n{\n\n    public override string GetPostfix()\n    {\n        return &quot;&quot;;\n    }\n\n    public override int Multiplier()\n    {\n        return 1;\n    }\n\n\n    public override int GetLength()\n    {\n        return  1;\n    }\n}\n `\n</code></pre>\n<p><strong>十位解释器</strong></p>\n<pre><code class=\"c#\">    /// &lt;summary&gt;\n    /// 十位解释器 解析个位+十位\n    /// &lt;/summary&gt;\n    public class ShiExpression : Expression\n    {\n\n        public override string GetPostfix()\n        {\n            return &quot;十&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 10;\n        }\n    }\n</code></pre>\n<p><strong>百位解释器</strong></p>\n<pre><code>    /// &lt;summary&gt;\n    /// 百位解释器 解析个位+十位+百位\n    /// &lt;/summary&gt;\n    public class BaiExpresssion : Expression\n    {\n\n        public override string GetPostfix()\n        {\n            return &quot;百&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 100;\n        }\n    }\n</code></pre><p><strong>千位解释器</strong></p>\n<pre><code>    /// &lt;summary&gt;\n    /// 千位解释器 解析个位+十位+百位+千位\n    /// &lt;/summary&gt;\n    public class QianExpression : Expression\n    {\n\n        public override string GetPostfix()\n        {\n            return &quot;千&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 1000;\n        }\n    }\n</code></pre><p><strong>万位解释器</strong></p>\n<pre><code>\n    /// &lt;summary&gt;\n    /// 万位解释器 解析个位+十位+百位+千位+万位\n    /// &lt;/summary&gt;\n    public class WanExpression : Expression\n    {\n        public override void Interpreter(Context context)\n        {\n            if (context.Statement.Length == 0)\n            {\n                return;\n            }\n            ArrayList tree = new ArrayList();\n            tree.Add(new GeExpression());\n            tree.Add(new ShiExpression());\n            tree.Add(new BaiExpresssion());\n            tree.Add(new QianExpression());\n\n            foreach (string key in table.Keys)\n            {\n                if (context.Statement.EndsWith(this.GetPostfix()))\n                {\n                    int temp = context.Data;\n                    context.Data = 0;\n                    context.Statement=context.Statement.Substring(0, context.Statement.Length - 1);\n                    foreach(Expression expression in tree)\n                    {\n                        expression.Interpreter(context);\n                    }\n                    context.Data = temp+this.Multiplier()*context.Data;\n                }\n            }\n\n\n        }\n\n        public override string GetPostfix()\n        {\n            return &quot;万&quot;;\n        }\n\n        public override int Multiplier()\n        {\n            return 10000;\n        }\n    }\n</code></pre><p>以上，我们可以很轻松通过Interpreter模式扩展亿位相对的YiExpression类</p>\n<p><strong>主程序调用</strong></p>\n<pre><code>public class App\n{\n    public static void Main()\n    {\n\n        string chinese=&quot;四百七十一万六千四百五十二&quot;;\n        Context context =new Context(chinese);\n        ArrayList tree = new ArrayList();//需按顺序添加个十百千万等解释表达式对象\n        tree.Add(new GeExpression());\n        tree.Add(new ShiExpression());\n        tree.Add(new BaiExpresssion());\n        tree.Add(new QianExpression());\n        tree.Add(new WanExpression());\n        foreach (Expression exp in tree)\n        {\n            exp.Interpreter(context);\n        }\n        Console.WriteLine(&quot;{0}={1}&quot;,chinese,context.Data);\n    }\n}\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353829.html\">这里</a></p>"},{"title":"面向对象设计模式之Prototype原型模式（创建型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 意图\n\n使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象\n\n### 可适用性\n\n1. 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时\n2. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\n\n<!--more-->\n\n### UML图解\n\n![原型模式UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/67444558.jpg)\n\n\n### 示例\n\n举一个例子，假设魂斗罗游戏，其中有各种各样的角色比如从抽象概念上有NormalActor、FlyActor、WaterActor,其中每一种角色又对应A、B、C三种具体人物等等;在游戏开始需要创建若干种人物出场进行决斗\n\n以下就是用原型模式实现此示例的代码：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Prototype\n{\n    /***\n     * 魂斗罗游戏\n     * ***/\n    public class GameSystem\n    {\n        NormalActor na; FlyActor fa; WaterActor wa;\n\n        public void Run(NormalActor na,FlyActor fa,WaterActor wa)\n        {\n            //以下就是使用原型实例创建对象的种类；Clone()方法也实现了以后的多态特征\n            NormalActor na1 = na.Clone();\n            NormalActor na2 = na.Clone();\n\n            FlyActor fa1 = fa.Clone();\n            FlyActor fa2 = fa.Clone();\n\n            WaterActor wa1 = wa.Clone();\n            WaterActor wa2 = wa.Clone();\n        }\n    }\n    //角色抽象类定义\n    public abstract class NormalActor\n    {\n        public abstract NormalActor Clone();\n    }\n    public abstract class FlyActor\n    {\n        public abstract FlyActor Clone();\n    }\n    public abstract class WaterActor\n    {\n        public abstract WaterActor Clone();\n    }\n\n    /***\n     * 注意：在C#中this.MemberwiseClone();属于浅拷贝；即当类对象执行浅拷贝时，类中引用类型\n     * 的成员仍然是被共享的，即拷贝的是其引用成员的地址；要实现其深度拷贝有两种方法：\n     * ①即new一个该类的实例，将当前对象的成员的值一一赋给新的对象返回此新的对象\n     * ②使用序列化和反序列，即将当前对象序列化到内存流中，然后再将其从内存流中反序列化得到的\n     * 一定是深度拷贝的新对象\n     * ***/\n    //角色类的具体实现\n    public class NormalActorA : NormalActor\n    {\n\n        public override NormalActor Clone()\n        {\n            return (NormalActor)this.MemberwiseClone();\n        }\n    }\n    public class FlyActorA : FlyActor\n    {\n        public override FlyActor Clone()\n        {\n            return (FlyActor)this.MemberwiseClone();\n        }\n    }\n    public class WaterActorrA : WaterActor\n    {\n\n        public override WaterActor Clone()\n        {\n            return (WaterActor)this.MemberwiseClone();\n        }\n    }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178775.html)\n","source":"_posts/Prototype.md","raw":"---\ntitle: 面向对象设计模式之Prototype原型模式（创建型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Prototype','原型模式']\n---\n\n### 意图\n\n使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象\n\n### 可适用性\n\n1. 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时\n2. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\n\n<!--more-->\n\n### UML图解\n\n![原型模式UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/67444558.jpg)\n\n\n### 示例\n\n举一个例子，假设魂斗罗游戏，其中有各种各样的角色比如从抽象概念上有NormalActor、FlyActor、WaterActor,其中每一种角色又对应A、B、C三种具体人物等等;在游戏开始需要创建若干种人物出场进行决斗\n\n以下就是用原型模式实现此示例的代码：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Prototype\n{\n    /***\n     * 魂斗罗游戏\n     * ***/\n    public class GameSystem\n    {\n        NormalActor na; FlyActor fa; WaterActor wa;\n\n        public void Run(NormalActor na,FlyActor fa,WaterActor wa)\n        {\n            //以下就是使用原型实例创建对象的种类；Clone()方法也实现了以后的多态特征\n            NormalActor na1 = na.Clone();\n            NormalActor na2 = na.Clone();\n\n            FlyActor fa1 = fa.Clone();\n            FlyActor fa2 = fa.Clone();\n\n            WaterActor wa1 = wa.Clone();\n            WaterActor wa2 = wa.Clone();\n        }\n    }\n    //角色抽象类定义\n    public abstract class NormalActor\n    {\n        public abstract NormalActor Clone();\n    }\n    public abstract class FlyActor\n    {\n        public abstract FlyActor Clone();\n    }\n    public abstract class WaterActor\n    {\n        public abstract WaterActor Clone();\n    }\n\n    /***\n     * 注意：在C#中this.MemberwiseClone();属于浅拷贝；即当类对象执行浅拷贝时，类中引用类型\n     * 的成员仍然是被共享的，即拷贝的是其引用成员的地址；要实现其深度拷贝有两种方法：\n     * ①即new一个该类的实例，将当前对象的成员的值一一赋给新的对象返回此新的对象\n     * ②使用序列化和反序列，即将当前对象序列化到内存流中，然后再将其从内存流中反序列化得到的\n     * 一定是深度拷贝的新对象\n     * ***/\n    //角色类的具体实现\n    public class NormalActorA : NormalActor\n    {\n\n        public override NormalActor Clone()\n        {\n            return (NormalActor)this.MemberwiseClone();\n        }\n    }\n    public class FlyActorA : FlyActor\n    {\n        public override FlyActor Clone()\n        {\n            return (FlyActor)this.MemberwiseClone();\n        }\n    }\n    public class WaterActorrA : WaterActor\n    {\n\n        public override WaterActor Clone()\n        {\n            return (WaterActor)this.MemberwiseClone();\n        }\n    }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178775.html)\n","slug":"Prototype","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsvc000pqk5cqdts7v11","content":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p>\n<h3 id=\"可适用性\"><a href=\"#可适用性\" class=\"headerlink\" title=\"可适用性\"></a>可适用性</h3><ol>\n<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时</li>\n<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/67444558.jpg\" alt=\"原型模式UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>举一个例子，假设魂斗罗游戏，其中有各种各样的角色比如从抽象概念上有NormalActor、FlyActor、WaterActor,其中每一种角色又对应A、B、C三种具体人物等等;在游戏开始需要创建若干种人物出场进行决斗</p>\n<p>以下就是用原型模式实现此示例的代码：</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Prototype\n{\n    /***\n     * 魂斗罗游戏\n     * ***/\n    public class GameSystem\n    {\n        NormalActor na; FlyActor fa; WaterActor wa;\n\n        public void Run(NormalActor na,FlyActor fa,WaterActor wa)\n        {\n            //以下就是使用原型实例创建对象的种类；Clone()方法也实现了以后的多态特征\n            NormalActor na1 = na.Clone();\n            NormalActor na2 = na.Clone();\n\n            FlyActor fa1 = fa.Clone();\n            FlyActor fa2 = fa.Clone();\n\n            WaterActor wa1 = wa.Clone();\n            WaterActor wa2 = wa.Clone();\n        }\n    }\n    //角色抽象类定义\n    public abstract class NormalActor\n    {\n        public abstract NormalActor Clone();\n    }\n    public abstract class FlyActor\n    {\n        public abstract FlyActor Clone();\n    }\n    public abstract class WaterActor\n    {\n        public abstract WaterActor Clone();\n    }\n\n    /***\n     * 注意：在C#中this.MemberwiseClone();属于浅拷贝；即当类对象执行浅拷贝时，类中引用类型\n     * 的成员仍然是被共享的，即拷贝的是其引用成员的地址；要实现其深度拷贝有两种方法：\n     * ①即new一个该类的实例，将当前对象的成员的值一一赋给新的对象返回此新的对象\n     * ②使用序列化和反序列，即将当前对象序列化到内存流中，然后再将其从内存流中反序列化得到的\n     * 一定是深度拷贝的新对象\n     * ***/\n    //角色类的具体实现\n    public class NormalActorA : NormalActor\n    {\n\n        public override NormalActor Clone()\n        {\n            return (NormalActor)this.MemberwiseClone();\n        }\n    }\n    public class FlyActorA : FlyActor\n    {\n        public override FlyActor Clone()\n        {\n            return (FlyActor)this.MemberwiseClone();\n        }\n    }\n    public class WaterActorrA : WaterActor\n    {\n\n        public override WaterActor Clone()\n        {\n            return (WaterActor)this.MemberwiseClone();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178775.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p>\n<h3 id=\"可适用性\"><a href=\"#可适用性\" class=\"headerlink\" title=\"可适用性\"></a>可适用性</h3><ol>\n<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时</li>\n<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>\n</ol>","more":"<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/67444558.jpg\" alt=\"原型模式UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>举一个例子，假设魂斗罗游戏，其中有各种各样的角色比如从抽象概念上有NormalActor、FlyActor、WaterActor,其中每一种角色又对应A、B、C三种具体人物等等;在游戏开始需要创建若干种人物出场进行决斗</p>\n<p>以下就是用原型模式实现此示例的代码：</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Prototype\n{\n    /***\n     * 魂斗罗游戏\n     * ***/\n    public class GameSystem\n    {\n        NormalActor na; FlyActor fa; WaterActor wa;\n\n        public void Run(NormalActor na,FlyActor fa,WaterActor wa)\n        {\n            //以下就是使用原型实例创建对象的种类；Clone()方法也实现了以后的多态特征\n            NormalActor na1 = na.Clone();\n            NormalActor na2 = na.Clone();\n\n            FlyActor fa1 = fa.Clone();\n            FlyActor fa2 = fa.Clone();\n\n            WaterActor wa1 = wa.Clone();\n            WaterActor wa2 = wa.Clone();\n        }\n    }\n    //角色抽象类定义\n    public abstract class NormalActor\n    {\n        public abstract NormalActor Clone();\n    }\n    public abstract class FlyActor\n    {\n        public abstract FlyActor Clone();\n    }\n    public abstract class WaterActor\n    {\n        public abstract WaterActor Clone();\n    }\n\n    /***\n     * 注意：在C#中this.MemberwiseClone();属于浅拷贝；即当类对象执行浅拷贝时，类中引用类型\n     * 的成员仍然是被共享的，即拷贝的是其引用成员的地址；要实现其深度拷贝有两种方法：\n     * ①即new一个该类的实例，将当前对象的成员的值一一赋给新的对象返回此新的对象\n     * ②使用序列化和反序列，即将当前对象序列化到内存流中，然后再将其从内存流中反序列化得到的\n     * 一定是深度拷贝的新对象\n     * ***/\n    //角色类的具体实现\n    public class NormalActorA : NormalActor\n    {\n\n        public override NormalActor Clone()\n        {\n            return (NormalActor)this.MemberwiseClone();\n        }\n    }\n    public class FlyActorA : FlyActor\n    {\n        public override FlyActor Clone()\n        {\n            return (FlyActor)this.MemberwiseClone();\n        }\n    }\n    public class WaterActorrA : WaterActor\n    {\n\n        public override WaterActor Clone()\n        {\n            return (WaterActor)this.MemberwiseClone();\n        }\n    }\n}\n</code></pre>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178775.html\">这里</a></p>"},{"title":"面向对象设计模式之Singleton单例模式（创建型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n在软件系统中，经常有这样的一些特殊的类，必须保证它们在系统中 只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率\n\n<!--more-->\n\n### 意图\n\n保证一个类仅有一个实例，并提供一个该实例的全局访问点\n\n### UML图解\n\n![Singleton UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/59535259.jpg)\n\n### 示例\n\n利用.Net实现单例模式，可以有几种不同的编码实现\n\n**第一种实现，非线程安全**\n\n```\nnamespace Singleton\n{\n  //只适用单线程下的单例模式,在多线程下无法保证其唯一实例\n  public class Singleton\n  {\n      private static Singleton instance;\n      private Singleton() { }\n      public static Singleton Instance\n      {\n          get\n          {\n              if (instance == null)\n              {\n                  instance = new Singleton();\n              }\n              return instance;\n          }\n      }\n  }\n}\n```\n\n**第二种：多线程单例模式的设计**\n```\n/// <summary>\n/// 多线程单例模式的设计\n/// </summary>\npublic class Singleton\n{\n    //volatile 会保证编译器不对代码指令的执行调整顺序，而保证其严格意义上的的按顺序执行\n    private static volatile Singleton instance=null;\n    private static object lockHepler = new object();//起辅助作用\n    private Singleton() { }\n    public static Singleton Instance\n    {\n        get\n        {\n            if (instance==null)\n            {\n                lock (lockHepler)\n                {\n                    if (instance == null)\n                    {\n                        instance = new Singleton();\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n}\n```\n**第三种：多线程单例模式的设计**\n\n```\n/// <summary>\n/// 多线程单例模式的设计\n/// </summary>\npublic class Singleton\n{\n    public static readonly Singleton Instance = new Singleton();//内联初始化\n    private Singleton() { }\n}\n```\n\n**第三种实现的变体**\n\n```\n/// <summary>\n/// 等同于第三种的实现,但这两者的弊端：就是不支持参数化传递的构造器\n/// </summary>\n//public class Singleton\n{\n    public static readonly Singleton Instance;\n\n    //.NET机制会保证只有一个线程执行此行代码，以加锁的方式防止又一个线程执行\n    //在第一次访问任意静态字段之前，都会执行静态构造器，以保证静态字段都已初始化\n    static Singleton() { Instance = new Singleton(); }\n    private Singleton() { }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178779.html)\n","source":"_posts/Singleton.md","raw":"---\ntitle: 面向对象设计模式之Singleton单例模式（创建型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Singleton','单例模式']\n---\n\n### 动机\n\n在软件系统中，经常有这样的一些特殊的类，必须保证它们在系统中 只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率\n\n<!--more-->\n\n### 意图\n\n保证一个类仅有一个实例，并提供一个该实例的全局访问点\n\n### UML图解\n\n![Singleton UML图解](http://oaefo3hoy.bkt.clouddn.com/16-8-6/59535259.jpg)\n\n### 示例\n\n利用.Net实现单例模式，可以有几种不同的编码实现\n\n**第一种实现，非线程安全**\n\n```\nnamespace Singleton\n{\n  //只适用单线程下的单例模式,在多线程下无法保证其唯一实例\n  public class Singleton\n  {\n      private static Singleton instance;\n      private Singleton() { }\n      public static Singleton Instance\n      {\n          get\n          {\n              if (instance == null)\n              {\n                  instance = new Singleton();\n              }\n              return instance;\n          }\n      }\n  }\n}\n```\n\n**第二种：多线程单例模式的设计**\n```\n/// <summary>\n/// 多线程单例模式的设计\n/// </summary>\npublic class Singleton\n{\n    //volatile 会保证编译器不对代码指令的执行调整顺序，而保证其严格意义上的的按顺序执行\n    private static volatile Singleton instance=null;\n    private static object lockHepler = new object();//起辅助作用\n    private Singleton() { }\n    public static Singleton Instance\n    {\n        get\n        {\n            if (instance==null)\n            {\n                lock (lockHepler)\n                {\n                    if (instance == null)\n                    {\n                        instance = new Singleton();\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n}\n```\n**第三种：多线程单例模式的设计**\n\n```\n/// <summary>\n/// 多线程单例模式的设计\n/// </summary>\npublic class Singleton\n{\n    public static readonly Singleton Instance = new Singleton();//内联初始化\n    private Singleton() { }\n}\n```\n\n**第三种实现的变体**\n\n```\n/// <summary>\n/// 等同于第三种的实现,但这两者的弊端：就是不支持参数化传递的构造器\n/// </summary>\n//public class Singleton\n{\n    public static readonly Singleton Instance;\n\n    //.NET机制会保证只有一个线程执行此行代码，以加锁的方式防止又一个线程执行\n    //在第一次访问任意静态字段之前，都会执行静态构造器，以保证静态字段都已初始化\n    static Singleton() { Instance = new Singleton(); }\n    private Singleton() { }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178779.html)\n","slug":"Singleton","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsve000rqk5cyhdo2j23","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，经常有这样的一些特殊的类，必须保证它们在系统中 只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/59535259.jpg\" alt=\"Singleton UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>利用.Net实现单例模式，可以有几种不同的编码实现</p>\n<p><strong>第一种实现，非线程安全</strong></p>\n<pre><code>namespace Singleton\n{\n  //只适用单线程下的单例模式,在多线程下无法保证其唯一实例\n  public class Singleton\n  {\n      private static Singleton instance;\n      private Singleton() { }\n      public static Singleton Instance\n      {\n          get\n          {\n              if (instance == null)\n              {\n                  instance = new Singleton();\n              }\n              return instance;\n          }\n      }\n  }\n}\n</code></pre><p><strong>第二种：多线程单例模式的设计</strong></p>\n<pre><code>/// &lt;summary&gt;\n/// 多线程单例模式的设计\n/// &lt;/summary&gt;\npublic class Singleton\n{\n    //volatile 会保证编译器不对代码指令的执行调整顺序，而保证其严格意义上的的按顺序执行\n    private static volatile Singleton instance=null;\n    private static object lockHepler = new object();//起辅助作用\n    private Singleton() { }\n    public static Singleton Instance\n    {\n        get\n        {\n            if (instance==null)\n            {\n                lock (lockHepler)\n                {\n                    if (instance == null)\n                    {\n                        instance = new Singleton();\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n}\n</code></pre><p><strong>第三种：多线程单例模式的设计</strong></p>\n<pre><code>/// &lt;summary&gt;\n/// 多线程单例模式的设计\n/// &lt;/summary&gt;\npublic class Singleton\n{\n    public static readonly Singleton Instance = new Singleton();//内联初始化\n    private Singleton() { }\n}\n</code></pre><p><strong>第三种实现的变体</strong></p>\n<pre><code>/// &lt;summary&gt;\n/// 等同于第三种的实现,但这两者的弊端：就是不支持参数化传递的构造器\n/// &lt;/summary&gt;\n//public class Singleton\n{\n    public static readonly Singleton Instance;\n\n    //.NET机制会保证只有一个线程执行此行代码，以加锁的方式防止又一个线程执行\n    //在第一次访问任意静态字段之前，都会执行静态构造器，以保证静态字段都已初始化\n    static Singleton() { Instance = new Singleton(); }\n    private Singleton() { }\n}\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178779.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件系统中，经常有这样的一些特殊的类，必须保证它们在系统中 只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-6/59535259.jpg\" alt=\"Singleton UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>利用.Net实现单例模式，可以有几种不同的编码实现</p>\n<p><strong>第一种实现，非线程安全</strong></p>\n<pre><code>namespace Singleton\n{\n  //只适用单线程下的单例模式,在多线程下无法保证其唯一实例\n  public class Singleton\n  {\n      private static Singleton instance;\n      private Singleton() { }\n      public static Singleton Instance\n      {\n          get\n          {\n              if (instance == null)\n              {\n                  instance = new Singleton();\n              }\n              return instance;\n          }\n      }\n  }\n}\n</code></pre><p><strong>第二种：多线程单例模式的设计</strong></p>\n<pre><code>/// &lt;summary&gt;\n/// 多线程单例模式的设计\n/// &lt;/summary&gt;\npublic class Singleton\n{\n    //volatile 会保证编译器不对代码指令的执行调整顺序，而保证其严格意义上的的按顺序执行\n    private static volatile Singleton instance=null;\n    private static object lockHepler = new object();//起辅助作用\n    private Singleton() { }\n    public static Singleton Instance\n    {\n        get\n        {\n            if (instance==null)\n            {\n                lock (lockHepler)\n                {\n                    if (instance == null)\n                    {\n                        instance = new Singleton();\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n}\n</code></pre><p><strong>第三种：多线程单例模式的设计</strong></p>\n<pre><code>/// &lt;summary&gt;\n/// 多线程单例模式的设计\n/// &lt;/summary&gt;\npublic class Singleton\n{\n    public static readonly Singleton Instance = new Singleton();//内联初始化\n    private Singleton() { }\n}\n</code></pre><p><strong>第三种实现的变体</strong></p>\n<pre><code>/// &lt;summary&gt;\n/// 等同于第三种的实现,但这两者的弊端：就是不支持参数化传递的构造器\n/// &lt;/summary&gt;\n//public class Singleton\n{\n    public static readonly Singleton Instance;\n\n    //.NET机制会保证只有一个线程执行此行代码，以加锁的方式防止又一个线程执行\n    //在第一次访问任意静态字段之前，都会执行静态构造器，以保证静态字段都已初始化\n    static Singleton() { Instance = new Singleton(); }\n    private Singleton() { }\n}\n</code></pre><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178779.html\">这里</a></p>"},{"title":"面向对象设计模式之TemplateMethod模板方法（行为型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 动机\n\n在软件构建过程中，对于某一项任务，他常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现；如何在确定稳定操作结构的前提下，来灵活应对各种子步骤的变化或者晚期实现需求？\n\n<!--more-->\n\n### 意图\n定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod是的子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n\n### 适用性\n\n1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。\n\n2. 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[ O J 9 3 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。\n\n3. 控制子类扩展。模板方法只在特定点调用“hook”,我们俗称设定一个钩子，后面去操作实现，这样就只允许在这些点进行扩展。\n\n### UML图解\n\n![TemplateMethod UML图解](http://oaefo3hoy.bkt.clouddn.com/TemplateMethod.jpg)\n\n\n### 示例\n\n#### 示例场景\n\n假设要开发一款汽车测试程序，而对于测试什么类型和什么牌子的汽车，都是是未知的。应用模板方法来设计，我们就可以先把汽车测试程序测试涉及的方法列举出来，对于某些测试方法具体实现留给后来汽车厂商去实现\n\n#### 示例代码\n\n**汽车测试软件框架部分**\n\n```C#\n//汽车测试软件框架的开发组——先开发\nnamespace TemplateMethod\n{\n    public abstract class Vehicle\n    {\n        protected abstract void Startup();\n        protected abstract void Run();\n        protected abstract void Turn();\n        protected abstract void Stop();\n\n        public void Test()\n        {\n            Startup();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Run();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Turn();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Stop();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n        }\n    }\n\n    public class VehicleTestFramework\n    {\n        public static void DoTest(Vehicle vehicle)\n        {\n            //...\n            vehicle.Test();\n            //...\n        }\n    }\n}\n```\n\n**具体汽车厂商后来实现部分**\n\n```C#\n//具体汽车厂商汽车测试程序程序开发组——晚开发\nnamespace TemplateMethod\n{\n    public class DaZhongCar:Vehicle\n    {\n        protected override void Startup()\n        {\n            //...\n        }\n\n        protected override void Run()\n        {\n            //...\n        }\n\n        protected override void Turn()\n        {\n            //...\n        }\n\n        protected override void Stop()\n        {\n            //...\n        }\n    }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353863.html)\n","source":"_posts/TemplateMethod.md","raw":"---\ntitle: 面向对象设计模式之TemplateMethod模板方法（行为型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['模板方法','TemplateMethod']\n---\n\n### 动机\n\n在软件构建过程中，对于某一项任务，他常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现；如何在确定稳定操作结构的前提下，来灵活应对各种子步骤的变化或者晚期实现需求？\n\n<!--more-->\n\n### 意图\n定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod是的子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n\n### 适用性\n\n1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。\n\n2. 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[ O J 9 3 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。\n\n3. 控制子类扩展。模板方法只在特定点调用“hook”,我们俗称设定一个钩子，后面去操作实现，这样就只允许在这些点进行扩展。\n\n### UML图解\n\n![TemplateMethod UML图解](http://oaefo3hoy.bkt.clouddn.com/TemplateMethod.jpg)\n\n\n### 示例\n\n#### 示例场景\n\n假设要开发一款汽车测试程序，而对于测试什么类型和什么牌子的汽车，都是是未知的。应用模板方法来设计，我们就可以先把汽车测试程序测试涉及的方法列举出来，对于某些测试方法具体实现留给后来汽车厂商去实现\n\n#### 示例代码\n\n**汽车测试软件框架部分**\n\n```C#\n//汽车测试软件框架的开发组——先开发\nnamespace TemplateMethod\n{\n    public abstract class Vehicle\n    {\n        protected abstract void Startup();\n        protected abstract void Run();\n        protected abstract void Turn();\n        protected abstract void Stop();\n\n        public void Test()\n        {\n            Startup();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Run();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Turn();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Stop();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n        }\n    }\n\n    public class VehicleTestFramework\n    {\n        public static void DoTest(Vehicle vehicle)\n        {\n            //...\n            vehicle.Test();\n            //...\n        }\n    }\n}\n```\n\n**具体汽车厂商后来实现部分**\n\n```C#\n//具体汽车厂商汽车测试程序程序开发组——晚开发\nnamespace TemplateMethod\n{\n    public class DaZhongCar:Vehicle\n    {\n        protected override void Startup()\n        {\n            //...\n        }\n\n        protected override void Run()\n        {\n            //...\n        }\n\n        protected override void Turn()\n        {\n            //...\n        }\n\n        protected override void Stop()\n        {\n            //...\n        }\n    }\n}\n```\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3353863.html)\n","slug":"TemplateMethod","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsvh000uqk5cmpkrsemv","content":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件构建过程中，对于某一项任务，他常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现；如何在确定稳定操作结构的前提下，来灵活应对各种子步骤的变化或者晚期实现需求？</p>\n<a id=\"more\"></a>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod是的子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li><p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</p>\n</li>\n<li><p>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[ O J 9 3 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</p>\n</li>\n<li><p>控制子类扩展。模板方法只在特定点调用“hook”,我们俗称设定一个钩子，后面去操作实现，这样就只允许在这些点进行扩展。</p>\n</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/TemplateMethod.jpg\" alt=\"TemplateMethod UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>假设要开发一款汽车测试程序，而对于测试什么类型和什么牌子的汽车，都是是未知的。应用模板方法来设计，我们就可以先把汽车测试程序测试涉及的方法列举出来，对于某些测试方法具体实现留给后来汽车厂商去实现</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><p><strong>汽车测试软件框架部分</strong></p>\n<pre><code class=\"C#\">//汽车测试软件框架的开发组——先开发\nnamespace TemplateMethod\n{\n    public abstract class Vehicle\n    {\n        protected abstract void Startup();\n        protected abstract void Run();\n        protected abstract void Turn();\n        protected abstract void Stop();\n\n        public void Test()\n        {\n            Startup();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Run();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Turn();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Stop();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n        }\n    }\n\n    public class VehicleTestFramework\n    {\n        public static void DoTest(Vehicle vehicle)\n        {\n            //...\n            vehicle.Test();\n            //...\n        }\n    }\n}\n</code></pre>\n<p><strong>具体汽车厂商后来实现部分</strong></p>\n<pre><code class=\"C#\">//具体汽车厂商汽车测试程序程序开发组——晚开发\nnamespace TemplateMethod\n{\n    public class DaZhongCar:Vehicle\n    {\n        protected override void Startup()\n        {\n            //...\n        }\n\n        protected override void Run()\n        {\n            //...\n        }\n\n        protected override void Turn()\n        {\n            //...\n        }\n\n        protected override void Stop()\n        {\n            //...\n        }\n    }\n}\n</code></pre>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353863.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>在软件构建过程中，对于某一项任务，他常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现；如何在确定稳定操作结构的前提下，来灵活应对各种子步骤的变化或者晚期实现需求？</p>","more":"<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod是的子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n<h3 id=\"适用性\"><a href=\"#适用性\" class=\"headerlink\" title=\"适用性\"></a>适用性</h3><ol>\n<li><p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</p>\n</li>\n<li><p>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[ O J 9 3 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</p>\n</li>\n<li><p>控制子类扩展。模板方法只在特定点调用“hook”,我们俗称设定一个钩子，后面去操作实现，这样就只允许在这些点进行扩展。</p>\n</li>\n</ol>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/TemplateMethod.jpg\" alt=\"TemplateMethod UML图解\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h4><p>假设要开发一款汽车测试程序，而对于测试什么类型和什么牌子的汽车，都是是未知的。应用模板方法来设计，我们就可以先把汽车测试程序测试涉及的方法列举出来，对于某些测试方法具体实现留给后来汽车厂商去实现</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><p><strong>汽车测试软件框架部分</strong></p>\n<pre><code class=\"C#\">//汽车测试软件框架的开发组——先开发\nnamespace TemplateMethod\n{\n    public abstract class Vehicle\n    {\n        protected abstract void Startup();\n        protected abstract void Run();\n        protected abstract void Turn();\n        protected abstract void Stop();\n\n        public void Test()\n        {\n            Startup();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Run();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Turn();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n\n            Stop();//晚绑定，留给应用程序开发人员实现，扩展点\n            //测试数据记录...\n        }\n    }\n\n    public class VehicleTestFramework\n    {\n        public static void DoTest(Vehicle vehicle)\n        {\n            //...\n            vehicle.Test();\n            //...\n        }\n    }\n}\n</code></pre>\n<p><strong>具体汽车厂商后来实现部分</strong></p>\n<pre><code class=\"C#\">//具体汽车厂商汽车测试程序程序开发组——晚开发\nnamespace TemplateMethod\n{\n    public class DaZhongCar:Vehicle\n    {\n        protected override void Startup()\n        {\n            //...\n        }\n\n        protected override void Run()\n        {\n            //...\n        }\n\n        protected override void Turn()\n        {\n            //...\n        }\n\n        protected override void Stop()\n        {\n            //...\n        }\n    }\n}\n</code></pre>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3353863.html\">这里</a></p>"},{"title":"面向对象设计模式之Bridge桥接模式（结构型）","date":"2013-10-06T08:36:00.000Z","_content":"\n### 问题分析\n\n首先我们来看下下面这个问题\n> 假如我们需要开发一个同时支持PC和手机的坦克游戏，游戏在PC和手机上功能都一样，都有同样的类型，面临同样的功能需求变化，比如坦克可能有多种不同的型号：T50，T75，T90..对于其中的坦克设计，我们可能很容易设计出来一个Tank的抽象类，然后各种不同型号的Tank继承自该类，但是PC和手机上的图形绘制、声效、操作等实现完全不同...因此对于各种型号的坦克，都 要提供各种不同平台上的坦克实现；而这样的设计带来了很多问题：有很多重复代码，类的结构过于复杂，难以维护，最致命的是引入任何新的平台，比如TV上的Tank游戏，都会让整个类层次级结构复杂化\n\n<!--more-->\n### 动机\n\n思考上述问题的症结，事实上由于Tank类型的固有逻辑，使得Tank类型具有了两个变化的维度——一个变化的维度为“平台的变化”，一个变化的维度为“型号的变化”；如何应对这种“多维度的变化”？如何利用面向对象技术使得Tank类型可以轻松地沿着“平台”和“型号”两个方向变化，而不引入额外的复杂度呢？\n\n### 意图\n\n使用桥接模式我们主要是想将抽象部分和实现部分分离（将一个事物中多个维度的变化分离），使它们可以独立的变化 即将不同纬度的变化抽象出来，并子类化它们，用对象组合的方式实现应对其变化\n\n### UML图解\n\n![桥接模式UML图](http://oaefo3hoy.bkt.clouddn.com/16-8-3/12927396.jpg)\n\n### 示例\n\n按照UML图对桥接模式的描述，我们先看下在未使用桥接模式的情况下，我们这个代码是怎样的\n\n#### 未使用桥接模式前的实现代码\n\n定义抽象坦克类和不同型号的坦克子类\n```C#\npublic abstract  class Tank\n{\n    public abstract void Run();\n    public abstract void Shot();\n    public abstract void Stop();\n}\n\npublic class T50 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\npublic class T75 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n\npublic class T90 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n```\n假设我们的坦克游戏有针对PC,Mobile,TV这三种不同平台版本，不同平台每种型号的坦克具体实现是不一样的，为此我们需要继续扩展子类定义每个平台不同型号坦克子类及实现\n\n**PC平台对不同型号坦克子类实现**\n\n```C#\npublic class PCT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT75: T75\n{\n    public override void Run()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n       //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\n```\n\n**Mobile平台对不同型号坦克子类实现**\n\n```C#\npublic class MobileT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT75 : T75\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\n```\n\n**TV平台对不同型号坦克子类实现**\n\n```C#\npublic class TVT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT75 : T75\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT90 : T90\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\n```\n通过上述代码，我们可以看出，如果将来我们新增任意坦克或平台都要靠增加子类来解决变化，这种情况就会导致子类的繁多，不能真正的应对平台和坦克型号两个纬度增加的变化，这时桥接模式就很好的派上用场\n\n#### 桥接模式登场\n\n\n首先我们针对平台和坦克型号这两个纬度进行抽象\n\n```C#\nnamespace Bridge\n{\n  /// <summary>\n  /// 将不同平台坦克实现抽象出来（应对平台变化）\n  /// </summary>\n  public abstract class TankPlatformImplementation\n  {\n      public abstract void MoveTo();\n      public abstract void Draw();\n      public abstract void Stop();\n  }\n  /// <summary>\n  /// 坦克抽象类(应对坦克型号的变化)\n  /// </summary>\n  public abstract class Tank\n  {\n      TankPlatformImplementation tanklmp;//对象组合\n      public Tank( TankPlatformImplementation tanklmp)\n      {\n          this.tanklmp = tanklmp;\n      }\n      public abstract void Run();\n      public abstract void Shot();\n      public abstract void Stop();\n  }\n}\n```\n\n不同平台下的坦克实现\n\n```C#\n/// <summary>\n/// PC平台的Tank\n/// </summary>\npublic class PCTankImplementation:TankPlatformImplementation\n{\n     public override void  MoveTo()\n     {\n        //PC上的实现代码\n     }\n     public override void  Draw()\n     {\n       //PC上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        //PC上的实现代码\n     }\n }\n/// <summary>\n/// Mobile平台的Tank\n/// </summary>\npublic class MobileTankImplementation:TankPlatformImplementation\n{\n\n     public override void  MoveTo()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Draw()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        // Mobile上的实现代码\n     }\n}\n```\n\n不同型号坦克的子类实现\n\n```C#\npublic class T50 : Tank\n{\n  public T50(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n\npublic class T75 : Tank\n{\n  public T75(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n```\n\n以上代码实现完了之后，我们就可以很轻松的针对不同平台进行开发\n\n```C#\npublic class App\n{\n    public static void Main()\n    {\n       //手机平台游戏\n        TankPlatformImplementation mobileTank=new MobileTankImplementation();\n        Tank tank=new T50(mobileTank);\n        //tank.Shot();\n    }\n}\n```\n\n### 可适用性\n\n1. 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。\n2. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。\n3. 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。\n4. （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。\n5. 有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”(nested generalizations)。\n6. 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String类[Cop92]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178773.html)\n","source":"_posts/bridge.md","raw":"---\ntitle: 面向对象设计模式之Bridge桥接模式（结构型）\ndate: 2013-10-06 16:36\ncategories: 设计模式\ntags: ['Bridge','桥接模式']\n---\n\n### 问题分析\n\n首先我们来看下下面这个问题\n> 假如我们需要开发一个同时支持PC和手机的坦克游戏，游戏在PC和手机上功能都一样，都有同样的类型，面临同样的功能需求变化，比如坦克可能有多种不同的型号：T50，T75，T90..对于其中的坦克设计，我们可能很容易设计出来一个Tank的抽象类，然后各种不同型号的Tank继承自该类，但是PC和手机上的图形绘制、声效、操作等实现完全不同...因此对于各种型号的坦克，都 要提供各种不同平台上的坦克实现；而这样的设计带来了很多问题：有很多重复代码，类的结构过于复杂，难以维护，最致命的是引入任何新的平台，比如TV上的Tank游戏，都会让整个类层次级结构复杂化\n\n<!--more-->\n### 动机\n\n思考上述问题的症结，事实上由于Tank类型的固有逻辑，使得Tank类型具有了两个变化的维度——一个变化的维度为“平台的变化”，一个变化的维度为“型号的变化”；如何应对这种“多维度的变化”？如何利用面向对象技术使得Tank类型可以轻松地沿着“平台”和“型号”两个方向变化，而不引入额外的复杂度呢？\n\n### 意图\n\n使用桥接模式我们主要是想将抽象部分和实现部分分离（将一个事物中多个维度的变化分离），使它们可以独立的变化 即将不同纬度的变化抽象出来，并子类化它们，用对象组合的方式实现应对其变化\n\n### UML图解\n\n![桥接模式UML图](http://oaefo3hoy.bkt.clouddn.com/16-8-3/12927396.jpg)\n\n### 示例\n\n按照UML图对桥接模式的描述，我们先看下在未使用桥接模式的情况下，我们这个代码是怎样的\n\n#### 未使用桥接模式前的实现代码\n\n定义抽象坦克类和不同型号的坦克子类\n```C#\npublic abstract  class Tank\n{\n    public abstract void Run();\n    public abstract void Shot();\n    public abstract void Stop();\n}\n\npublic class T50 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\npublic class T75 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n\npublic class T90 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n```\n假设我们的坦克游戏有针对PC,Mobile,TV这三种不同平台版本，不同平台每种型号的坦克具体实现是不一样的，为此我们需要继续扩展子类定义每个平台不同型号坦克子类及实现\n\n**PC平台对不同型号坦克子类实现**\n\n```C#\npublic class PCT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT75: T75\n{\n    public override void Run()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n       //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\n```\n\n**Mobile平台对不同型号坦克子类实现**\n\n```C#\npublic class MobileT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT75 : T75\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\n```\n\n**TV平台对不同型号坦克子类实现**\n\n```C#\npublic class TVT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT75 : T75\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT90 : T90\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\n```\n通过上述代码，我们可以看出，如果将来我们新增任意坦克或平台都要靠增加子类来解决变化，这种情况就会导致子类的繁多，不能真正的应对平台和坦克型号两个纬度增加的变化，这时桥接模式就很好的派上用场\n\n#### 桥接模式登场\n\n\n首先我们针对平台和坦克型号这两个纬度进行抽象\n\n```C#\nnamespace Bridge\n{\n  /// <summary>\n  /// 将不同平台坦克实现抽象出来（应对平台变化）\n  /// </summary>\n  public abstract class TankPlatformImplementation\n  {\n      public abstract void MoveTo();\n      public abstract void Draw();\n      public abstract void Stop();\n  }\n  /// <summary>\n  /// 坦克抽象类(应对坦克型号的变化)\n  /// </summary>\n  public abstract class Tank\n  {\n      TankPlatformImplementation tanklmp;//对象组合\n      public Tank( TankPlatformImplementation tanklmp)\n      {\n          this.tanklmp = tanklmp;\n      }\n      public abstract void Run();\n      public abstract void Shot();\n      public abstract void Stop();\n  }\n}\n```\n\n不同平台下的坦克实现\n\n```C#\n/// <summary>\n/// PC平台的Tank\n/// </summary>\npublic class PCTankImplementation:TankPlatformImplementation\n{\n     public override void  MoveTo()\n     {\n        //PC上的实现代码\n     }\n     public override void  Draw()\n     {\n       //PC上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        //PC上的实现代码\n     }\n }\n/// <summary>\n/// Mobile平台的Tank\n/// </summary>\npublic class MobileTankImplementation:TankPlatformImplementation\n{\n\n     public override void  MoveTo()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Draw()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        // Mobile上的实现代码\n     }\n}\n```\n\n不同型号坦克的子类实现\n\n```C#\npublic class T50 : Tank\n{\n  public T50(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n\npublic class T75 : Tank\n{\n  public T75(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n```\n\n以上代码实现完了之后，我们就可以很轻松的针对不同平台进行开发\n\n```C#\npublic class App\n{\n    public static void Main()\n    {\n       //手机平台游戏\n        TankPlatformImplementation mobileTank=new MobileTankImplementation();\n        Tank tank=new T50(mobileTank);\n        //tank.Shot();\n    }\n}\n```\n\n### 可适用性\n\n1. 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。\n2. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。\n3. 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。\n4. （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。\n5. 有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”(nested generalizations)。\n6. 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String类[Cop92]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。\n\n### 说明\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/archive/2012/02/24/3178773.html)\n","slug":"bridge","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsvs000xqk5c8tspar24","content":"<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>首先我们来看下下面这个问题</p>\n<blockquote>\n<p>假如我们需要开发一个同时支持PC和手机的坦克游戏，游戏在PC和手机上功能都一样，都有同样的类型，面临同样的功能需求变化，比如坦克可能有多种不同的型号：T50，T75，T90..对于其中的坦克设计，我们可能很容易设计出来一个Tank的抽象类，然后各种不同型号的Tank继承自该类，但是PC和手机上的图形绘制、声效、操作等实现完全不同…因此对于各种型号的坦克，都 要提供各种不同平台上的坦克实现；而这样的设计带来了很多问题：有很多重复代码，类的结构过于复杂，难以维护，最致命的是引入任何新的平台，比如TV上的Tank游戏，都会让整个类层次级结构复杂化</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>思考上述问题的症结，事实上由于Tank类型的固有逻辑，使得Tank类型具有了两个变化的维度——一个变化的维度为“平台的变化”，一个变化的维度为“型号的变化”；如何应对这种“多维度的变化”？如何利用面向对象技术使得Tank类型可以轻松地沿着“平台”和“型号”两个方向变化，而不引入额外的复杂度呢？</p>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>使用桥接模式我们主要是想将抽象部分和实现部分分离（将一个事物中多个维度的变化分离），使它们可以独立的变化 即将不同纬度的变化抽象出来，并子类化它们，用对象组合的方式实现应对其变化</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-3/12927396.jpg\" alt=\"桥接模式UML图\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>按照UML图对桥接模式的描述，我们先看下在未使用桥接模式的情况下，我们这个代码是怎样的</p>\n<h4 id=\"未使用桥接模式前的实现代码\"><a href=\"#未使用桥接模式前的实现代码\" class=\"headerlink\" title=\"未使用桥接模式前的实现代码\"></a>未使用桥接模式前的实现代码</h4><p>定义抽象坦克类和不同型号的坦克子类</p>\n<pre><code class=\"C#\">public abstract  class Tank\n{\n    public abstract void Run();\n    public abstract void Shot();\n    public abstract void Stop();\n}\n\npublic class T50 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\npublic class T75 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n\npublic class T90 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n</code></pre>\n<p>假设我们的坦克游戏有针对PC,Mobile,TV这三种不同平台版本，不同平台每种型号的坦克具体实现是不一样的，为此我们需要继续扩展子类定义每个平台不同型号坦克子类及实现</p>\n<p><strong>PC平台对不同型号坦克子类实现</strong></p>\n<pre><code class=\"C#\">public class PCT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT75: T75\n{\n    public override void Run()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n       //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\n</code></pre>\n<p><strong>Mobile平台对不同型号坦克子类实现</strong></p>\n<pre><code class=\"C#\">public class MobileT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT75 : T75\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\n</code></pre>\n<p><strong>TV平台对不同型号坦克子类实现</strong></p>\n<pre><code class=\"C#\">public class TVT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT75 : T75\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT90 : T90\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\n</code></pre>\n<p>通过上述代码，我们可以看出，如果将来我们新增任意坦克或平台都要靠增加子类来解决变化，这种情况就会导致子类的繁多，不能真正的应对平台和坦克型号两个纬度增加的变化，这时桥接模式就很好的派上用场</p>\n<h4 id=\"桥接模式登场\"><a href=\"#桥接模式登场\" class=\"headerlink\" title=\"桥接模式登场\"></a>桥接模式登场</h4><p>首先我们针对平台和坦克型号这两个纬度进行抽象</p>\n<pre><code class=\"C#\">namespace Bridge\n{\n  /// &lt;summary&gt;\n  /// 将不同平台坦克实现抽象出来（应对平台变化）\n  /// &lt;/summary&gt;\n  public abstract class TankPlatformImplementation\n  {\n      public abstract void MoveTo();\n      public abstract void Draw();\n      public abstract void Stop();\n  }\n  /// &lt;summary&gt;\n  /// 坦克抽象类(应对坦克型号的变化)\n  /// &lt;/summary&gt;\n  public abstract class Tank\n  {\n      TankPlatformImplementation tanklmp;//对象组合\n      public Tank( TankPlatformImplementation tanklmp)\n      {\n          this.tanklmp = tanklmp;\n      }\n      public abstract void Run();\n      public abstract void Shot();\n      public abstract void Stop();\n  }\n}\n</code></pre>\n<p>不同平台下的坦克实现</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// PC平台的Tank\n/// &lt;/summary&gt;\npublic class PCTankImplementation:TankPlatformImplementation\n{\n     public override void  MoveTo()\n     {\n        //PC上的实现代码\n     }\n     public override void  Draw()\n     {\n       //PC上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        //PC上的实现代码\n     }\n }\n/// &lt;summary&gt;\n/// Mobile平台的Tank\n/// &lt;/summary&gt;\npublic class MobileTankImplementation:TankPlatformImplementation\n{\n\n     public override void  MoveTo()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Draw()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        // Mobile上的实现代码\n     }\n}\n</code></pre>\n<p>不同型号坦克的子类实现</p>\n<pre><code class=\"C#\">public class T50 : Tank\n{\n  public T50(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n\npublic class T75 : Tank\n{\n  public T75(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n</code></pre>\n<p>以上代码实现完了之后，我们就可以很轻松的针对不同平台进行开发</p>\n<pre><code class=\"C#\">public class App\n{\n    public static void Main()\n    {\n       //手机平台游戏\n        TankPlatformImplementation mobileTank=new MobileTankImplementation();\n        Tank tank=new T50(mobileTank);\n        //tank.Shot();\n    }\n}\n</code></pre>\n<h3 id=\"可适用性\"><a href=\"#可适用性\" class=\"headerlink\" title=\"可适用性\"></a>可适用性</h3><ol>\n<li>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</li>\n<li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li>\n<li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li>\n<li>（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。</li>\n<li>有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”(nested generalizations)。</li>\n<li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String类[Cop92]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178773.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>首先我们来看下下面这个问题</p>\n<blockquote>\n<p>假如我们需要开发一个同时支持PC和手机的坦克游戏，游戏在PC和手机上功能都一样，都有同样的类型，面临同样的功能需求变化，比如坦克可能有多种不同的型号：T50，T75，T90..对于其中的坦克设计，我们可能很容易设计出来一个Tank的抽象类，然后各种不同型号的Tank继承自该类，但是PC和手机上的图形绘制、声效、操作等实现完全不同…因此对于各种型号的坦克，都 要提供各种不同平台上的坦克实现；而这样的设计带来了很多问题：有很多重复代码，类的结构过于复杂，难以维护，最致命的是引入任何新的平台，比如TV上的Tank游戏，都会让整个类层次级结构复杂化</p>\n</blockquote>","more":"<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>思考上述问题的症结，事实上由于Tank类型的固有逻辑，使得Tank类型具有了两个变化的维度——一个变化的维度为“平台的变化”，一个变化的维度为“型号的变化”；如何应对这种“多维度的变化”？如何利用面向对象技术使得Tank类型可以轻松地沿着“平台”和“型号”两个方向变化，而不引入额外的复杂度呢？</p>\n<h3 id=\"意图\"><a href=\"#意图\" class=\"headerlink\" title=\"意图\"></a>意图</h3><p>使用桥接模式我们主要是想将抽象部分和实现部分分离（将一个事物中多个维度的变化分离），使它们可以独立的变化 即将不同纬度的变化抽象出来，并子类化它们，用对象组合的方式实现应对其变化</p>\n<h3 id=\"UML图解\"><a href=\"#UML图解\" class=\"headerlink\" title=\"UML图解\"></a>UML图解</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-3/12927396.jpg\" alt=\"桥接模式UML图\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>按照UML图对桥接模式的描述，我们先看下在未使用桥接模式的情况下，我们这个代码是怎样的</p>\n<h4 id=\"未使用桥接模式前的实现代码\"><a href=\"#未使用桥接模式前的实现代码\" class=\"headerlink\" title=\"未使用桥接模式前的实现代码\"></a>未使用桥接模式前的实现代码</h4><p>定义抽象坦克类和不同型号的坦克子类</p>\n<pre><code class=\"C#\">public abstract  class Tank\n{\n    public abstract void Run();\n    public abstract void Shot();\n    public abstract void Stop();\n}\n\npublic class T50 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\npublic class T75 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n\npublic class T90 : Tank\n{\n    public override void Run()\n    {\n        //....\n    }\n\n    public override void Shot()\n    {\n        //....\n    }\n\n    public override void Stop()\n    {\n        //....\n    }\n}\n</code></pre>\n<p>假设我们的坦克游戏有针对PC,Mobile,TV这三种不同平台版本，不同平台每种型号的坦克具体实现是不一样的，为此我们需要继续扩展子类定义每个平台不同型号坦克子类及实现</p>\n<p><strong>PC平台对不同型号坦克子类实现</strong></p>\n<pre><code class=\"C#\">public class PCT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT75: T75\n{\n    public override void Run()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\npublic class PCT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:pc平台具体实现\n    }\n\n    public override void Shot()\n    {\n       //TODO:pc平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:pc平台具体实现\n    }\n}\n</code></pre>\n<p><strong>Mobile平台对不同型号坦克子类实现</strong></p>\n<pre><code class=\"C#\">public class MobileT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT75 : T75\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\npublic class MobileT90 : T90\n{\n    public override void Run()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Shot()\n    {\n        //TODO:Mobile平台具体实现\n    }\n\n    public override void Stop()\n    {\n        //TODO:Mobile平台具体实现\n    }\n}\n</code></pre>\n<p><strong>TV平台对不同型号坦克子类实现</strong></p>\n<pre><code class=\"C#\">public class TVT50 : T50\n{\n    public override void Run()\n    {\n        //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT75 : T75\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\npublic class TVT90 : T90\n{\n    public override void Run()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Shot()\n    {\n      //TODO:TV平台具体实现\n    }\n\n    public override void Stop()\n    {\n      //TODO:TV平台具体实现\n    }\n}\n</code></pre>\n<p>通过上述代码，我们可以看出，如果将来我们新增任意坦克或平台都要靠增加子类来解决变化，这种情况就会导致子类的繁多，不能真正的应对平台和坦克型号两个纬度增加的变化，这时桥接模式就很好的派上用场</p>\n<h4 id=\"桥接模式登场\"><a href=\"#桥接模式登场\" class=\"headerlink\" title=\"桥接模式登场\"></a>桥接模式登场</h4><p>首先我们针对平台和坦克型号这两个纬度进行抽象</p>\n<pre><code class=\"C#\">namespace Bridge\n{\n  /// &lt;summary&gt;\n  /// 将不同平台坦克实现抽象出来（应对平台变化）\n  /// &lt;/summary&gt;\n  public abstract class TankPlatformImplementation\n  {\n      public abstract void MoveTo();\n      public abstract void Draw();\n      public abstract void Stop();\n  }\n  /// &lt;summary&gt;\n  /// 坦克抽象类(应对坦克型号的变化)\n  /// &lt;/summary&gt;\n  public abstract class Tank\n  {\n      TankPlatformImplementation tanklmp;//对象组合\n      public Tank( TankPlatformImplementation tanklmp)\n      {\n          this.tanklmp = tanklmp;\n      }\n      public abstract void Run();\n      public abstract void Shot();\n      public abstract void Stop();\n  }\n}\n</code></pre>\n<p>不同平台下的坦克实现</p>\n<pre><code class=\"C#\">/// &lt;summary&gt;\n/// PC平台的Tank\n/// &lt;/summary&gt;\npublic class PCTankImplementation:TankPlatformImplementation\n{\n     public override void  MoveTo()\n     {\n        //PC上的实现代码\n     }\n     public override void  Draw()\n     {\n       //PC上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        //PC上的实现代码\n     }\n }\n/// &lt;summary&gt;\n/// Mobile平台的Tank\n/// &lt;/summary&gt;\npublic class MobileTankImplementation:TankPlatformImplementation\n{\n\n     public override void  MoveTo()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Draw()\n     {\n       // Mobile上的实现代码\n     }\n\n     public override void  Stop()\n     {\n        // Mobile上的实现代码\n     }\n}\n</code></pre>\n<p>不同型号坦克的子类实现</p>\n<pre><code class=\"C#\">public class T50 : Tank\n{\n  public T50(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n\npublic class T75 : Tank\n{\n  public T75(TankPlatformImplementation tanklmp)\n      : base(tanklmp)\n  {\n\n  }\n  public override void Run()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Shot()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n  public override void Stop()\n  {\n      //....\n      //using tanklmp do something...\n      //...\n  }\n}\n</code></pre>\n<p>以上代码实现完了之后，我们就可以很轻松的针对不同平台进行开发</p>\n<pre><code class=\"C#\">public class App\n{\n    public static void Main()\n    {\n       //手机平台游戏\n        TankPlatformImplementation mobileTank=new MobileTankImplementation();\n        Tank tank=new T50(mobileTank);\n        //tank.Shot();\n    }\n}\n</code></pre>\n<h3 id=\"可适用性\"><a href=\"#可适用性\" class=\"headerlink\" title=\"可适用性\"></a>可适用性</h3><ol>\n<li>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</li>\n<li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li>\n<li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li>\n<li>（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。</li>\n<li>有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”(nested generalizations)。</li>\n<li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String类[Cop92]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。</li>\n</ol>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/archive/2012/02/24/3178773.html\">这里</a></p>"},{"title":"Hibernate Session中createQuery()和createSQLSquery()方法的区别","date":"2014-06-04T10:37:29.000Z","_content":"\n本文将介绍Hibernate的Session类createQuery, createSQLSquery方法两个区别及如何使用\n\n### createQuery\n\n可以使用\"FROM Student\"这样的HQL语句进行查询，其中\"Student\"是持久化Student类的名称\n\n<!--more-->\n例如：\n```Java\nSession session = factory.openSession();\nQuery query = session.createQuery(\"FROM Student where studentId=\"+ stuId);\nStudent ss = (Student) query.list().get(0);\nSystem.out.println(ss.getName() + \"    \" + ss.getAge());\nsession.close();\n```\n\n### createSQLQuery\n\n可以像\"select * from student\"这样使用原生数据库语法编写查询语句，其中student是一个表的名称\n\n例如：\n\n```Java\nSession session = factory.openSession();\nSQLQuery query = session.createSQLQuery(\"select * from student where student_id=\"+stuId);\nquery.addEntity(Student.class);\nList list = query.list();\nfor (Object ss : list) {\n  System.out.println(((Object)ss).getName() + \"    \" + ((Object)ss).getAge());\n  session.close();\n}    \nsession.close();\n```\nquery.addEntity(Student.class)这句是指定将数据库查询的数据映射到指定的实体类，如果不指定将会以Object[Object[]]返回行数据\n\n### get()\n\n用给定的对象标识返回给定的持久化实体类（Student.hbm.xml为实体类映射文件，实体标识id映射数据库的主键student_id）\n例如\n```Java\nSession session = factory.openSession();\nStudent ss = (Student) session.get(Student.class,student_id);\nSystem.out.println(ss.getName() + \"    \" + ss.getAge());\nsession.close();\n```\n","source":"_posts/createquery-vs-createsqlsquery.md","raw":"---\ntitle: Hibernate Session中createQuery()和createSQLSquery()方法的区别\ndate: 2014-06-04 18:37:29\ncategories: Hibernate\ntags: ['hibernate','java']\n---\n\n本文将介绍Hibernate的Session类createQuery, createSQLSquery方法两个区别及如何使用\n\n### createQuery\n\n可以使用\"FROM Student\"这样的HQL语句进行查询，其中\"Student\"是持久化Student类的名称\n\n<!--more-->\n例如：\n```Java\nSession session = factory.openSession();\nQuery query = session.createQuery(\"FROM Student where studentId=\"+ stuId);\nStudent ss = (Student) query.list().get(0);\nSystem.out.println(ss.getName() + \"    \" + ss.getAge());\nsession.close();\n```\n\n### createSQLQuery\n\n可以像\"select * from student\"这样使用原生数据库语法编写查询语句，其中student是一个表的名称\n\n例如：\n\n```Java\nSession session = factory.openSession();\nSQLQuery query = session.createSQLQuery(\"select * from student where student_id=\"+stuId);\nquery.addEntity(Student.class);\nList list = query.list();\nfor (Object ss : list) {\n  System.out.println(((Object)ss).getName() + \"    \" + ((Object)ss).getAge());\n  session.close();\n}    \nsession.close();\n```\nquery.addEntity(Student.class)这句是指定将数据库查询的数据映射到指定的实体类，如果不指定将会以Object[Object[]]返回行数据\n\n### get()\n\n用给定的对象标识返回给定的持久化实体类（Student.hbm.xml为实体类映射文件，实体标识id映射数据库的主键student_id）\n例如\n```Java\nSession session = factory.openSession();\nStudent ss = (Student) session.get(Student.class,student_id);\nSystem.out.println(ss.getName() + \"    \" + ss.getAge());\nsession.close();\n```\n","slug":"createquery-vs-createsqlsquery","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsvw0011qk5c4we1bz7g","content":"<p>本文将介绍Hibernate的Session类createQuery, createSQLSquery方法两个区别及如何使用</p>\n<h3 id=\"createQuery\"><a href=\"#createQuery\" class=\"headerlink\" title=\"createQuery\"></a>createQuery</h3><p>可以使用”FROM Student”这样的HQL语句进行查询，其中”Student”是持久化Student类的名称</p>\n<a id=\"more\"></a>\n<p>例如：</p>\n<pre><code class=\"Java\">Session session = factory.openSession();\nQuery query = session.createQuery(&quot;FROM Student where studentId=&quot;+ stuId);\nStudent ss = (Student) query.list().get(0);\nSystem.out.println(ss.getName() + &quot;    &quot; + ss.getAge());\nsession.close();\n</code></pre>\n<h3 id=\"createSQLQuery\"><a href=\"#createSQLQuery\" class=\"headerlink\" title=\"createSQLQuery\"></a>createSQLQuery</h3><p>可以像”select * from student”这样使用原生数据库语法编写查询语句，其中student是一个表的名称</p>\n<p>例如：</p>\n<pre><code class=\"Java\">Session session = factory.openSession();\nSQLQuery query = session.createSQLQuery(&quot;select * from student where student_id=&quot;+stuId);\nquery.addEntity(Student.class);\nList list = query.list();\nfor (Object ss : list) {\n  System.out.println(((Object)ss).getName() + &quot;    &quot; + ((Object)ss).getAge());\n  session.close();\n}    \nsession.close();\n</code></pre>\n<p>query.addEntity(Student.class)这句是指定将数据库查询的数据映射到指定的实体类，如果不指定将会以Object[Object[]]返回行数据</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p>用给定的对象标识返回给定的持久化实体类（Student.hbm.xml为实体类映射文件，实体标识id映射数据库的主键student_id）<br>例如</p>\n<pre><code class=\"Java\">Session session = factory.openSession();\nStudent ss = (Student) session.get(Student.class,student_id);\nSystem.out.println(ss.getName() + &quot;    &quot; + ss.getAge());\nsession.close();\n</code></pre>\n","excerpt":"<p>本文将介绍Hibernate的Session类createQuery, createSQLSquery方法两个区别及如何使用</p>\n<h3 id=\"createQuery\"><a href=\"#createQuery\" class=\"headerlink\" title=\"createQuery\"></a>createQuery</h3><p>可以使用”FROM Student”这样的HQL语句进行查询，其中”Student”是持久化Student类的名称</p>","more":"<p>例如：</p>\n<pre><code class=\"Java\">Session session = factory.openSession();\nQuery query = session.createQuery(&quot;FROM Student where studentId=&quot;+ stuId);\nStudent ss = (Student) query.list().get(0);\nSystem.out.println(ss.getName() + &quot;    &quot; + ss.getAge());\nsession.close();\n</code></pre>\n<h3 id=\"createSQLQuery\"><a href=\"#createSQLQuery\" class=\"headerlink\" title=\"createSQLQuery\"></a>createSQLQuery</h3><p>可以像”select * from student”这样使用原生数据库语法编写查询语句，其中student是一个表的名称</p>\n<p>例如：</p>\n<pre><code class=\"Java\">Session session = factory.openSession();\nSQLQuery query = session.createSQLQuery(&quot;select * from student where student_id=&quot;+stuId);\nquery.addEntity(Student.class);\nList list = query.list();\nfor (Object ss : list) {\n  System.out.println(((Object)ss).getName() + &quot;    &quot; + ((Object)ss).getAge());\n  session.close();\n}    \nsession.close();\n</code></pre>\n<p>query.addEntity(Student.class)这句是指定将数据库查询的数据映射到指定的实体类，如果不指定将会以Object[Object[]]返回行数据</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><p>用给定的对象标识返回给定的持久化实体类（Student.hbm.xml为实体类映射文件，实体标识id映射数据库的主键student_id）<br>例如</p>\n<pre><code class=\"Java\">Session session = factory.openSession();\nStudent ss = (Student) session.get(Student.class,student_id);\nSystem.out.println(ss.getName() + &quot;    &quot; + ss.getAge());\nsession.close();\n</code></pre>"},{"title":"使用Swagger插件丰富增强RESTful服务","date":"2016-09-03T06:04:44.000Z","_content":"\n## 前言\n\n通常来说调用一个RESTful服务接口可以说是一个比较繁杂的事情,因为有很多非常低效的任务要去做。我们非常羡慕使用WS*/SOAP协议服务的人:他们可以很容易地基于正式的WSDL接口规范生成一个客户端API，这样大大的简化了服务的调用。在很长一段时间内REST世界中缺乏广泛的正式规范和生成工具。但是Swagger的出现改变了这种局面\n<!--more-->\n\n## 处理RESTful服务现存的问题\n\n当涉及到调用RESTful服务时，你会遇到两个问题：\n- 首先要阅读并且理解RESTful服务接口文档\n- 使用费劲的RESTful服务，你必须创建一个HTTP请求，包括正确的HTTP方法,正确的HTTP头，URL使用正确的参数，在HTTP Body里使用正确的JSON，这些特别是在服务API的变化时,维护成本特别高\n\n当开发和维护一个RESTful服务时，你会遇到下面问题：\n- 必须手动再编写一个api文档\n- 当服务改变时，你必须兼顾同步更新api文档，这个过程是比较容易出现错误\n\n然而，Swagger就可以解决这些问题\n\n## 使用Swagger\n\nSwagger的核心是一个用来描述RESTful服务规范的语言。但最重要的是，这个规范如同代码生成器和编辑器,提供了一个强大和积极成熟的生态系统工具,。这就是独特的卖点像WADL其他规范语言一样。\n\n在开发流程中，有两种方式使用[Swagger](http://swagger.io/getting-started/)\n- API优先\n- 服务优先\n\n### API优先\n\n你可以先写你的Swagger API规范。在此基础上规范可以生成JAX-RS存根资源类和调用服务的客户端库。尽管可以利用[Swagger编辑器](http://editor.swagger.io/),用来创建这个规格，但这是一个非常艰难的任务，你需要学习这个规范语言。\n\n然而,这是必须要做的，因为当你开始一个新项目涉及多个不同公司的团队时,你必须提交一个API规范。这样所有团队可以开始工作,不需要等待服务团队(例如通过生成一个服务的伪实现)\n\n在这有一个很棒的的工具[swagger-inflector](http://swagger.io/writing-apis-with-the-swagger-inflector/)。它简化了基于给定的swagge文件JAX-RS服务器的实现,不再有JAX-RS生成的步骤。swagger-inflector在运行时将请求重定向到你的业务逻辑。如果你不提供业务逻辑,将返回伪实现的数据。因此,swagger-inflector还可用于对于一个给定swagger文件进行模拟服务。\n\n### 服务优先\n\n我更喜欢服务优先这种更加实际的方式，看下下面这工作流程图：\n![使用Swagger服务开发优先流程图](http://oaefo3hoy.bkt.clouddn.com/16-9-3/35478687.jpg)\n\n#### 服务端\n\n通常,你开始通过编写JAX-RS资源类开发RESTful服务。然后通过对资源类添加Swaggeer的注解为RESTful API提供额外的文档。大部分的Swaggeer相关注解以前缀“@Api*”开始。资源类最终会像如下的代码:\n\n```java\n@Api(value = \"customers\", description = \"RESTful API to interact with customer resources.\")\n@Path(\"customers\")\npublic class CustomerResource {\n\t@Inject\n\tprivate CustomerDAO dao;\n\n\t@ApiOperation(value = \"Get all customers\", notes = \"Get all customers matching the given search string.\", responseContainer = \"List\", response = Customer.class)\n\t@GET\n\t@Path(\"/\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic List<Customer> getCustomers(\n\t\t\t@ApiParam(value = \"The search string is used to find customer by their name. Not case sensetive.\", required = false, defaultValue = \"\") @QueryParam(\"search\") String searchString,\n\t\t\t@ApiParam(value = \"Limits the size of the result set\", required = false, defaultValue = \"50\") @QueryParam(\"limit\") int limit) {\n\t\tList<Customer> customers = dao.getCustomers(searchString, limit);\n\t\treturn customers;\n\t}\n\n\t@ApiOperation(value = \"Create a new customer\", notes = \"Creates a new customer with the given name. The URL of the new customer is returned in the location header.\")\n\t@POST\n\t@Path(\"/\")\n\t@Consumes(MediaType.APPLICATION_JSON)\n\tpublic Response createEmployee(\n\t\t\t@ApiParam(value = \"customer's name\", required = true) String customerName)\n\t\t\tthrows URISyntaxException {\n\t\tCustomer customer = dao.createCustomer(customerName);\n\n\t\tURI uri = createNewLocationURI(customer.getId());\n\t\tResponse response = Response.created(uri).build();\n\t\treturn response;\n\t}\n}\n```\n\n现在我们可以让Swagger处理带注解的资源类。它将生成正式规范。典型的应该是基于你的API规范以相同步骤创建的一个HTML文档。有几种方法可以实现这它:\n\n- 可以在Maven构建过程中生成Swagger规范文档，这个可以通过我们的[swagger-maven-plugin](https://github.com/kongchen/swagger-maven-plugin)完成\n- 如果正在使用Dropwizard，可以使用其捆绑插件[dropwizard-swagger](https://github.com/federecio/dropwizard-swagger)。它会在服务类启动过程中自动生成Swagger规范并且都发布在特定的url下面。这种方式非常非常不错,因为这样可以确保规范和文档跟已发布的服务保持最新。除此之外，不需要关心如何发布规范和文档。\n\n下面是生成的API规范和我们的RESTful服务：\n```yml\nswagger: \"2.0\"\ninfo: {}\nbasePath: \"/\"\ntags:\n- name: \"customers\"\npaths:\n  /customers:\n    get:\n      tags:\n      - \"customers\"\n      summary: \"Get all customers\"\n      description: \"Get all customers matching the given search string.\"\n      operationId: \"getCustomers\"\n      consumes:\n      - \"application/json\"\n      produces:\n      - \"application/json\"\n      parameters:\n      - name: \"search\"\n        in: \"query\"\n        description: \"The search string is used to find customer by their name. Not\\\n          \\ case sensetive.\"\n        required: false\n        type: \"string\"\n      - name: \"limit\"\n        in: \"query\"\n        description: \"Limits the size of the result set\"\n        required: false\n        type: \"integer\"\n        default: \"50\"\n        format: \"int32\"\n      responses:\n        200:\n          description: \"successful operation\"\n          schema:\n            type: \"array\"\n            items:\n              $ref: \"#/definitions/Customer\"\n    post:\n      tags:\n      - \"customers\"\n      summary: \"Creates a new customer\"\n      description: \"Creates a new customer with the given name. \"\n      operationId: \"createEmployee\"\n      consumes:\n      - \"application/json\"\n      parameters:\n      - in: \"body\"\n        name: \"body\"\n        description: \"customer's name\"\n        required: false\n        schema:\n          type: \"string\"\n      responses:\n        default:\n          description: \"successful operation\"\n```\n\n生成的文档，如图：\n![生成的api文档](http://oaefo3hoy.bkt.clouddn.com/16-9-3/92930277.jpg)\n\n\n那么好处是什么呢？我们有了一个自动保持最新的API文档，文档是自动生成的，我们不需要手工去编写。另外，还提供了一个正式API规范标准。该规范可以用来生成一个客户端库(支持生成多个编程语言)，这是我们接下来要做的。\n\n#### 客户端\n\n客户端希望使用我们的RESTful服务,可以使用我们发布的Swagger规范来生成客户端库。有以下几种方法来生成：\n\n**使用命令行工具**\n\n为此，我们可以使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)命令行工具。下面是一个使用它的命令示例：\n```shell\njava -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \\\n  -i http://localhost:8080/swagger.json \\\n  -l java \\\n  -o samples/client/customer/java\n```\n上面示例的命令将生成一个完整的Maven项目，可以构建安装到我们自己的仓库中\n\n**使用Maven插件**\n\n然而,我建议通过[swagger-codegen-maven-plugin](https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen-maven-plugin) maven插件在一个现有的项目执行生成操作。通过这种方式,我们可以维护自己项目的pom(而不是生成一个新的项目)，并且完全控制构建配置(SVN/Git位置,构件的仓库url)。这非常适合于一个典型的项目基础设施搭建。\n\n```xml\n<properties>\n\t<yaml.file>${project.basedir}/src/main/resources/prozu-service.yaml</yaml.file>\n\t<generated-sources-path>${project.build.directory}/generated-sources</generated-sources-path>\n\t<generated-sources-java-path>main/java</generated-sources-java-path>\n\t<version.swagger.codegen>2.1.4</version.swagger.codegen>\n\t<!-- TODO add the properties from target/generated-sources/pom.xml here -->\n</properties>\n<dependencies>\n\t<!-- TODO add the dependencies from target/generated-sources/pom.xml here -->\n</dependencies>\n\n<build>\n<plugins>\n\t<plugin>\n\t\t<groupId>io.swagger</groupId>\n\t\t<artifactId>swagger-codegen-maven-plugin</artifactId>\n\t\t<version>${version.swagger.codegen}</version>\n\t\t<configuration>\n\t\t\t<inputSpec>${yaml.file}</inputSpec>\n\t\t\t<configOptions>\n\t\t\t\t<sourceFolder>${generated-sources-java-path}</sourceFolder>\n\t\t\t</configOptions>\n\t\t\t<output>${generated-sources-path}</output>\n\t\t</configuration>\n\t\t<executions>\n\t\t\t<execution>\n\t\t\t\t<id>generate-swagger-javaclient</id>\n\t\t\t\t<phase>generate-sources</phase>\n\t\t\t\t<goals>\n\t\t\t\t\t<goal>generate</goal>\n\t\t\t\t</goals>\n\t\t\t\t<configuration>\n\t\t\t\t\t<language>java</language>\n\t\t\t\t\t<modelPackage>${groupId}.prozu.client.model</modelPackage>\n\t\t\t\t\t<apiPackage>${groupId}.prozu.client.api</apiPackage>\n\t\t\t\t\t<invokerPackage>${groupId}.prozu.client.invoker</invokerPackage>\n\t\t\t\t</configuration>\n\t\t\t</execution>\n\t\t</executions>\n\t</plugin>\n\t<plugin>\n\t\t<groupId>org.codehaus.mojo</groupId>\n\t\t<artifactId>build-helper-maven-plugin</artifactId>\n\t\t<version>1.9.1</version>\n\t\t<executions>\n\t\t\t<!-- TODO for eclipse/m2e users: install the m2e connector 'buildhelper' by selecting 'Discover new m2e connectors' while hovering over the follwoing execution tag -->\n\t\t\t<execution>\n\t\t\t\t<id>add-generated-source</id>\n\t\t\t\t<phase>initialize</phase>\n\t\t\t\t<goals>\n\t\t\t\t\t<goal>add-source</goal>\n\t\t\t\t</goals>\n\t\t\t\t<configuration>\n\t\t\t\t\t<sources>\n\t\t\t\t\t\t<source>${generated-sources-path}/${generated-sources-java-path}</source>\n\t\t\t\t\t</sources>\n\t\t\t\t</configuration>\n\t\t\t</execution>\n\t\t</executions>\n\t</plugin>\n</plugins>\n\n<!-- the following is only necessary if you are using eclipse and m2e -->\n<pluginManagement>\n\t<plugins>\n\t\t<plugin>\n\t\t\t<groupId>org.eclipse.m2e</groupId>\n\t\t\t<artifactId>lifecycle-mapping</artifactId>\n\t\t\t<version>1.0.0</version>\n\t\t\t<configuration>\n\t\t\t\t<lifecycleMappingMetadata>\n\t\t\t\t\t<pluginExecutions>\n\t\t\t\t\t\t<pluginExecution>\n\t\t\t\t\t\t\t<pluginExecutionFilter>\n\t\t\t\t\t\t\t\t<groupId>io.swagger</groupId>\n\t\t\t\t\t\t\t\t<artifactId>swagger-codegen-maven-plugin</artifactId>\n\t\t\t\t\t\t\t\t<versionRange>[${version.swagger.codegen},)</versionRange>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>generate</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t</pluginExecutionFilter>\n\t\t\t\t\t\t\t<action>\n\t\t\t\t\t\t\t\t<execute />\n\t\t\t\t\t\t\t</action>\n\t\t\t\t\t\t</pluginExecution>\n\t\t\t\t\t</pluginExecutions>\n\t\t\t\t</lifecycleMappingMetadata>\n\t\t\t</configuration>\n\t\t</plugin>\n\t</plugins>\n</pluginManagement>\n</build>\n```\n基于上面的Maven配置，运行`mvn generate-sources`生成客户端库代码到项目的target/generated-sources目录下，运行`mvn package`将会将生成的客户端库代码打包成一个jar包\n\n### 客户端调用\n\n最后，我们就可以在应用项目中使用那个客户端库调用服务了\n```java\nApiClient apiClient = new ApiClient();\napiClient.setBasePath(\"http://localhost:8080\");\nCustomersApi customerApi = new CustomersApi(apiClient);\nList<Customer> customers = customerApi.getCustomers(\"peter\", 40);\n```\n通过上述调用代码，可以看出这大大的简化了调用RESTful服务的过程，这里我们使用抽象api的调用，非常低级的工作交给了客户端的lib完成\n\n## 博主声明\n\n本文属于博主原创英文技术文章翻译，原文连接请点击[这里](http://blog.philipphauer.de/enriching-restful-services-swagger/),翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读\n\n由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！\n","source":"_posts/enriching-restful-services-swagger.md","raw":"---\ntitle: 使用Swagger插件丰富增强RESTful服务\ndate: 2016-09-03 14:04:44\ncategories: 随笔\ntags: ['Swagger','RESTful Service','原创翻译']\n---\n\n## 前言\n\n通常来说调用一个RESTful服务接口可以说是一个比较繁杂的事情,因为有很多非常低效的任务要去做。我们非常羡慕使用WS*/SOAP协议服务的人:他们可以很容易地基于正式的WSDL接口规范生成一个客户端API，这样大大的简化了服务的调用。在很长一段时间内REST世界中缺乏广泛的正式规范和生成工具。但是Swagger的出现改变了这种局面\n<!--more-->\n\n## 处理RESTful服务现存的问题\n\n当涉及到调用RESTful服务时，你会遇到两个问题：\n- 首先要阅读并且理解RESTful服务接口文档\n- 使用费劲的RESTful服务，你必须创建一个HTTP请求，包括正确的HTTP方法,正确的HTTP头，URL使用正确的参数，在HTTP Body里使用正确的JSON，这些特别是在服务API的变化时,维护成本特别高\n\n当开发和维护一个RESTful服务时，你会遇到下面问题：\n- 必须手动再编写一个api文档\n- 当服务改变时，你必须兼顾同步更新api文档，这个过程是比较容易出现错误\n\n然而，Swagger就可以解决这些问题\n\n## 使用Swagger\n\nSwagger的核心是一个用来描述RESTful服务规范的语言。但最重要的是，这个规范如同代码生成器和编辑器,提供了一个强大和积极成熟的生态系统工具,。这就是独特的卖点像WADL其他规范语言一样。\n\n在开发流程中，有两种方式使用[Swagger](http://swagger.io/getting-started/)\n- API优先\n- 服务优先\n\n### API优先\n\n你可以先写你的Swagger API规范。在此基础上规范可以生成JAX-RS存根资源类和调用服务的客户端库。尽管可以利用[Swagger编辑器](http://editor.swagger.io/),用来创建这个规格，但这是一个非常艰难的任务，你需要学习这个规范语言。\n\n然而,这是必须要做的，因为当你开始一个新项目涉及多个不同公司的团队时,你必须提交一个API规范。这样所有团队可以开始工作,不需要等待服务团队(例如通过生成一个服务的伪实现)\n\n在这有一个很棒的的工具[swagger-inflector](http://swagger.io/writing-apis-with-the-swagger-inflector/)。它简化了基于给定的swagge文件JAX-RS服务器的实现,不再有JAX-RS生成的步骤。swagger-inflector在运行时将请求重定向到你的业务逻辑。如果你不提供业务逻辑,将返回伪实现的数据。因此,swagger-inflector还可用于对于一个给定swagger文件进行模拟服务。\n\n### 服务优先\n\n我更喜欢服务优先这种更加实际的方式，看下下面这工作流程图：\n![使用Swagger服务开发优先流程图](http://oaefo3hoy.bkt.clouddn.com/16-9-3/35478687.jpg)\n\n#### 服务端\n\n通常,你开始通过编写JAX-RS资源类开发RESTful服务。然后通过对资源类添加Swaggeer的注解为RESTful API提供额外的文档。大部分的Swaggeer相关注解以前缀“@Api*”开始。资源类最终会像如下的代码:\n\n```java\n@Api(value = \"customers\", description = \"RESTful API to interact with customer resources.\")\n@Path(\"customers\")\npublic class CustomerResource {\n\t@Inject\n\tprivate CustomerDAO dao;\n\n\t@ApiOperation(value = \"Get all customers\", notes = \"Get all customers matching the given search string.\", responseContainer = \"List\", response = Customer.class)\n\t@GET\n\t@Path(\"/\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic List<Customer> getCustomers(\n\t\t\t@ApiParam(value = \"The search string is used to find customer by their name. Not case sensetive.\", required = false, defaultValue = \"\") @QueryParam(\"search\") String searchString,\n\t\t\t@ApiParam(value = \"Limits the size of the result set\", required = false, defaultValue = \"50\") @QueryParam(\"limit\") int limit) {\n\t\tList<Customer> customers = dao.getCustomers(searchString, limit);\n\t\treturn customers;\n\t}\n\n\t@ApiOperation(value = \"Create a new customer\", notes = \"Creates a new customer with the given name. The URL of the new customer is returned in the location header.\")\n\t@POST\n\t@Path(\"/\")\n\t@Consumes(MediaType.APPLICATION_JSON)\n\tpublic Response createEmployee(\n\t\t\t@ApiParam(value = \"customer's name\", required = true) String customerName)\n\t\t\tthrows URISyntaxException {\n\t\tCustomer customer = dao.createCustomer(customerName);\n\n\t\tURI uri = createNewLocationURI(customer.getId());\n\t\tResponse response = Response.created(uri).build();\n\t\treturn response;\n\t}\n}\n```\n\n现在我们可以让Swagger处理带注解的资源类。它将生成正式规范。典型的应该是基于你的API规范以相同步骤创建的一个HTML文档。有几种方法可以实现这它:\n\n- 可以在Maven构建过程中生成Swagger规范文档，这个可以通过我们的[swagger-maven-plugin](https://github.com/kongchen/swagger-maven-plugin)完成\n- 如果正在使用Dropwizard，可以使用其捆绑插件[dropwizard-swagger](https://github.com/federecio/dropwizard-swagger)。它会在服务类启动过程中自动生成Swagger规范并且都发布在特定的url下面。这种方式非常非常不错,因为这样可以确保规范和文档跟已发布的服务保持最新。除此之外，不需要关心如何发布规范和文档。\n\n下面是生成的API规范和我们的RESTful服务：\n```yml\nswagger: \"2.0\"\ninfo: {}\nbasePath: \"/\"\ntags:\n- name: \"customers\"\npaths:\n  /customers:\n    get:\n      tags:\n      - \"customers\"\n      summary: \"Get all customers\"\n      description: \"Get all customers matching the given search string.\"\n      operationId: \"getCustomers\"\n      consumes:\n      - \"application/json\"\n      produces:\n      - \"application/json\"\n      parameters:\n      - name: \"search\"\n        in: \"query\"\n        description: \"The search string is used to find customer by their name. Not\\\n          \\ case sensetive.\"\n        required: false\n        type: \"string\"\n      - name: \"limit\"\n        in: \"query\"\n        description: \"Limits the size of the result set\"\n        required: false\n        type: \"integer\"\n        default: \"50\"\n        format: \"int32\"\n      responses:\n        200:\n          description: \"successful operation\"\n          schema:\n            type: \"array\"\n            items:\n              $ref: \"#/definitions/Customer\"\n    post:\n      tags:\n      - \"customers\"\n      summary: \"Creates a new customer\"\n      description: \"Creates a new customer with the given name. \"\n      operationId: \"createEmployee\"\n      consumes:\n      - \"application/json\"\n      parameters:\n      - in: \"body\"\n        name: \"body\"\n        description: \"customer's name\"\n        required: false\n        schema:\n          type: \"string\"\n      responses:\n        default:\n          description: \"successful operation\"\n```\n\n生成的文档，如图：\n![生成的api文档](http://oaefo3hoy.bkt.clouddn.com/16-9-3/92930277.jpg)\n\n\n那么好处是什么呢？我们有了一个自动保持最新的API文档，文档是自动生成的，我们不需要手工去编写。另外，还提供了一个正式API规范标准。该规范可以用来生成一个客户端库(支持生成多个编程语言)，这是我们接下来要做的。\n\n#### 客户端\n\n客户端希望使用我们的RESTful服务,可以使用我们发布的Swagger规范来生成客户端库。有以下几种方法来生成：\n\n**使用命令行工具**\n\n为此，我们可以使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)命令行工具。下面是一个使用它的命令示例：\n```shell\njava -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \\\n  -i http://localhost:8080/swagger.json \\\n  -l java \\\n  -o samples/client/customer/java\n```\n上面示例的命令将生成一个完整的Maven项目，可以构建安装到我们自己的仓库中\n\n**使用Maven插件**\n\n然而,我建议通过[swagger-codegen-maven-plugin](https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen-maven-plugin) maven插件在一个现有的项目执行生成操作。通过这种方式,我们可以维护自己项目的pom(而不是生成一个新的项目)，并且完全控制构建配置(SVN/Git位置,构件的仓库url)。这非常适合于一个典型的项目基础设施搭建。\n\n```xml\n<properties>\n\t<yaml.file>${project.basedir}/src/main/resources/prozu-service.yaml</yaml.file>\n\t<generated-sources-path>${project.build.directory}/generated-sources</generated-sources-path>\n\t<generated-sources-java-path>main/java</generated-sources-java-path>\n\t<version.swagger.codegen>2.1.4</version.swagger.codegen>\n\t<!-- TODO add the properties from target/generated-sources/pom.xml here -->\n</properties>\n<dependencies>\n\t<!-- TODO add the dependencies from target/generated-sources/pom.xml here -->\n</dependencies>\n\n<build>\n<plugins>\n\t<plugin>\n\t\t<groupId>io.swagger</groupId>\n\t\t<artifactId>swagger-codegen-maven-plugin</artifactId>\n\t\t<version>${version.swagger.codegen}</version>\n\t\t<configuration>\n\t\t\t<inputSpec>${yaml.file}</inputSpec>\n\t\t\t<configOptions>\n\t\t\t\t<sourceFolder>${generated-sources-java-path}</sourceFolder>\n\t\t\t</configOptions>\n\t\t\t<output>${generated-sources-path}</output>\n\t\t</configuration>\n\t\t<executions>\n\t\t\t<execution>\n\t\t\t\t<id>generate-swagger-javaclient</id>\n\t\t\t\t<phase>generate-sources</phase>\n\t\t\t\t<goals>\n\t\t\t\t\t<goal>generate</goal>\n\t\t\t\t</goals>\n\t\t\t\t<configuration>\n\t\t\t\t\t<language>java</language>\n\t\t\t\t\t<modelPackage>${groupId}.prozu.client.model</modelPackage>\n\t\t\t\t\t<apiPackage>${groupId}.prozu.client.api</apiPackage>\n\t\t\t\t\t<invokerPackage>${groupId}.prozu.client.invoker</invokerPackage>\n\t\t\t\t</configuration>\n\t\t\t</execution>\n\t\t</executions>\n\t</plugin>\n\t<plugin>\n\t\t<groupId>org.codehaus.mojo</groupId>\n\t\t<artifactId>build-helper-maven-plugin</artifactId>\n\t\t<version>1.9.1</version>\n\t\t<executions>\n\t\t\t<!-- TODO for eclipse/m2e users: install the m2e connector 'buildhelper' by selecting 'Discover new m2e connectors' while hovering over the follwoing execution tag -->\n\t\t\t<execution>\n\t\t\t\t<id>add-generated-source</id>\n\t\t\t\t<phase>initialize</phase>\n\t\t\t\t<goals>\n\t\t\t\t\t<goal>add-source</goal>\n\t\t\t\t</goals>\n\t\t\t\t<configuration>\n\t\t\t\t\t<sources>\n\t\t\t\t\t\t<source>${generated-sources-path}/${generated-sources-java-path}</source>\n\t\t\t\t\t</sources>\n\t\t\t\t</configuration>\n\t\t\t</execution>\n\t\t</executions>\n\t</plugin>\n</plugins>\n\n<!-- the following is only necessary if you are using eclipse and m2e -->\n<pluginManagement>\n\t<plugins>\n\t\t<plugin>\n\t\t\t<groupId>org.eclipse.m2e</groupId>\n\t\t\t<artifactId>lifecycle-mapping</artifactId>\n\t\t\t<version>1.0.0</version>\n\t\t\t<configuration>\n\t\t\t\t<lifecycleMappingMetadata>\n\t\t\t\t\t<pluginExecutions>\n\t\t\t\t\t\t<pluginExecution>\n\t\t\t\t\t\t\t<pluginExecutionFilter>\n\t\t\t\t\t\t\t\t<groupId>io.swagger</groupId>\n\t\t\t\t\t\t\t\t<artifactId>swagger-codegen-maven-plugin</artifactId>\n\t\t\t\t\t\t\t\t<versionRange>[${version.swagger.codegen},)</versionRange>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>generate</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t</pluginExecutionFilter>\n\t\t\t\t\t\t\t<action>\n\t\t\t\t\t\t\t\t<execute />\n\t\t\t\t\t\t\t</action>\n\t\t\t\t\t\t</pluginExecution>\n\t\t\t\t\t</pluginExecutions>\n\t\t\t\t</lifecycleMappingMetadata>\n\t\t\t</configuration>\n\t\t</plugin>\n\t</plugins>\n</pluginManagement>\n</build>\n```\n基于上面的Maven配置，运行`mvn generate-sources`生成客户端库代码到项目的target/generated-sources目录下，运行`mvn package`将会将生成的客户端库代码打包成一个jar包\n\n### 客户端调用\n\n最后，我们就可以在应用项目中使用那个客户端库调用服务了\n```java\nApiClient apiClient = new ApiClient();\napiClient.setBasePath(\"http://localhost:8080\");\nCustomersApi customerApi = new CustomersApi(apiClient);\nList<Customer> customers = customerApi.getCustomers(\"peter\", 40);\n```\n通过上述调用代码，可以看出这大大的简化了调用RESTful服务的过程，这里我们使用抽象api的调用，非常低级的工作交给了客户端的lib完成\n\n## 博主声明\n\n本文属于博主原创英文技术文章翻译，原文连接请点击[这里](http://blog.philipphauer.de/enriching-restful-services-swagger/),翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读\n\n由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！\n","slug":"enriching-restful-services-swagger","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsvy0013qk5c8uyah2cy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>通常来说调用一个RESTful服务接口可以说是一个比较繁杂的事情,因为有很多非常低效的任务要去做。我们非常羡慕使用WS*/SOAP协议服务的人:他们可以很容易地基于正式的WSDL接口规范生成一个客户端API，这样大大的简化了服务的调用。在很长一段时间内REST世界中缺乏广泛的正式规范和生成工具。但是Swagger的出现改变了这种局面<br><a id=\"more\"></a></p>\n<h2 id=\"处理RESTful服务现存的问题\"><a href=\"#处理RESTful服务现存的问题\" class=\"headerlink\" title=\"处理RESTful服务现存的问题\"></a>处理RESTful服务现存的问题</h2><p>当涉及到调用RESTful服务时，你会遇到两个问题：</p>\n<ul>\n<li>首先要阅读并且理解RESTful服务接口文档</li>\n<li>使用费劲的RESTful服务，你必须创建一个HTTP请求，包括正确的HTTP方法,正确的HTTP头，URL使用正确的参数，在HTTP Body里使用正确的JSON，这些特别是在服务API的变化时,维护成本特别高</li>\n</ul>\n<p>当开发和维护一个RESTful服务时，你会遇到下面问题：</p>\n<ul>\n<li>必须手动再编写一个api文档</li>\n<li>当服务改变时，你必须兼顾同步更新api文档，这个过程是比较容易出现错误</li>\n</ul>\n<p>然而，Swagger就可以解决这些问题</p>\n<h2 id=\"使用Swagger\"><a href=\"#使用Swagger\" class=\"headerlink\" title=\"使用Swagger\"></a>使用Swagger</h2><p>Swagger的核心是一个用来描述RESTful服务规范的语言。但最重要的是，这个规范如同代码生成器和编辑器,提供了一个强大和积极成熟的生态系统工具,。这就是独特的卖点像WADL其他规范语言一样。</p>\n<p>在开发流程中，有两种方式使用<a href=\"http://swagger.io/getting-started/\" target=\"_blank\" rel=\"external\">Swagger</a></p>\n<ul>\n<li>API优先</li>\n<li>服务优先</li>\n</ul>\n<h3 id=\"API优先\"><a href=\"#API优先\" class=\"headerlink\" title=\"API优先\"></a>API优先</h3><p>你可以先写你的Swagger API规范。在此基础上规范可以生成JAX-RS存根资源类和调用服务的客户端库。尽管可以利用<a href=\"http://editor.swagger.io/\" target=\"_blank\" rel=\"external\">Swagger编辑器</a>,用来创建这个规格，但这是一个非常艰难的任务，你需要学习这个规范语言。</p>\n<p>然而,这是必须要做的，因为当你开始一个新项目涉及多个不同公司的团队时,你必须提交一个API规范。这样所有团队可以开始工作,不需要等待服务团队(例如通过生成一个服务的伪实现)</p>\n<p>在这有一个很棒的的工具<a href=\"http://swagger.io/writing-apis-with-the-swagger-inflector/\" target=\"_blank\" rel=\"external\">swagger-inflector</a>。它简化了基于给定的swagge文件JAX-RS服务器的实现,不再有JAX-RS生成的步骤。swagger-inflector在运行时将请求重定向到你的业务逻辑。如果你不提供业务逻辑,将返回伪实现的数据。因此,swagger-inflector还可用于对于一个给定swagger文件进行模拟服务。</p>\n<h3 id=\"服务优先\"><a href=\"#服务优先\" class=\"headerlink\" title=\"服务优先\"></a>服务优先</h3><p>我更喜欢服务优先这种更加实际的方式，看下下面这工作流程图：<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-3/35478687.jpg\" alt=\"使用Swagger服务开发优先流程图\"></p>\n<h4 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h4><p>通常,你开始通过编写JAX-RS资源类开发RESTful服务。然后通过对资源类添加Swaggeer的注解为RESTful API提供额外的文档。大部分的Swaggeer相关注解以前缀“@Api*”开始。资源类最终会像如下的代码:</p>\n<pre><code class=\"java\">@Api(value = &quot;customers&quot;, description = &quot;RESTful API to interact with customer resources.&quot;)\n@Path(&quot;customers&quot;)\npublic class CustomerResource {\n    @Inject\n    private CustomerDAO dao;\n\n    @ApiOperation(value = &quot;Get all customers&quot;, notes = &quot;Get all customers matching the given search string.&quot;, responseContainer = &quot;List&quot;, response = Customer.class)\n    @GET\n    @Path(&quot;/&quot;)\n    @Produces(MediaType.APPLICATION_JSON)\n    public List&lt;Customer&gt; getCustomers(\n            @ApiParam(value = &quot;The search string is used to find customer by their name. Not case sensetive.&quot;, required = false, defaultValue = &quot;&quot;) @QueryParam(&quot;search&quot;) String searchString,\n            @ApiParam(value = &quot;Limits the size of the result set&quot;, required = false, defaultValue = &quot;50&quot;) @QueryParam(&quot;limit&quot;) int limit) {\n        List&lt;Customer&gt; customers = dao.getCustomers(searchString, limit);\n        return customers;\n    }\n\n    @ApiOperation(value = &quot;Create a new customer&quot;, notes = &quot;Creates a new customer with the given name. The URL of the new customer is returned in the location header.&quot;)\n    @POST\n    @Path(&quot;/&quot;)\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response createEmployee(\n            @ApiParam(value = &quot;customer&#39;s name&quot;, required = true) String customerName)\n            throws URISyntaxException {\n        Customer customer = dao.createCustomer(customerName);\n\n        URI uri = createNewLocationURI(customer.getId());\n        Response response = Response.created(uri).build();\n        return response;\n    }\n}\n</code></pre>\n<p>现在我们可以让Swagger处理带注解的资源类。它将生成正式规范。典型的应该是基于你的API规范以相同步骤创建的一个HTML文档。有几种方法可以实现这它:</p>\n<ul>\n<li>可以在Maven构建过程中生成Swagger规范文档，这个可以通过我们的<a href=\"https://github.com/kongchen/swagger-maven-plugin\" target=\"_blank\" rel=\"external\">swagger-maven-plugin</a>完成</li>\n<li>如果正在使用Dropwizard，可以使用其捆绑插件<a href=\"https://github.com/federecio/dropwizard-swagger\" target=\"_blank\" rel=\"external\">dropwizard-swagger</a>。它会在服务类启动过程中自动生成Swagger规范并且都发布在特定的url下面。这种方式非常非常不错,因为这样可以确保规范和文档跟已发布的服务保持最新。除此之外，不需要关心如何发布规范和文档。</li>\n</ul>\n<p>下面是生成的API规范和我们的RESTful服务：</p>\n<pre><code class=\"yml\">swagger: &quot;2.0&quot;\ninfo: {}\nbasePath: &quot;/&quot;\ntags:\n- name: &quot;customers&quot;\npaths:\n  /customers:\n    get:\n      tags:\n      - &quot;customers&quot;\n      summary: &quot;Get all customers&quot;\n      description: &quot;Get all customers matching the given search string.&quot;\n      operationId: &quot;getCustomers&quot;\n      consumes:\n      - &quot;application/json&quot;\n      produces:\n      - &quot;application/json&quot;\n      parameters:\n      - name: &quot;search&quot;\n        in: &quot;query&quot;\n        description: &quot;The search string is used to find customer by their name. Not\\\n          \\ case sensetive.&quot;\n        required: false\n        type: &quot;string&quot;\n      - name: &quot;limit&quot;\n        in: &quot;query&quot;\n        description: &quot;Limits the size of the result set&quot;\n        required: false\n        type: &quot;integer&quot;\n        default: &quot;50&quot;\n        format: &quot;int32&quot;\n      responses:\n        200:\n          description: &quot;successful operation&quot;\n          schema:\n            type: &quot;array&quot;\n            items:\n              $ref: &quot;#/definitions/Customer&quot;\n    post:\n      tags:\n      - &quot;customers&quot;\n      summary: &quot;Creates a new customer&quot;\n      description: &quot;Creates a new customer with the given name. &quot;\n      operationId: &quot;createEmployee&quot;\n      consumes:\n      - &quot;application/json&quot;\n      parameters:\n      - in: &quot;body&quot;\n        name: &quot;body&quot;\n        description: &quot;customer&#39;s name&quot;\n        required: false\n        schema:\n          type: &quot;string&quot;\n      responses:\n        default:\n          description: &quot;successful operation&quot;\n</code></pre>\n<p>生成的文档，如图：<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-3/92930277.jpg\" alt=\"生成的api文档\"></p>\n<p>那么好处是什么呢？我们有了一个自动保持最新的API文档，文档是自动生成的，我们不需要手工去编写。另外，还提供了一个正式API规范标准。该规范可以用来生成一个客户端库(支持生成多个编程语言)，这是我们接下来要做的。</p>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><p>客户端希望使用我们的RESTful服务,可以使用我们发布的Swagger规范来生成客户端库。有以下几种方法来生成：</p>\n<p><strong>使用命令行工具</strong></p>\n<p>为此，我们可以使用<a href=\"https://github.com/swagger-api/swagger-codegen\" target=\"_blank\" rel=\"external\">swagger-codegen</a>命令行工具。下面是一个使用它的命令示例：</p>\n<pre><code class=\"shell\">java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \\\n  -i http://localhost:8080/swagger.json \\\n  -l java \\\n  -o samples/client/customer/java\n</code></pre>\n<p>上面示例的命令将生成一个完整的Maven项目，可以构建安装到我们自己的仓库中</p>\n<p><strong>使用Maven插件</strong></p>\n<p>然而,我建议通过<a href=\"https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen-maven-plugin\" target=\"_blank\" rel=\"external\">swagger-codegen-maven-plugin</a> maven插件在一个现有的项目执行生成操作。通过这种方式,我们可以维护自己项目的pom(而不是生成一个新的项目)，并且完全控制构建配置(SVN/Git位置,构件的仓库url)。这非常适合于一个典型的项目基础设施搭建。</p>\n<pre><code class=\"xml\">&lt;properties&gt;\n    &lt;yaml.file&gt;${project.basedir}/src/main/resources/prozu-service.yaml&lt;/yaml.file&gt;\n    &lt;generated-sources-path&gt;${project.build.directory}/generated-sources&lt;/generated-sources-path&gt;\n    &lt;generated-sources-java-path&gt;main/java&lt;/generated-sources-java-path&gt;\n    &lt;version.swagger.codegen&gt;2.1.4&lt;/version.swagger.codegen&gt;\n    &lt;!-- TODO add the properties from target/generated-sources/pom.xml here --&gt;\n&lt;/properties&gt;\n&lt;dependencies&gt;\n    &lt;!-- TODO add the dependencies from target/generated-sources/pom.xml here --&gt;\n&lt;/dependencies&gt;\n\n&lt;build&gt;\n&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;io.swagger&lt;/groupId&gt;\n        &lt;artifactId&gt;swagger-codegen-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${version.swagger.codegen}&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;inputSpec&gt;${yaml.file}&lt;/inputSpec&gt;\n            &lt;configOptions&gt;\n                &lt;sourceFolder&gt;${generated-sources-java-path}&lt;/sourceFolder&gt;\n            &lt;/configOptions&gt;\n            &lt;output&gt;${generated-sources-path}&lt;/output&gt;\n        &lt;/configuration&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n                &lt;id&gt;generate-swagger-javaclient&lt;/id&gt;\n                &lt;phase&gt;generate-sources&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;generate&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;language&gt;java&lt;/language&gt;\n                    &lt;modelPackage&gt;${groupId}.prozu.client.model&lt;/modelPackage&gt;\n                    &lt;apiPackage&gt;${groupId}.prozu.client.api&lt;/apiPackage&gt;\n                    &lt;invokerPackage&gt;${groupId}.prozu.client.invoker&lt;/invokerPackage&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;1.9.1&lt;/version&gt;\n        &lt;executions&gt;\n            &lt;!-- TODO for eclipse/m2e users: install the m2e connector &#39;buildhelper&#39; by selecting &#39;Discover new m2e connectors&#39; while hovering over the follwoing execution tag --&gt;\n            &lt;execution&gt;\n                &lt;id&gt;add-generated-source&lt;/id&gt;\n                &lt;phase&gt;initialize&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;add-source&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;sources&gt;\n                        &lt;source&gt;${generated-sources-path}/${generated-sources-java-path}&lt;/source&gt;\n                    &lt;/sources&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n&lt;/plugins&gt;\n\n&lt;!-- the following is only necessary if you are using eclipse and m2e --&gt;\n&lt;pluginManagement&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;\n            &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;\n            &lt;version&gt;1.0.0&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;lifecycleMappingMetadata&gt;\n                    &lt;pluginExecutions&gt;\n                        &lt;pluginExecution&gt;\n                            &lt;pluginExecutionFilter&gt;\n                                &lt;groupId&gt;io.swagger&lt;/groupId&gt;\n                                &lt;artifactId&gt;swagger-codegen-maven-plugin&lt;/artifactId&gt;\n                                &lt;versionRange&gt;[${version.swagger.codegen},)&lt;/versionRange&gt;\n                                &lt;goals&gt;\n                                    &lt;goal&gt;generate&lt;/goal&gt;\n                                &lt;/goals&gt;\n                            &lt;/pluginExecutionFilter&gt;\n                            &lt;action&gt;\n                                &lt;execute /&gt;\n                            &lt;/action&gt;\n                        &lt;/pluginExecution&gt;\n                    &lt;/pluginExecutions&gt;\n                &lt;/lifecycleMappingMetadata&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/pluginManagement&gt;\n&lt;/build&gt;\n</code></pre>\n<p>基于上面的Maven配置，运行<code>mvn generate-sources</code>生成客户端库代码到项目的target/generated-sources目录下，运行<code>mvn package</code>将会将生成的客户端库代码打包成一个jar包</p>\n<h3 id=\"客户端调用\"><a href=\"#客户端调用\" class=\"headerlink\" title=\"客户端调用\"></a>客户端调用</h3><p>最后，我们就可以在应用项目中使用那个客户端库调用服务了</p>\n<pre><code class=\"java\">ApiClient apiClient = new ApiClient();\napiClient.setBasePath(&quot;http://localhost:8080&quot;);\nCustomersApi customerApi = new CustomersApi(apiClient);\nList&lt;Customer&gt; customers = customerApi.getCustomers(&quot;peter&quot;, 40);\n</code></pre>\n<p>通过上述调用代码，可以看出这大大的简化了调用RESTful服务的过程，这里我们使用抽象api的调用，非常低级的工作交给了客户端的lib完成</p>\n<h2 id=\"博主声明\"><a href=\"#博主声明\" class=\"headerlink\" title=\"博主声明\"></a>博主声明</h2><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href=\"http://blog.philipphauer.de/enriching-restful-services-swagger/\" target=\"_blank\" rel=\"external\">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p>\n<p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>\n","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>通常来说调用一个RESTful服务接口可以说是一个比较繁杂的事情,因为有很多非常低效的任务要去做。我们非常羡慕使用WS*/SOAP协议服务的人:他们可以很容易地基于正式的WSDL接口规范生成一个客户端API，这样大大的简化了服务的调用。在很长一段时间内REST世界中缺乏广泛的正式规范和生成工具。但是Swagger的出现改变了这种局面<br>","more":"</p>\n<h2 id=\"处理RESTful服务现存的问题\"><a href=\"#处理RESTful服务现存的问题\" class=\"headerlink\" title=\"处理RESTful服务现存的问题\"></a>处理RESTful服务现存的问题</h2><p>当涉及到调用RESTful服务时，你会遇到两个问题：</p>\n<ul>\n<li>首先要阅读并且理解RESTful服务接口文档</li>\n<li>使用费劲的RESTful服务，你必须创建一个HTTP请求，包括正确的HTTP方法,正确的HTTP头，URL使用正确的参数，在HTTP Body里使用正确的JSON，这些特别是在服务API的变化时,维护成本特别高</li>\n</ul>\n<p>当开发和维护一个RESTful服务时，你会遇到下面问题：</p>\n<ul>\n<li>必须手动再编写一个api文档</li>\n<li>当服务改变时，你必须兼顾同步更新api文档，这个过程是比较容易出现错误</li>\n</ul>\n<p>然而，Swagger就可以解决这些问题</p>\n<h2 id=\"使用Swagger\"><a href=\"#使用Swagger\" class=\"headerlink\" title=\"使用Swagger\"></a>使用Swagger</h2><p>Swagger的核心是一个用来描述RESTful服务规范的语言。但最重要的是，这个规范如同代码生成器和编辑器,提供了一个强大和积极成熟的生态系统工具,。这就是独特的卖点像WADL其他规范语言一样。</p>\n<p>在开发流程中，有两种方式使用<a href=\"http://swagger.io/getting-started/\">Swagger</a></p>\n<ul>\n<li>API优先</li>\n<li>服务优先</li>\n</ul>\n<h3 id=\"API优先\"><a href=\"#API优先\" class=\"headerlink\" title=\"API优先\"></a>API优先</h3><p>你可以先写你的Swagger API规范。在此基础上规范可以生成JAX-RS存根资源类和调用服务的客户端库。尽管可以利用<a href=\"http://editor.swagger.io/\">Swagger编辑器</a>,用来创建这个规格，但这是一个非常艰难的任务，你需要学习这个规范语言。</p>\n<p>然而,这是必须要做的，因为当你开始一个新项目涉及多个不同公司的团队时,你必须提交一个API规范。这样所有团队可以开始工作,不需要等待服务团队(例如通过生成一个服务的伪实现)</p>\n<p>在这有一个很棒的的工具<a href=\"http://swagger.io/writing-apis-with-the-swagger-inflector/\">swagger-inflector</a>。它简化了基于给定的swagge文件JAX-RS服务器的实现,不再有JAX-RS生成的步骤。swagger-inflector在运行时将请求重定向到你的业务逻辑。如果你不提供业务逻辑,将返回伪实现的数据。因此,swagger-inflector还可用于对于一个给定swagger文件进行模拟服务。</p>\n<h3 id=\"服务优先\"><a href=\"#服务优先\" class=\"headerlink\" title=\"服务优先\"></a>服务优先</h3><p>我更喜欢服务优先这种更加实际的方式，看下下面这工作流程图：<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-3/35478687.jpg\" alt=\"使用Swagger服务开发优先流程图\"></p>\n<h4 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h4><p>通常,你开始通过编写JAX-RS资源类开发RESTful服务。然后通过对资源类添加Swaggeer的注解为RESTful API提供额外的文档。大部分的Swaggeer相关注解以前缀“@Api*”开始。资源类最终会像如下的代码:</p>\n<pre><code class=\"java\">@Api(value = &quot;customers&quot;, description = &quot;RESTful API to interact with customer resources.&quot;)\n@Path(&quot;customers&quot;)\npublic class CustomerResource {\n    @Inject\n    private CustomerDAO dao;\n\n    @ApiOperation(value = &quot;Get all customers&quot;, notes = &quot;Get all customers matching the given search string.&quot;, responseContainer = &quot;List&quot;, response = Customer.class)\n    @GET\n    @Path(&quot;/&quot;)\n    @Produces(MediaType.APPLICATION_JSON)\n    public List&lt;Customer&gt; getCustomers(\n            @ApiParam(value = &quot;The search string is used to find customer by their name. Not case sensetive.&quot;, required = false, defaultValue = &quot;&quot;) @QueryParam(&quot;search&quot;) String searchString,\n            @ApiParam(value = &quot;Limits the size of the result set&quot;, required = false, defaultValue = &quot;50&quot;) @QueryParam(&quot;limit&quot;) int limit) {\n        List&lt;Customer&gt; customers = dao.getCustomers(searchString, limit);\n        return customers;\n    }\n\n    @ApiOperation(value = &quot;Create a new customer&quot;, notes = &quot;Creates a new customer with the given name. The URL of the new customer is returned in the location header.&quot;)\n    @POST\n    @Path(&quot;/&quot;)\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response createEmployee(\n            @ApiParam(value = &quot;customer&#39;s name&quot;, required = true) String customerName)\n            throws URISyntaxException {\n        Customer customer = dao.createCustomer(customerName);\n\n        URI uri = createNewLocationURI(customer.getId());\n        Response response = Response.created(uri).build();\n        return response;\n    }\n}\n</code></pre>\n<p>现在我们可以让Swagger处理带注解的资源类。它将生成正式规范。典型的应该是基于你的API规范以相同步骤创建的一个HTML文档。有几种方法可以实现这它:</p>\n<ul>\n<li>可以在Maven构建过程中生成Swagger规范文档，这个可以通过我们的<a href=\"https://github.com/kongchen/swagger-maven-plugin\">swagger-maven-plugin</a>完成</li>\n<li>如果正在使用Dropwizard，可以使用其捆绑插件<a href=\"https://github.com/federecio/dropwizard-swagger\">dropwizard-swagger</a>。它会在服务类启动过程中自动生成Swagger规范并且都发布在特定的url下面。这种方式非常非常不错,因为这样可以确保规范和文档跟已发布的服务保持最新。除此之外，不需要关心如何发布规范和文档。</li>\n</ul>\n<p>下面是生成的API规范和我们的RESTful服务：</p>\n<pre><code class=\"yml\">swagger: &quot;2.0&quot;\ninfo: {}\nbasePath: &quot;/&quot;\ntags:\n- name: &quot;customers&quot;\npaths:\n  /customers:\n    get:\n      tags:\n      - &quot;customers&quot;\n      summary: &quot;Get all customers&quot;\n      description: &quot;Get all customers matching the given search string.&quot;\n      operationId: &quot;getCustomers&quot;\n      consumes:\n      - &quot;application/json&quot;\n      produces:\n      - &quot;application/json&quot;\n      parameters:\n      - name: &quot;search&quot;\n        in: &quot;query&quot;\n        description: &quot;The search string is used to find customer by their name. Not\\\n          \\ case sensetive.&quot;\n        required: false\n        type: &quot;string&quot;\n      - name: &quot;limit&quot;\n        in: &quot;query&quot;\n        description: &quot;Limits the size of the result set&quot;\n        required: false\n        type: &quot;integer&quot;\n        default: &quot;50&quot;\n        format: &quot;int32&quot;\n      responses:\n        200:\n          description: &quot;successful operation&quot;\n          schema:\n            type: &quot;array&quot;\n            items:\n              $ref: &quot;#/definitions/Customer&quot;\n    post:\n      tags:\n      - &quot;customers&quot;\n      summary: &quot;Creates a new customer&quot;\n      description: &quot;Creates a new customer with the given name. &quot;\n      operationId: &quot;createEmployee&quot;\n      consumes:\n      - &quot;application/json&quot;\n      parameters:\n      - in: &quot;body&quot;\n        name: &quot;body&quot;\n        description: &quot;customer&#39;s name&quot;\n        required: false\n        schema:\n          type: &quot;string&quot;\n      responses:\n        default:\n          description: &quot;successful operation&quot;\n</code></pre>\n<p>生成的文档，如图：<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-3/92930277.jpg\" alt=\"生成的api文档\"></p>\n<p>那么好处是什么呢？我们有了一个自动保持最新的API文档，文档是自动生成的，我们不需要手工去编写。另外，还提供了一个正式API规范标准。该规范可以用来生成一个客户端库(支持生成多个编程语言)，这是我们接下来要做的。</p>\n<h4 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h4><p>客户端希望使用我们的RESTful服务,可以使用我们发布的Swagger规范来生成客户端库。有以下几种方法来生成：</p>\n<p><strong>使用命令行工具</strong></p>\n<p>为此，我们可以使用<a href=\"https://github.com/swagger-api/swagger-codegen\">swagger-codegen</a>命令行工具。下面是一个使用它的命令示例：</p>\n<pre><code class=\"shell\">java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \\\n  -i http://localhost:8080/swagger.json \\\n  -l java \\\n  -o samples/client/customer/java\n</code></pre>\n<p>上面示例的命令将生成一个完整的Maven项目，可以构建安装到我们自己的仓库中</p>\n<p><strong>使用Maven插件</strong></p>\n<p>然而,我建议通过<a href=\"https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen-maven-plugin\">swagger-codegen-maven-plugin</a> maven插件在一个现有的项目执行生成操作。通过这种方式,我们可以维护自己项目的pom(而不是生成一个新的项目)，并且完全控制构建配置(SVN/Git位置,构件的仓库url)。这非常适合于一个典型的项目基础设施搭建。</p>\n<pre><code class=\"xml\">&lt;properties&gt;\n    &lt;yaml.file&gt;${project.basedir}/src/main/resources/prozu-service.yaml&lt;/yaml.file&gt;\n    &lt;generated-sources-path&gt;${project.build.directory}/generated-sources&lt;/generated-sources-path&gt;\n    &lt;generated-sources-java-path&gt;main/java&lt;/generated-sources-java-path&gt;\n    &lt;version.swagger.codegen&gt;2.1.4&lt;/version.swagger.codegen&gt;\n    &lt;!-- TODO add the properties from target/generated-sources/pom.xml here --&gt;\n&lt;/properties&gt;\n&lt;dependencies&gt;\n    &lt;!-- TODO add the dependencies from target/generated-sources/pom.xml here --&gt;\n&lt;/dependencies&gt;\n\n&lt;build&gt;\n&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;io.swagger&lt;/groupId&gt;\n        &lt;artifactId&gt;swagger-codegen-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${version.swagger.codegen}&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;inputSpec&gt;${yaml.file}&lt;/inputSpec&gt;\n            &lt;configOptions&gt;\n                &lt;sourceFolder&gt;${generated-sources-java-path}&lt;/sourceFolder&gt;\n            &lt;/configOptions&gt;\n            &lt;output&gt;${generated-sources-path}&lt;/output&gt;\n        &lt;/configuration&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n                &lt;id&gt;generate-swagger-javaclient&lt;/id&gt;\n                &lt;phase&gt;generate-sources&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;generate&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;language&gt;java&lt;/language&gt;\n                    &lt;modelPackage&gt;${groupId}.prozu.client.model&lt;/modelPackage&gt;\n                    &lt;apiPackage&gt;${groupId}.prozu.client.api&lt;/apiPackage&gt;\n                    &lt;invokerPackage&gt;${groupId}.prozu.client.invoker&lt;/invokerPackage&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;1.9.1&lt;/version&gt;\n        &lt;executions&gt;\n            &lt;!-- TODO for eclipse/m2e users: install the m2e connector &#39;buildhelper&#39; by selecting &#39;Discover new m2e connectors&#39; while hovering over the follwoing execution tag --&gt;\n            &lt;execution&gt;\n                &lt;id&gt;add-generated-source&lt;/id&gt;\n                &lt;phase&gt;initialize&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;add-source&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;sources&gt;\n                        &lt;source&gt;${generated-sources-path}/${generated-sources-java-path}&lt;/source&gt;\n                    &lt;/sources&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n&lt;/plugins&gt;\n\n&lt;!-- the following is only necessary if you are using eclipse and m2e --&gt;\n&lt;pluginManagement&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;\n            &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;\n            &lt;version&gt;1.0.0&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;lifecycleMappingMetadata&gt;\n                    &lt;pluginExecutions&gt;\n                        &lt;pluginExecution&gt;\n                            &lt;pluginExecutionFilter&gt;\n                                &lt;groupId&gt;io.swagger&lt;/groupId&gt;\n                                &lt;artifactId&gt;swagger-codegen-maven-plugin&lt;/artifactId&gt;\n                                &lt;versionRange&gt;[${version.swagger.codegen},)&lt;/versionRange&gt;\n                                &lt;goals&gt;\n                                    &lt;goal&gt;generate&lt;/goal&gt;\n                                &lt;/goals&gt;\n                            &lt;/pluginExecutionFilter&gt;\n                            &lt;action&gt;\n                                &lt;execute /&gt;\n                            &lt;/action&gt;\n                        &lt;/pluginExecution&gt;\n                    &lt;/pluginExecutions&gt;\n                &lt;/lifecycleMappingMetadata&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/pluginManagement&gt;\n&lt;/build&gt;\n</code></pre>\n<p>基于上面的Maven配置，运行<code>mvn generate-sources</code>生成客户端库代码到项目的target/generated-sources目录下，运行<code>mvn package</code>将会将生成的客户端库代码打包成一个jar包</p>\n<h3 id=\"客户端调用\"><a href=\"#客户端调用\" class=\"headerlink\" title=\"客户端调用\"></a>客户端调用</h3><p>最后，我们就可以在应用项目中使用那个客户端库调用服务了</p>\n<pre><code class=\"java\">ApiClient apiClient = new ApiClient();\napiClient.setBasePath(&quot;http://localhost:8080&quot;);\nCustomersApi customerApi = new CustomersApi(apiClient);\nList&lt;Customer&gt; customers = customerApi.getCustomers(&quot;peter&quot;, 40);\n</code></pre>\n<p>通过上述调用代码，可以看出这大大的简化了调用RESTful服务的过程，这里我们使用抽象api的调用，非常低级的工作交给了客户端的lib完成</p>\n<h2 id=\"博主声明\"><a href=\"#博主声明\" class=\"headerlink\" title=\"博主声明\"></a>博主声明</h2><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href=\"http://blog.philipphauer.de/enriching-restful-services-swagger/\">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p>\n<p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>"},{"title":"gradle日常使用之Java插件","date":"2016-07-16T16:34:58.000Z","_content":"\n\n### 介绍\n\nJava 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。\n\n### 如何引入\n\n要使用 Java 插件，请在构建脚本(build.gradle)中加入：\n```groovy\napply plugin: 'java'\n```\n\n<!--more-->\n\n### Java项目默认布局\n\n|目录|含义|\n|:----|:----|\n|src/main/java|\t产品的Java源代码\n|src/main/resources\t|产品的资源\n|src/test/java\t|Java 测试源代码\n|src/test/resources\t|测试资源\n|src/sourceSet/java\t|给定的源集的Java源代码\n|src/sourceSet/resources\t|给定的源集的资源\n\n### 自带任务列举\n\n|任务名称|依赖于|类型|描述|\n|:----|:----|:----|:-----|\n|compileJava|产生编译类路径中的所有任务。这包括了用于编译配置中包含的项目依赖关系的jar任务。|JavaCompile|使用 javac 编译产品中的 Java 源文件。\n|processResources|\t-| Copy\t|把生产资源文件拷贝到生产的类目录中。|\n|classes|compileJava和processResources。一些插件添加了额外的编译任务|Task|组装生产的类目录。\n|compileTestJava\t|compile，再加上所有能产生测试编译类路径的任务。\t|JavaCompile|\t使用 javac 编译 Java 的测试源文件。\n|processTestResources|\t-\t|Copy|\t把测试的资源文件拷贝到测试的类目录中。\n|testClasses\t|compileTestJava和processTestResources。一些插件添加了额外的测试编译任务。\tTask\t|组装测试的类目录。\n|jar\t|compile\t|Jar\t|组装 JAR 文件\n|javadoc\t|compile\t|Javadoc\t|使用 Javadoc 生成生产的 Java 源代码的API文档\n|test\t|compile， compileTest，再加上所有产生测试运行时类路径的任务。\t|Test\t|使用 JUnit 或 TestNG运行单元测试。\n|uploadArchives\t|使用archives的配置生成构件的任务，包括jar。\t|Upload\t|使用archives配置上传包括 JAR 文件的构件。\n|clean\t|-\t|Delete\t|删除项目的build目录。\n|cleanTaskName|\t-\t|Delete\t|删除由指定的任务所产生的输出文件。例如， cleanJar将删除由jar任务中所创建的 JAR 文件，cleanTest将删除由test任务所创建的测试结果。\n\n### 源集概念\n\nJava 插件引入了一个源集的概念。一个源集只是一组用于编译并一起执行的源文件。这些源文件可能包括 Java 源代码文件和资源文件。其他有一些插件添加了在源集里包含 Groovy 和 Scala 的源代码文件的能力。一个源集有一个相关联的编译类路径和运行时类路径。\n\n源集的一个用途是，把源文件进行逻辑上的分组，以描述它们的目的。例如，你可能会使用一个源集来定义一个集成测试套件，或者你可能会使用单独的源集来定义你的项目的 API 和实现类。\n\nJava 插件定义了两个标准的源集，分别是main和test。main源集包含你产品的源代码，它们将被编译并组装成一个 JAR 文件。test源集包含你的单元测试的源代码，它们将被编译并使用 JUnit 或 TestNG来执行\n\n### Java 插件-源集任务\n\n对于每个你添加到该项目中的源集，Java 插件将添加以下的编译任务：\n\n|任务名称|依赖于|类型|描述|\n|:----|:----|:----|:-----|\n|compileSourceSetJava\t|所有产生源集编译类路径的任务。\t|JavaCompile\t|使用 javac 编译给定的源集中的 Java 源文件。\n|processSourceSetResources\t|-\t|Copy\t|把给定的源集的资源文件拷贝到类目录中。\n|sourceSetClasses\t|compileSourceSetJava 和 processSourceSetResources。某些插件还为源集添加了额外的编译任务。\t|Task\t|组装给定源集的类目录。\n\n\n### Java 插件-生命周期任务\n\nJava 插件还增加了大量的任务构成该项目的生命周期：\n\n|任务名称|依赖于|类型|描述|\n|:----|:----|:----:|:-----|\n|assemble\t|项目中的所有归档项目，包括jar任务。某些插件还向项目添加额外的归档任务。\t|Task\t|组装项目中所有的归类文件。\n|check\t|项目中的所有核查项目，包括test任务。某些插件还向项目添加额外的核查任务。\t|Task\t|执行项目中所有的核查任务。\n|build\t|check 和 assemble\t|Task\t|执行项目的完事构建。\n|buildNeeded\t|build任务，以及在testRuntime配置的所有项目库依赖项的build任务。\t|Task\t|执行项目本身及它所依赖的其他所有项目的完整构建。\n|buildDependents\t|build任务，以及在testRuntime配置中对此项目有库依赖的所有项目的build任务。\t|Task\t|执行项目本身及依赖它的其他所有项目的完整构建。\n|buildConfigurationName\t|使用配置ConfigurationName生成构件的任务。\t|Task\t|组装指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。\n|uploadConfigurationName\t|使用配置ConfigurationName上传构件的任务。\t|Upload\t|组装并上传指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。\n\n### Java插件-任务依赖关系图\n\n![Java插件-任务依赖关系图](http://oaefo3hoy.bkt.clouddn.com/16-7-17/48492582.jpg)\n\n\n### Java插件 ​​- 依赖配置\n\nJava插件向项目添加了许多依赖配置，如下图所示。它对一些任务指定了这些配置，如compileJava和test。\n\n|名称|继承自|在哪些任务中使用|意义|\n|----|------|----------------|----|\n|compile|\t-\t|compileJava\t|编译时依赖\n|runtime\t|compile\t|-\t|运行时依赖\n|testCompile|\tcompile\t|compileTestJava\t|用于编译测试的其他依赖\n|testRuntime\t|runtime, testCompile\t|test\t|只用于运行测试的其他依赖\n|archives\t|-\t|uploadArchives\t|由本项目生产的构件（如jar包）。\n|default\t|runtime\t|-\t|本项目上的默认项目依赖配置。包含本项目运行时所需要的构件和依赖。\n\n\nJava插件 ​​- 依赖配置 对于每个你添加到项目中的源集，Java插件都会添加以下的依赖配置：\n\n![默认添加的依赖配置](http://oaefo3hoy.bkt.clouddn.com/16-7-17/64820034.jpg)\n\n### Java插件的常规属性\n\nJava插件向项目添加了许多常规属性，如下表格所示。您可以在构建脚本中使用这些属性，就像它们是project对象的属性一样\n\n|属性名称|类型|默认值|描述|\n|:----|:----|:----:|:-----|\n|reportsDirName\t|String\t|reports\t|相对于build目录的目录名称，报告将生成到此目录。\n|reportsDir\t|File (read-only)\t|buildDir/reportsDirName|\t报告将生成到此目录。\n|testResultsDirName\t|String\t|test-results\t|相对于build目录的目录名称，测试报告的.xml文件将生成到此目录。\n|testResultsDir\t|File (read-only)\t|buildDir/testResultsDirName\t|测试报告的.xml文件将生成到此目录。|\n|testReportDirName\t|String\t|tests\t|相对于build目录的目录名称，测试报告将生成到此目录。\n|testReportDir\t|File (read-only)\t|reportsDir/testReportDirName\t|测试报告生成到此目录。\n|libsDirName\t|String\t|libs\t|相对于build目录的目录名称，类库将生成到此目录中。\n|libsDir\t|File (read-only)|\tbuildDir/libsDirName\t|类库将生成到此目录中。\n|distsDirName\t|String\t|distributions\t|相对于build目录的目录名称，发布的文件将生成到此目录中。\n|distsDir\t|File (read-only)\t|buildDir/distsDirName\t|要发布的文件将生成到此目录。\n|docsDirName\t|String\t|docs\t|相对于build目录的目录名称，文档将生成到此目录。\n|docsDir|\tFile (read-only)\t|buildDir/docsDirName\t|要生成文档的目录。\n|dependencyCacheDirName\t|String\t|dependency-cache\t|相对于build目录的目录名称，该目录用于缓存源代码的依赖信息。\n|dependencyCacheDir\t|File (read-only)\t|buildDir/dependencyCacheDirName\t|该目录用于缓存源代码的依赖信息。\n|sourceSets\t|SourceSetContainer (read-only)\t|非空\t|包含项目的源集。\n|sourceCompatibility\t|JavaVersion.\t|可以使用字符串或数字来设置，例如\"1.5\"或1.5。\t|当前JVM所使用的值 当编译Java源代码时所使用的Java版本兼容性。\n|targetCompatibility|\tJavaVersion.\t|可以使用字符串或数字来设置，例如\"1.5\"或1.5。\t|sourceCompatibility 要生成的类的 Java 版本。\n|archivesBaseName\t|String\t|projectName|\t像JAR或ZIP文件这样的构件的basename\n|manifest\t|Manifest\t|一个空的清单\t|要包括的所有 JAR 文件的清单。\n\n\n### 使用源集\n\n你可以使用sourceSets属性访问项目的源集。这是项目的源集的容器，它的类型是 SourceSetContainer。除此之后，还有一个sourceSets{}的脚本块，可以传入一个闭包来配置源集容器。源集容器的使用方式几乎与其他容器一样，例如tasks。\n\n示例代码：访问源集的属性\n```gradle\n// Various ways to access the main source set\nprintln sourceSets.main.output.classesDir\nprintln sourceSets['main'].output.classesDir\nsourceSets {\n    println main.output.classesDir\n}\nsourceSets {\n    main {\n        println output.classesDir\n    }\n}\n\n// Iterate over the source sets\nsourceSets.all {\n    println name\n}\n```\n\n示例代码：配置源集的源代码目录\n\nbuild.gradle文件\n```gradle\nsourceSets {\n    main {\n        java {\n            srcDir 'src/java'\n        }\n        resources {\n            srcDir 'src/resources'\n        }\n    }\n}\n```\n\n\n#### 源集属性列举\n\n下表列出了一些重要的源集属性。我们可以在SourceSet的 API 文档中查看更多的详细信息。\n\n|属性名称|类型|默认值|描述\n|:--------|:----:|:------:|:----\n|name\t|String (read-only)\t|非空\t|用来确定一个源集的源集名称。\n|output\t|SourceSetOutput (read-only)\t|非空\t|源集的输出文件，包含它编译过的类和资源。\n|output.classesDir|\tFile\t|*buildDir/classes/name*\t|要生成的该源集的类的目录。\n|output.resourcesDir\t|File\t|*buildDir/resources/name*\t|要生成的该源集的资源的目录。\n|compileClasspath\t|FileCollection |compileSourceSet 配置 |该类路径在编译该源集的源文件时使用。\n|runtimeClasspath |FileCollection |output + runtimeSourceSet 配置|该类路径在执行该源集的类时使用。\n|java |SourceDirectorySet (read-only)| 非空 |该源集的Java源文件。仅包含Java源文件目录里的.java文件，并排除其他所有文件。\n|java.srcDirs |Set<File> 可指定一组输入文件来设置|[*projectDir/src/name/java*]|该源目录包含了此源集的所有Java源文件。\n|resources |SourceDirectorySet (read-only) |非空 |此源集的资源文件。仅包含资源文件，并且排除在资源源目录中找到的所有 .java文件。其他插件，如Groovy 插件，会从该集合中排除其他类型的文件。\n|resources.srcDirs| Set<File> 指定一组输入文件来设置。| [*projectDir/src/name/resources*] |该源目录包含了此源集的资源文件。\n|allJava |SourceDirectorySet (read-only) |java |该源集的所有.java 文件。有些插件，如Groovy 插件，会从该集合中增加其他的Java源文件。\n|allSource |SourceDirectorySet (read-only)| resources + java |该源集的所有源文件。包含所有的资源文件和Java源文件。有些插件，如Groovy 插件，会从该集合中增加其他的源文件。\n\n\n### 多项目构建\n\n### 创建多项目总结\n\n1. 一个多项目构建必须在根项目的根目录下包含settings.gradle文件，因为它指明了那些包含在多项目构建中的项目。\n\n2. 如果需要在多项目构建的所有项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用allprojects)\n\n3. 如果需要在根项目的子项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用subprojects)\n","source":"_posts/gradle-usage.md","raw":"---\ntitle: gradle日常使用之Java插件\ndate: 2016-07-17 00:34:58\ncategories: \"Java\"\ntags: ['gradle','构建工具']\n---\n\n\n### 介绍\n\nJava 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。\n\n### 如何引入\n\n要使用 Java 插件，请在构建脚本(build.gradle)中加入：\n```groovy\napply plugin: 'java'\n```\n\n<!--more-->\n\n### Java项目默认布局\n\n|目录|含义|\n|:----|:----|\n|src/main/java|\t产品的Java源代码\n|src/main/resources\t|产品的资源\n|src/test/java\t|Java 测试源代码\n|src/test/resources\t|测试资源\n|src/sourceSet/java\t|给定的源集的Java源代码\n|src/sourceSet/resources\t|给定的源集的资源\n\n### 自带任务列举\n\n|任务名称|依赖于|类型|描述|\n|:----|:----|:----|:-----|\n|compileJava|产生编译类路径中的所有任务。这包括了用于编译配置中包含的项目依赖关系的jar任务。|JavaCompile|使用 javac 编译产品中的 Java 源文件。\n|processResources|\t-| Copy\t|把生产资源文件拷贝到生产的类目录中。|\n|classes|compileJava和processResources。一些插件添加了额外的编译任务|Task|组装生产的类目录。\n|compileTestJava\t|compile，再加上所有能产生测试编译类路径的任务。\t|JavaCompile|\t使用 javac 编译 Java 的测试源文件。\n|processTestResources|\t-\t|Copy|\t把测试的资源文件拷贝到测试的类目录中。\n|testClasses\t|compileTestJava和processTestResources。一些插件添加了额外的测试编译任务。\tTask\t|组装测试的类目录。\n|jar\t|compile\t|Jar\t|组装 JAR 文件\n|javadoc\t|compile\t|Javadoc\t|使用 Javadoc 生成生产的 Java 源代码的API文档\n|test\t|compile， compileTest，再加上所有产生测试运行时类路径的任务。\t|Test\t|使用 JUnit 或 TestNG运行单元测试。\n|uploadArchives\t|使用archives的配置生成构件的任务，包括jar。\t|Upload\t|使用archives配置上传包括 JAR 文件的构件。\n|clean\t|-\t|Delete\t|删除项目的build目录。\n|cleanTaskName|\t-\t|Delete\t|删除由指定的任务所产生的输出文件。例如， cleanJar将删除由jar任务中所创建的 JAR 文件，cleanTest将删除由test任务所创建的测试结果。\n\n### 源集概念\n\nJava 插件引入了一个源集的概念。一个源集只是一组用于编译并一起执行的源文件。这些源文件可能包括 Java 源代码文件和资源文件。其他有一些插件添加了在源集里包含 Groovy 和 Scala 的源代码文件的能力。一个源集有一个相关联的编译类路径和运行时类路径。\n\n源集的一个用途是，把源文件进行逻辑上的分组，以描述它们的目的。例如，你可能会使用一个源集来定义一个集成测试套件，或者你可能会使用单独的源集来定义你的项目的 API 和实现类。\n\nJava 插件定义了两个标准的源集，分别是main和test。main源集包含你产品的源代码，它们将被编译并组装成一个 JAR 文件。test源集包含你的单元测试的源代码，它们将被编译并使用 JUnit 或 TestNG来执行\n\n### Java 插件-源集任务\n\n对于每个你添加到该项目中的源集，Java 插件将添加以下的编译任务：\n\n|任务名称|依赖于|类型|描述|\n|:----|:----|:----|:-----|\n|compileSourceSetJava\t|所有产生源集编译类路径的任务。\t|JavaCompile\t|使用 javac 编译给定的源集中的 Java 源文件。\n|processSourceSetResources\t|-\t|Copy\t|把给定的源集的资源文件拷贝到类目录中。\n|sourceSetClasses\t|compileSourceSetJava 和 processSourceSetResources。某些插件还为源集添加了额外的编译任务。\t|Task\t|组装给定源集的类目录。\n\n\n### Java 插件-生命周期任务\n\nJava 插件还增加了大量的任务构成该项目的生命周期：\n\n|任务名称|依赖于|类型|描述|\n|:----|:----|:----:|:-----|\n|assemble\t|项目中的所有归档项目，包括jar任务。某些插件还向项目添加额外的归档任务。\t|Task\t|组装项目中所有的归类文件。\n|check\t|项目中的所有核查项目，包括test任务。某些插件还向项目添加额外的核查任务。\t|Task\t|执行项目中所有的核查任务。\n|build\t|check 和 assemble\t|Task\t|执行项目的完事构建。\n|buildNeeded\t|build任务，以及在testRuntime配置的所有项目库依赖项的build任务。\t|Task\t|执行项目本身及它所依赖的其他所有项目的完整构建。\n|buildDependents\t|build任务，以及在testRuntime配置中对此项目有库依赖的所有项目的build任务。\t|Task\t|执行项目本身及依赖它的其他所有项目的完整构建。\n|buildConfigurationName\t|使用配置ConfigurationName生成构件的任务。\t|Task\t|组装指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。\n|uploadConfigurationName\t|使用配置ConfigurationName上传构件的任务。\t|Upload\t|组装并上传指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。\n\n### Java插件-任务依赖关系图\n\n![Java插件-任务依赖关系图](http://oaefo3hoy.bkt.clouddn.com/16-7-17/48492582.jpg)\n\n\n### Java插件 ​​- 依赖配置\n\nJava插件向项目添加了许多依赖配置，如下图所示。它对一些任务指定了这些配置，如compileJava和test。\n\n|名称|继承自|在哪些任务中使用|意义|\n|----|------|----------------|----|\n|compile|\t-\t|compileJava\t|编译时依赖\n|runtime\t|compile\t|-\t|运行时依赖\n|testCompile|\tcompile\t|compileTestJava\t|用于编译测试的其他依赖\n|testRuntime\t|runtime, testCompile\t|test\t|只用于运行测试的其他依赖\n|archives\t|-\t|uploadArchives\t|由本项目生产的构件（如jar包）。\n|default\t|runtime\t|-\t|本项目上的默认项目依赖配置。包含本项目运行时所需要的构件和依赖。\n\n\nJava插件 ​​- 依赖配置 对于每个你添加到项目中的源集，Java插件都会添加以下的依赖配置：\n\n![默认添加的依赖配置](http://oaefo3hoy.bkt.clouddn.com/16-7-17/64820034.jpg)\n\n### Java插件的常规属性\n\nJava插件向项目添加了许多常规属性，如下表格所示。您可以在构建脚本中使用这些属性，就像它们是project对象的属性一样\n\n|属性名称|类型|默认值|描述|\n|:----|:----|:----:|:-----|\n|reportsDirName\t|String\t|reports\t|相对于build目录的目录名称，报告将生成到此目录。\n|reportsDir\t|File (read-only)\t|buildDir/reportsDirName|\t报告将生成到此目录。\n|testResultsDirName\t|String\t|test-results\t|相对于build目录的目录名称，测试报告的.xml文件将生成到此目录。\n|testResultsDir\t|File (read-only)\t|buildDir/testResultsDirName\t|测试报告的.xml文件将生成到此目录。|\n|testReportDirName\t|String\t|tests\t|相对于build目录的目录名称，测试报告将生成到此目录。\n|testReportDir\t|File (read-only)\t|reportsDir/testReportDirName\t|测试报告生成到此目录。\n|libsDirName\t|String\t|libs\t|相对于build目录的目录名称，类库将生成到此目录中。\n|libsDir\t|File (read-only)|\tbuildDir/libsDirName\t|类库将生成到此目录中。\n|distsDirName\t|String\t|distributions\t|相对于build目录的目录名称，发布的文件将生成到此目录中。\n|distsDir\t|File (read-only)\t|buildDir/distsDirName\t|要发布的文件将生成到此目录。\n|docsDirName\t|String\t|docs\t|相对于build目录的目录名称，文档将生成到此目录。\n|docsDir|\tFile (read-only)\t|buildDir/docsDirName\t|要生成文档的目录。\n|dependencyCacheDirName\t|String\t|dependency-cache\t|相对于build目录的目录名称，该目录用于缓存源代码的依赖信息。\n|dependencyCacheDir\t|File (read-only)\t|buildDir/dependencyCacheDirName\t|该目录用于缓存源代码的依赖信息。\n|sourceSets\t|SourceSetContainer (read-only)\t|非空\t|包含项目的源集。\n|sourceCompatibility\t|JavaVersion.\t|可以使用字符串或数字来设置，例如\"1.5\"或1.5。\t|当前JVM所使用的值 当编译Java源代码时所使用的Java版本兼容性。\n|targetCompatibility|\tJavaVersion.\t|可以使用字符串或数字来设置，例如\"1.5\"或1.5。\t|sourceCompatibility 要生成的类的 Java 版本。\n|archivesBaseName\t|String\t|projectName|\t像JAR或ZIP文件这样的构件的basename\n|manifest\t|Manifest\t|一个空的清单\t|要包括的所有 JAR 文件的清单。\n\n\n### 使用源集\n\n你可以使用sourceSets属性访问项目的源集。这是项目的源集的容器，它的类型是 SourceSetContainer。除此之后，还有一个sourceSets{}的脚本块，可以传入一个闭包来配置源集容器。源集容器的使用方式几乎与其他容器一样，例如tasks。\n\n示例代码：访问源集的属性\n```gradle\n// Various ways to access the main source set\nprintln sourceSets.main.output.classesDir\nprintln sourceSets['main'].output.classesDir\nsourceSets {\n    println main.output.classesDir\n}\nsourceSets {\n    main {\n        println output.classesDir\n    }\n}\n\n// Iterate over the source sets\nsourceSets.all {\n    println name\n}\n```\n\n示例代码：配置源集的源代码目录\n\nbuild.gradle文件\n```gradle\nsourceSets {\n    main {\n        java {\n            srcDir 'src/java'\n        }\n        resources {\n            srcDir 'src/resources'\n        }\n    }\n}\n```\n\n\n#### 源集属性列举\n\n下表列出了一些重要的源集属性。我们可以在SourceSet的 API 文档中查看更多的详细信息。\n\n|属性名称|类型|默认值|描述\n|:--------|:----:|:------:|:----\n|name\t|String (read-only)\t|非空\t|用来确定一个源集的源集名称。\n|output\t|SourceSetOutput (read-only)\t|非空\t|源集的输出文件，包含它编译过的类和资源。\n|output.classesDir|\tFile\t|*buildDir/classes/name*\t|要生成的该源集的类的目录。\n|output.resourcesDir\t|File\t|*buildDir/resources/name*\t|要生成的该源集的资源的目录。\n|compileClasspath\t|FileCollection |compileSourceSet 配置 |该类路径在编译该源集的源文件时使用。\n|runtimeClasspath |FileCollection |output + runtimeSourceSet 配置|该类路径在执行该源集的类时使用。\n|java |SourceDirectorySet (read-only)| 非空 |该源集的Java源文件。仅包含Java源文件目录里的.java文件，并排除其他所有文件。\n|java.srcDirs |Set<File> 可指定一组输入文件来设置|[*projectDir/src/name/java*]|该源目录包含了此源集的所有Java源文件。\n|resources |SourceDirectorySet (read-only) |非空 |此源集的资源文件。仅包含资源文件，并且排除在资源源目录中找到的所有 .java文件。其他插件，如Groovy 插件，会从该集合中排除其他类型的文件。\n|resources.srcDirs| Set<File> 指定一组输入文件来设置。| [*projectDir/src/name/resources*] |该源目录包含了此源集的资源文件。\n|allJava |SourceDirectorySet (read-only) |java |该源集的所有.java 文件。有些插件，如Groovy 插件，会从该集合中增加其他的Java源文件。\n|allSource |SourceDirectorySet (read-only)| resources + java |该源集的所有源文件。包含所有的资源文件和Java源文件。有些插件，如Groovy 插件，会从该集合中增加其他的源文件。\n\n\n### 多项目构建\n\n### 创建多项目总结\n\n1. 一个多项目构建必须在根项目的根目录下包含settings.gradle文件，因为它指明了那些包含在多项目构建中的项目。\n\n2. 如果需要在多项目构建的所有项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用allprojects)\n\n3. 如果需要在根项目的子项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用subprojects)\n","slug":"gradle-usage","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsw00016qk5c7y0w8eij","content":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Java 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。</p>\n<h3 id=\"如何引入\"><a href=\"#如何引入\" class=\"headerlink\" title=\"如何引入\"></a>如何引入</h3><p>要使用 Java 插件，请在构建脚本(build.gradle)中加入：</p>\n<pre><code class=\"groovy\">apply plugin: &#39;java&#39;\n</code></pre>\n<a id=\"more\"></a>\n<h3 id=\"Java项目默认布局\"><a href=\"#Java项目默认布局\" class=\"headerlink\" title=\"Java项目默认布局\"></a>Java项目默认布局</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">目录</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">src/main/java</td>\n<td style=\"text-align:left\">产品的Java源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/main/resources</td>\n<td style=\"text-align:left\">产品的资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/test/java</td>\n<td style=\"text-align:left\">Java 测试源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/test/resources</td>\n<td style=\"text-align:left\">测试资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/sourceSet/java</td>\n<td style=\"text-align:left\">给定的源集的Java源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/sourceSet/resources</td>\n<td style=\"text-align:left\">给定的源集的资源</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"自带任务列举\"><a href=\"#自带任务列举\" class=\"headerlink\" title=\"自带任务列举\"></a>自带任务列举</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">任务名称</th>\n<th style=\"text-align:left\">依赖于</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">compileJava</td>\n<td style=\"text-align:left\">产生编译类路径中的所有任务。这包括了用于编译配置中包含的项目依赖关系的jar任务。</td>\n<td style=\"text-align:left\">JavaCompile</td>\n<td style=\"text-align:left\">使用 javac 编译产品中的 Java 源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processResources</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Copy</td>\n<td style=\"text-align:left\">把生产资源文件拷贝到生产的类目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">classes</td>\n<td style=\"text-align:left\">compileJava和processResources。一些插件添加了额外的编译任务</td>\n<td style=\"text-align:left\">Task</td>\n<td style=\"text-align:left\">组装生产的类目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">compileTestJava</td>\n<td style=\"text-align:left\">compile，再加上所有能产生测试编译类路径的任务。</td>\n<td style=\"text-align:left\">JavaCompile</td>\n<td style=\"text-align:left\">使用 javac 编译 Java 的测试源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processTestResources</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Copy</td>\n<td style=\"text-align:left\">把测试的资源文件拷贝到测试的类目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testClasses</td>\n<td style=\"text-align:left\">compileTestJava和processTestResources。一些插件添加了额外的测试编译任务。    Task</td>\n<td style=\"text-align:left\">组装测试的类目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jar</td>\n<td style=\"text-align:left\">compile</td>\n<td style=\"text-align:left\">Jar</td>\n<td style=\"text-align:left\">组装 JAR 文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">javadoc</td>\n<td style=\"text-align:left\">compile</td>\n<td style=\"text-align:left\">Javadoc</td>\n<td style=\"text-align:left\">使用 Javadoc 生成生产的 Java 源代码的API文档</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">test</td>\n<td style=\"text-align:left\">compile， compileTest，再加上所有产生测试运行时类路径的任务。</td>\n<td style=\"text-align:left\">Test</td>\n<td style=\"text-align:left\">使用 JUnit 或 TestNG运行单元测试。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">uploadArchives</td>\n<td style=\"text-align:left\">使用archives的配置生成构件的任务，包括jar。</td>\n<td style=\"text-align:left\">Upload</td>\n<td style=\"text-align:left\">使用archives配置上传包括 JAR 文件的构件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">clean</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Delete</td>\n<td style=\"text-align:left\">删除项目的build目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cleanTaskName</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Delete</td>\n<td style=\"text-align:left\">删除由指定的任务所产生的输出文件。例如， cleanJar将删除由jar任务中所创建的 JAR 文件，cleanTest将删除由test任务所创建的测试结果。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"源集概念\"><a href=\"#源集概念\" class=\"headerlink\" title=\"源集概念\"></a>源集概念</h3><p>Java 插件引入了一个源集的概念。一个源集只是一组用于编译并一起执行的源文件。这些源文件可能包括 Java 源代码文件和资源文件。其他有一些插件添加了在源集里包含 Groovy 和 Scala 的源代码文件的能力。一个源集有一个相关联的编译类路径和运行时类路径。</p>\n<p>源集的一个用途是，把源文件进行逻辑上的分组，以描述它们的目的。例如，你可能会使用一个源集来定义一个集成测试套件，或者你可能会使用单独的源集来定义你的项目的 API 和实现类。</p>\n<p>Java 插件定义了两个标准的源集，分别是main和test。main源集包含你产品的源代码，它们将被编译并组装成一个 JAR 文件。test源集包含你的单元测试的源代码，它们将被编译并使用 JUnit 或 TestNG来执行</p>\n<h3 id=\"Java-插件-源集任务\"><a href=\"#Java-插件-源集任务\" class=\"headerlink\" title=\"Java 插件-源集任务\"></a>Java 插件-源集任务</h3><p>对于每个你添加到该项目中的源集，Java 插件将添加以下的编译任务：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">任务名称</th>\n<th style=\"text-align:left\">依赖于</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">compileSourceSetJava</td>\n<td style=\"text-align:left\">所有产生源集编译类路径的任务。</td>\n<td style=\"text-align:left\">JavaCompile</td>\n<td style=\"text-align:left\">使用 javac 编译给定的源集中的 Java 源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processSourceSetResources</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Copy</td>\n<td style=\"text-align:left\">把给定的源集的资源文件拷贝到类目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sourceSetClasses</td>\n<td style=\"text-align:left\">compileSourceSetJava 和 processSourceSetResources。某些插件还为源集添加了额外的编译任务。</td>\n<td style=\"text-align:left\">Task</td>\n<td style=\"text-align:left\">组装给定源集的类目录。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Java-插件-生命周期任务\"><a href=\"#Java-插件-生命周期任务\" class=\"headerlink\" title=\"Java 插件-生命周期任务\"></a>Java 插件-生命周期任务</h3><p>Java 插件还增加了大量的任务构成该项目的生命周期：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">任务名称</th>\n<th style=\"text-align:left\">依赖于</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">assemble</td>\n<td style=\"text-align:left\">项目中的所有归档项目，包括jar任务。某些插件还向项目添加额外的归档任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">组装项目中所有的归类文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">check</td>\n<td style=\"text-align:left\">项目中的所有核查项目，包括test任务。某些插件还向项目添加额外的核查任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目中所有的核查任务。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">build</td>\n<td style=\"text-align:left\">check 和 assemble</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目的完事构建。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">buildNeeded</td>\n<td style=\"text-align:left\">build任务，以及在testRuntime配置的所有项目库依赖项的build任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目本身及它所依赖的其他所有项目的完整构建。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">buildDependents</td>\n<td style=\"text-align:left\">build任务，以及在testRuntime配置中对此项目有库依赖的所有项目的build任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目本身及依赖它的其他所有项目的完整构建。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">buildConfigurationName</td>\n<td style=\"text-align:left\">使用配置ConfigurationName生成构件的任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">组装指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">uploadConfigurationName</td>\n<td style=\"text-align:left\">使用配置ConfigurationName上传构件的任务。</td>\n<td style=\"text-align:center\">Upload</td>\n<td style=\"text-align:left\">组装并上传指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Java插件-任务依赖关系图\"><a href=\"#Java插件-任务依赖关系图\" class=\"headerlink\" title=\"Java插件-任务依赖关系图\"></a>Java插件-任务依赖关系图</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-7-17/48492582.jpg\" alt=\"Java插件-任务依赖关系图\"></p>\n<h3 id=\"Java插件-​​-依赖配置\"><a href=\"#Java插件-​​-依赖配置\" class=\"headerlink\" title=\"Java插件 ​​- 依赖配置\"></a>Java插件 ​​- 依赖配置</h3><p>Java插件向项目添加了许多依赖配置，如下图所示。它对一些任务指定了这些配置，如compileJava和test。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>继承自</th>\n<th>在哪些任务中使用</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>compile</td>\n<td>-</td>\n<td>compileJava</td>\n<td>编译时依赖</td>\n</tr>\n<tr>\n<td>runtime</td>\n<td>compile</td>\n<td>-</td>\n<td>运行时依赖</td>\n</tr>\n<tr>\n<td>testCompile</td>\n<td>compile</td>\n<td>compileTestJava</td>\n<td>用于编译测试的其他依赖</td>\n</tr>\n<tr>\n<td>testRuntime</td>\n<td>runtime, testCompile</td>\n<td>test</td>\n<td>只用于运行测试的其他依赖</td>\n</tr>\n<tr>\n<td>archives</td>\n<td>-</td>\n<td>uploadArchives</td>\n<td>由本项目生产的构件（如jar包）。</td>\n</tr>\n<tr>\n<td>default</td>\n<td>runtime</td>\n<td>-</td>\n<td>本项目上的默认项目依赖配置。包含本项目运行时所需要的构件和依赖。</td>\n</tr>\n</tbody>\n</table>\n<p>Java插件 ​​- 依赖配置 对于每个你添加到项目中的源集，Java插件都会添加以下的依赖配置：</p>\n<p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-7-17/64820034.jpg\" alt=\"默认添加的依赖配置\"></p>\n<h3 id=\"Java插件的常规属性\"><a href=\"#Java插件的常规属性\" class=\"headerlink\" title=\"Java插件的常规属性\"></a>Java插件的常规属性</h3><p>Java插件向项目添加了许多常规属性，如下表格所示。您可以在构建脚本中使用这些属性，就像它们是project对象的属性一样</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性名称</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">reportsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">reports</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，报告将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">reportsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/reportsDirName</td>\n<td style=\"text-align:left\">报告将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testResultsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">test-results</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，测试报告的.xml文件将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testResultsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/testResultsDirName</td>\n<td style=\"text-align:left\">测试报告的.xml文件将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testReportDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">tests</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，测试报告将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testReportDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">reportsDir/testReportDirName</td>\n<td style=\"text-align:left\">测试报告生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">libsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">libs</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，类库将生成到此目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">libsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/libsDirName</td>\n<td style=\"text-align:left\">类库将生成到此目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">distsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">distributions</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，发布的文件将生成到此目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">distsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/distsDirName</td>\n<td style=\"text-align:left\">要发布的文件将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">docsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">docs</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，文档将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">docsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/docsDirName</td>\n<td style=\"text-align:left\">要生成文档的目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dependencyCacheDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">dependency-cache</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，该目录用于缓存源代码的依赖信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dependencyCacheDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/dependencyCacheDirName</td>\n<td style=\"text-align:left\">该目录用于缓存源代码的依赖信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sourceSets</td>\n<td style=\"text-align:left\">SourceSetContainer (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">包含项目的源集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sourceCompatibility</td>\n<td style=\"text-align:left\">JavaVersion.</td>\n<td style=\"text-align:center\">可以使用字符串或数字来设置，例如”1.5”或1.5。</td>\n<td style=\"text-align:left\">当前JVM所使用的值 当编译Java源代码时所使用的Java版本兼容性。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">targetCompatibility</td>\n<td style=\"text-align:left\">JavaVersion.</td>\n<td style=\"text-align:center\">可以使用字符串或数字来设置，例如”1.5”或1.5。</td>\n<td style=\"text-align:left\">sourceCompatibility 要生成的类的 Java 版本。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">archivesBaseName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">projectName</td>\n<td style=\"text-align:left\">像JAR或ZIP文件这样的构件的basename</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">manifest</td>\n<td style=\"text-align:left\">Manifest</td>\n<td style=\"text-align:center\">一个空的清单</td>\n<td style=\"text-align:left\">要包括的所有 JAR 文件的清单。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用源集\"><a href=\"#使用源集\" class=\"headerlink\" title=\"使用源集\"></a>使用源集</h3><p>你可以使用sourceSets属性访问项目的源集。这是项目的源集的容器，它的类型是 SourceSetContainer。除此之后，还有一个sourceSets{}的脚本块，可以传入一个闭包来配置源集容器。源集容器的使用方式几乎与其他容器一样，例如tasks。</p>\n<p>示例代码：访问源集的属性</p>\n<pre><code class=\"gradle\">// Various ways to access the main source set\nprintln sourceSets.main.output.classesDir\nprintln sourceSets[&#39;main&#39;].output.classesDir\nsourceSets {\n    println main.output.classesDir\n}\nsourceSets {\n    main {\n        println output.classesDir\n    }\n}\n\n// Iterate over the source sets\nsourceSets.all {\n    println name\n}\n</code></pre>\n<p>示例代码：配置源集的源代码目录</p>\n<p>build.gradle文件</p>\n<pre><code class=\"gradle\">sourceSets {\n    main {\n        java {\n            srcDir &#39;src/java&#39;\n        }\n        resources {\n            srcDir &#39;src/resources&#39;\n        }\n    }\n}\n</code></pre>\n<h4 id=\"源集属性列举\"><a href=\"#源集属性列举\" class=\"headerlink\" title=\"源集属性列举\"></a>源集属性列举</h4><p>下表列出了一些重要的源集属性。我们可以在SourceSet的 API 文档中查看更多的详细信息。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性名称</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">name</td>\n<td style=\"text-align:center\">String (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">用来确定一个源集的源集名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">output</td>\n<td style=\"text-align:center\">SourceSetOutput (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">源集的输出文件，包含它编译过的类和资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">output.classesDir</td>\n<td style=\"text-align:center\">File</td>\n<td style=\"text-align:center\"><em>buildDir/classes/name</em></td>\n<td style=\"text-align:left\">要生成的该源集的类的目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">output.resourcesDir</td>\n<td style=\"text-align:center\">File</td>\n<td style=\"text-align:center\"><em>buildDir/resources/name</em></td>\n<td style=\"text-align:left\">要生成的该源集的资源的目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">compileClasspath</td>\n<td style=\"text-align:center\">FileCollection</td>\n<td style=\"text-align:center\">compileSourceSet 配置</td>\n<td style=\"text-align:left\">该类路径在编译该源集的源文件时使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">runtimeClasspath</td>\n<td style=\"text-align:center\">FileCollection</td>\n<td style=\"text-align:center\">output + runtimeSourceSet 配置</td>\n<td style=\"text-align:left\">该类路径在执行该源集的类时使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">java</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">该源集的Java源文件。仅包含Java源文件目录里的.java文件，并排除其他所有文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">java.srcDirs</td>\n<td style=\"text-align:center\">Set<file> 可指定一组输入文件来设置</file></td>\n<td style=\"text-align:center\">[<em>projectDir/src/name/java</em>]</td>\n<td style=\"text-align:left\">该源目录包含了此源集的所有Java源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resources</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">此源集的资源文件。仅包含资源文件，并且排除在资源源目录中找到的所有 .java文件。其他插件，如Groovy 插件，会从该集合中排除其他类型的文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resources.srcDirs</td>\n<td style=\"text-align:center\">Set<file> 指定一组输入文件来设置。</file></td>\n<td style=\"text-align:center\">[<em>projectDir/src/name/resources</em>]</td>\n<td style=\"text-align:left\">该源目录包含了此源集的资源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">allJava</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">java</td>\n<td style=\"text-align:left\">该源集的所有.java 文件。有些插件，如Groovy 插件，会从该集合中增加其他的Java源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">allSource</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">resources + java</td>\n<td style=\"text-align:left\">该源集的所有源文件。包含所有的资源文件和Java源文件。有些插件，如Groovy 插件，会从该集合中增加其他的源文件。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"多项目构建\"><a href=\"#多项目构建\" class=\"headerlink\" title=\"多项目构建\"></a>多项目构建</h3><h3 id=\"创建多项目总结\"><a href=\"#创建多项目总结\" class=\"headerlink\" title=\"创建多项目总结\"></a>创建多项目总结</h3><ol>\n<li><p>一个多项目构建必须在根项目的根目录下包含settings.gradle文件，因为它指明了那些包含在多项目构建中的项目。</p>\n</li>\n<li><p>如果需要在多项目构建的所有项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用allprojects)</p>\n</li>\n<li><p>如果需要在根项目的子项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用subprojects)</p>\n</li>\n</ol>\n","excerpt":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Java 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。</p>\n<h3 id=\"如何引入\"><a href=\"#如何引入\" class=\"headerlink\" title=\"如何引入\"></a>如何引入</h3><p>要使用 Java 插件，请在构建脚本(build.gradle)中加入：</p>\n<pre><code class=\"groovy\">apply plugin: &#39;java&#39;\n</code></pre>","more":"<h3 id=\"Java项目默认布局\"><a href=\"#Java项目默认布局\" class=\"headerlink\" title=\"Java项目默认布局\"></a>Java项目默认布局</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">目录</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">src/main/java</td>\n<td style=\"text-align:left\">产品的Java源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/main/resources</td>\n<td style=\"text-align:left\">产品的资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/test/java</td>\n<td style=\"text-align:left\">Java 测试源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/test/resources</td>\n<td style=\"text-align:left\">测试资源</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/sourceSet/java</td>\n<td style=\"text-align:left\">给定的源集的Java源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">src/sourceSet/resources</td>\n<td style=\"text-align:left\">给定的源集的资源</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"自带任务列举\"><a href=\"#自带任务列举\" class=\"headerlink\" title=\"自带任务列举\"></a>自带任务列举</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">任务名称</th>\n<th style=\"text-align:left\">依赖于</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">compileJava</td>\n<td style=\"text-align:left\">产生编译类路径中的所有任务。这包括了用于编译配置中包含的项目依赖关系的jar任务。</td>\n<td style=\"text-align:left\">JavaCompile</td>\n<td style=\"text-align:left\">使用 javac 编译产品中的 Java 源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processResources</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Copy</td>\n<td style=\"text-align:left\">把生产资源文件拷贝到生产的类目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">classes</td>\n<td style=\"text-align:left\">compileJava和processResources。一些插件添加了额外的编译任务</td>\n<td style=\"text-align:left\">Task</td>\n<td style=\"text-align:left\">组装生产的类目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">compileTestJava</td>\n<td style=\"text-align:left\">compile，再加上所有能产生测试编译类路径的任务。</td>\n<td style=\"text-align:left\">JavaCompile</td>\n<td style=\"text-align:left\">使用 javac 编译 Java 的测试源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processTestResources</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Copy</td>\n<td style=\"text-align:left\">把测试的资源文件拷贝到测试的类目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testClasses</td>\n<td style=\"text-align:left\">compileTestJava和processTestResources。一些插件添加了额外的测试编译任务。    Task</td>\n<td style=\"text-align:left\">组装测试的类目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jar</td>\n<td style=\"text-align:left\">compile</td>\n<td style=\"text-align:left\">Jar</td>\n<td style=\"text-align:left\">组装 JAR 文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">javadoc</td>\n<td style=\"text-align:left\">compile</td>\n<td style=\"text-align:left\">Javadoc</td>\n<td style=\"text-align:left\">使用 Javadoc 生成生产的 Java 源代码的API文档</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">test</td>\n<td style=\"text-align:left\">compile， compileTest，再加上所有产生测试运行时类路径的任务。</td>\n<td style=\"text-align:left\">Test</td>\n<td style=\"text-align:left\">使用 JUnit 或 TestNG运行单元测试。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">uploadArchives</td>\n<td style=\"text-align:left\">使用archives的配置生成构件的任务，包括jar。</td>\n<td style=\"text-align:left\">Upload</td>\n<td style=\"text-align:left\">使用archives配置上传包括 JAR 文件的构件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">clean</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Delete</td>\n<td style=\"text-align:left\">删除项目的build目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">cleanTaskName</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Delete</td>\n<td style=\"text-align:left\">删除由指定的任务所产生的输出文件。例如， cleanJar将删除由jar任务中所创建的 JAR 文件，cleanTest将删除由test任务所创建的测试结果。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"源集概念\"><a href=\"#源集概念\" class=\"headerlink\" title=\"源集概念\"></a>源集概念</h3><p>Java 插件引入了一个源集的概念。一个源集只是一组用于编译并一起执行的源文件。这些源文件可能包括 Java 源代码文件和资源文件。其他有一些插件添加了在源集里包含 Groovy 和 Scala 的源代码文件的能力。一个源集有一个相关联的编译类路径和运行时类路径。</p>\n<p>源集的一个用途是，把源文件进行逻辑上的分组，以描述它们的目的。例如，你可能会使用一个源集来定义一个集成测试套件，或者你可能会使用单独的源集来定义你的项目的 API 和实现类。</p>\n<p>Java 插件定义了两个标准的源集，分别是main和test。main源集包含你产品的源代码，它们将被编译并组装成一个 JAR 文件。test源集包含你的单元测试的源代码，它们将被编译并使用 JUnit 或 TestNG来执行</p>\n<h3 id=\"Java-插件-源集任务\"><a href=\"#Java-插件-源集任务\" class=\"headerlink\" title=\"Java 插件-源集任务\"></a>Java 插件-源集任务</h3><p>对于每个你添加到该项目中的源集，Java 插件将添加以下的编译任务：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">任务名称</th>\n<th style=\"text-align:left\">依赖于</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">compileSourceSetJava</td>\n<td style=\"text-align:left\">所有产生源集编译类路径的任务。</td>\n<td style=\"text-align:left\">JavaCompile</td>\n<td style=\"text-align:left\">使用 javac 编译给定的源集中的 Java 源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processSourceSetResources</td>\n<td style=\"text-align:left\">-</td>\n<td style=\"text-align:left\">Copy</td>\n<td style=\"text-align:left\">把给定的源集的资源文件拷贝到类目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sourceSetClasses</td>\n<td style=\"text-align:left\">compileSourceSetJava 和 processSourceSetResources。某些插件还为源集添加了额外的编译任务。</td>\n<td style=\"text-align:left\">Task</td>\n<td style=\"text-align:left\">组装给定源集的类目录。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Java-插件-生命周期任务\"><a href=\"#Java-插件-生命周期任务\" class=\"headerlink\" title=\"Java 插件-生命周期任务\"></a>Java 插件-生命周期任务</h3><p>Java 插件还增加了大量的任务构成该项目的生命周期：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">任务名称</th>\n<th style=\"text-align:left\">依赖于</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">assemble</td>\n<td style=\"text-align:left\">项目中的所有归档项目，包括jar任务。某些插件还向项目添加额外的归档任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">组装项目中所有的归类文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">check</td>\n<td style=\"text-align:left\">项目中的所有核查项目，包括test任务。某些插件还向项目添加额外的核查任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目中所有的核查任务。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">build</td>\n<td style=\"text-align:left\">check 和 assemble</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目的完事构建。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">buildNeeded</td>\n<td style=\"text-align:left\">build任务，以及在testRuntime配置的所有项目库依赖项的build任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目本身及它所依赖的其他所有项目的完整构建。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">buildDependents</td>\n<td style=\"text-align:left\">build任务，以及在testRuntime配置中对此项目有库依赖的所有项目的build任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">执行项目本身及依赖它的其他所有项目的完整构建。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">buildConfigurationName</td>\n<td style=\"text-align:left\">使用配置ConfigurationName生成构件的任务。</td>\n<td style=\"text-align:center\">Task</td>\n<td style=\"text-align:left\">组装指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">uploadConfigurationName</td>\n<td style=\"text-align:left\">使用配置ConfigurationName上传构件的任务。</td>\n<td style=\"text-align:center\">Upload</td>\n<td style=\"text-align:left\">组装并上传指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Java插件-任务依赖关系图\"><a href=\"#Java插件-任务依赖关系图\" class=\"headerlink\" title=\"Java插件-任务依赖关系图\"></a>Java插件-任务依赖关系图</h3><p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-7-17/48492582.jpg\" alt=\"Java插件-任务依赖关系图\"></p>\n<h3 id=\"Java插件-​​-依赖配置\"><a href=\"#Java插件-​​-依赖配置\" class=\"headerlink\" title=\"Java插件 ​​- 依赖配置\"></a>Java插件 ​​- 依赖配置</h3><p>Java插件向项目添加了许多依赖配置，如下图所示。它对一些任务指定了这些配置，如compileJava和test。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>继承自</th>\n<th>在哪些任务中使用</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>compile</td>\n<td>-</td>\n<td>compileJava</td>\n<td>编译时依赖</td>\n</tr>\n<tr>\n<td>runtime</td>\n<td>compile</td>\n<td>-</td>\n<td>运行时依赖</td>\n</tr>\n<tr>\n<td>testCompile</td>\n<td>compile</td>\n<td>compileTestJava</td>\n<td>用于编译测试的其他依赖</td>\n</tr>\n<tr>\n<td>testRuntime</td>\n<td>runtime, testCompile</td>\n<td>test</td>\n<td>只用于运行测试的其他依赖</td>\n</tr>\n<tr>\n<td>archives</td>\n<td>-</td>\n<td>uploadArchives</td>\n<td>由本项目生产的构件（如jar包）。</td>\n</tr>\n<tr>\n<td>default</td>\n<td>runtime</td>\n<td>-</td>\n<td>本项目上的默认项目依赖配置。包含本项目运行时所需要的构件和依赖。</td>\n</tr>\n</tbody>\n</table>\n<p>Java插件 ​​- 依赖配置 对于每个你添加到项目中的源集，Java插件都会添加以下的依赖配置：</p>\n<p><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-7-17/64820034.jpg\" alt=\"默认添加的依赖配置\"></p>\n<h3 id=\"Java插件的常规属性\"><a href=\"#Java插件的常规属性\" class=\"headerlink\" title=\"Java插件的常规属性\"></a>Java插件的常规属性</h3><p>Java插件向项目添加了许多常规属性，如下表格所示。您可以在构建脚本中使用这些属性，就像它们是project对象的属性一样</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性名称</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">reportsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">reports</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，报告将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">reportsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/reportsDirName</td>\n<td style=\"text-align:left\">报告将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testResultsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">test-results</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，测试报告的.xml文件将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testResultsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/testResultsDirName</td>\n<td style=\"text-align:left\">测试报告的.xml文件将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testReportDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">tests</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，测试报告将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">testReportDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">reportsDir/testReportDirName</td>\n<td style=\"text-align:left\">测试报告生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">libsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">libs</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，类库将生成到此目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">libsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/libsDirName</td>\n<td style=\"text-align:left\">类库将生成到此目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">distsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">distributions</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，发布的文件将生成到此目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">distsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/distsDirName</td>\n<td style=\"text-align:left\">要发布的文件将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">docsDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">docs</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，文档将生成到此目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">docsDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/docsDirName</td>\n<td style=\"text-align:left\">要生成文档的目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dependencyCacheDirName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">dependency-cache</td>\n<td style=\"text-align:left\">相对于build目录的目录名称，该目录用于缓存源代码的依赖信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dependencyCacheDir</td>\n<td style=\"text-align:left\">File (read-only)</td>\n<td style=\"text-align:center\">buildDir/dependencyCacheDirName</td>\n<td style=\"text-align:left\">该目录用于缓存源代码的依赖信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sourceSets</td>\n<td style=\"text-align:left\">SourceSetContainer (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">包含项目的源集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sourceCompatibility</td>\n<td style=\"text-align:left\">JavaVersion.</td>\n<td style=\"text-align:center\">可以使用字符串或数字来设置，例如”1.5”或1.5。</td>\n<td style=\"text-align:left\">当前JVM所使用的值 当编译Java源代码时所使用的Java版本兼容性。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">targetCompatibility</td>\n<td style=\"text-align:left\">JavaVersion.</td>\n<td style=\"text-align:center\">可以使用字符串或数字来设置，例如”1.5”或1.5。</td>\n<td style=\"text-align:left\">sourceCompatibility 要生成的类的 Java 版本。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">archivesBaseName</td>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:center\">projectName</td>\n<td style=\"text-align:left\">像JAR或ZIP文件这样的构件的basename</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">manifest</td>\n<td style=\"text-align:left\">Manifest</td>\n<td style=\"text-align:center\">一个空的清单</td>\n<td style=\"text-align:left\">要包括的所有 JAR 文件的清单。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用源集\"><a href=\"#使用源集\" class=\"headerlink\" title=\"使用源集\"></a>使用源集</h3><p>你可以使用sourceSets属性访问项目的源集。这是项目的源集的容器，它的类型是 SourceSetContainer。除此之后，还有一个sourceSets{}的脚本块，可以传入一个闭包来配置源集容器。源集容器的使用方式几乎与其他容器一样，例如tasks。</p>\n<p>示例代码：访问源集的属性</p>\n<pre><code class=\"gradle\">// Various ways to access the main source set\nprintln sourceSets.main.output.classesDir\nprintln sourceSets[&#39;main&#39;].output.classesDir\nsourceSets {\n    println main.output.classesDir\n}\nsourceSets {\n    main {\n        println output.classesDir\n    }\n}\n\n// Iterate over the source sets\nsourceSets.all {\n    println name\n}\n</code></pre>\n<p>示例代码：配置源集的源代码目录</p>\n<p>build.gradle文件</p>\n<pre><code class=\"gradle\">sourceSets {\n    main {\n        java {\n            srcDir &#39;src/java&#39;\n        }\n        resources {\n            srcDir &#39;src/resources&#39;\n        }\n    }\n}\n</code></pre>\n<h4 id=\"源集属性列举\"><a href=\"#源集属性列举\" class=\"headerlink\" title=\"源集属性列举\"></a>源集属性列举</h4><p>下表列出了一些重要的源集属性。我们可以在SourceSet的 API 文档中查看更多的详细信息。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性名称</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">name</td>\n<td style=\"text-align:center\">String (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">用来确定一个源集的源集名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">output</td>\n<td style=\"text-align:center\">SourceSetOutput (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">源集的输出文件，包含它编译过的类和资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">output.classesDir</td>\n<td style=\"text-align:center\">File</td>\n<td style=\"text-align:center\"><em>buildDir/classes/name</em></td>\n<td style=\"text-align:left\">要生成的该源集的类的目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">output.resourcesDir</td>\n<td style=\"text-align:center\">File</td>\n<td style=\"text-align:center\"><em>buildDir/resources/name</em></td>\n<td style=\"text-align:left\">要生成的该源集的资源的目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">compileClasspath</td>\n<td style=\"text-align:center\">FileCollection</td>\n<td style=\"text-align:center\">compileSourceSet 配置</td>\n<td style=\"text-align:left\">该类路径在编译该源集的源文件时使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">runtimeClasspath</td>\n<td style=\"text-align:center\">FileCollection</td>\n<td style=\"text-align:center\">output + runtimeSourceSet 配置</td>\n<td style=\"text-align:left\">该类路径在执行该源集的类时使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">java</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">该源集的Java源文件。仅包含Java源文件目录里的.java文件，并排除其他所有文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">java.srcDirs</td>\n<td style=\"text-align:center\">Set<File> 可指定一组输入文件来设置</td>\n<td style=\"text-align:center\">[<em>projectDir/src/name/java</em>]</td>\n<td style=\"text-align:left\">该源目录包含了此源集的所有Java源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resources</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">非空</td>\n<td style=\"text-align:left\">此源集的资源文件。仅包含资源文件，并且排除在资源源目录中找到的所有 .java文件。其他插件，如Groovy 插件，会从该集合中排除其他类型的文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resources.srcDirs</td>\n<td style=\"text-align:center\">Set<File> 指定一组输入文件来设置。</td>\n<td style=\"text-align:center\">[<em>projectDir/src/name/resources</em>]</td>\n<td style=\"text-align:left\">该源目录包含了此源集的资源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">allJava</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">java</td>\n<td style=\"text-align:left\">该源集的所有.java 文件。有些插件，如Groovy 插件，会从该集合中增加其他的Java源文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">allSource</td>\n<td style=\"text-align:center\">SourceDirectorySet (read-only)</td>\n<td style=\"text-align:center\">resources + java</td>\n<td style=\"text-align:left\">该源集的所有源文件。包含所有的资源文件和Java源文件。有些插件，如Groovy 插件，会从该集合中增加其他的源文件。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"多项目构建\"><a href=\"#多项目构建\" class=\"headerlink\" title=\"多项目构建\"></a>多项目构建</h3><h3 id=\"创建多项目总结\"><a href=\"#创建多项目总结\" class=\"headerlink\" title=\"创建多项目总结\"></a>创建多项目总结</h3><ol>\n<li><p>一个多项目构建必须在根项目的根目录下包含settings.gradle文件，因为它指明了那些包含在多项目构建中的项目。</p>\n</li>\n<li><p>如果需要在多项目构建的所有项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用allprojects)</p>\n</li>\n<li><p>如果需要在根项目的子项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用subprojects)</p>\n</li>\n</ol>"},{"title":"如何使用Cmd Markdown 编写MarkDown文档","date":"2016-06-19T00:25:26.000Z","_content":"# 欢迎使用 Cmd Markdown 编辑阅读器\n\n------\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n<!--more-->\n![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\n\n### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)\n\n> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。\n\n------\n\n## 什么是 Markdown\n\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，**粗体** 或者 *斜体* 某些文字，更棒的是，它还可以\n\n### 1. 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)\n\n- [ ] 支持以 PDF 格式导出文稿\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n- [x] 修复 LaTex 公式渲染问题\n- [x] 新增 LaTex 公式编号功能\n\n### 2. 书写一个质能守恒公式[^LaTeX]\n\n$$E=mc^2$$\n\n### 3. 高亮一段代码[^code]\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n### 4. 高效绘制 [流程图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图)\n\n```flow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n### 5. 高效绘制 [序列图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图)\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n### 6. 绘制表格\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n### 7. 更详细语法说明\n\n想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\n\n总而言之，不同于其它 *所见即所得* 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。**Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。** 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n---\n\n## 什么是 Cmd Markdown\n\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n\n### 1. 实时同步预览\n\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n\n### 2. 编辑工具栏\n\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\n\n### 3. 编辑模式\n\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右测的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n\n### 4. 实时的云端文稿\n\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n\n### 5. 离线模式\n\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n\n### 6. 管理工具栏\n\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\n\n通过管理工具栏可以：\n\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\n\n### 7. 阅读工具栏\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\n\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\n\n工具栏上的五个图标依次为：\n\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n### 8. 阅读模式\n\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n\n### 9. 标签、分类和搜索\n\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n\n标签： 未分类\n\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\n\n### 10. 文稿发布和分享\n\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n------\n\n再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n\n作者 [@ghosert][3]     \n2015 年 06月 15日    \n\n[^LaTeX]: 支持 **LaTeX** 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。\n\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\n[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\n[3]: http://weibo.com/ghosert\n[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n","source":"_posts/howto-use-markdownedit.md","raw":"---\ntitle: 如何使用Cmd Markdown 编写MarkDown文档\ndate: 2016-06-19 08:25:26\ncategories: markdown\ntags: [CmdMarkdown,markdown,test]\n---\n# 欢迎使用 Cmd Markdown 编辑阅读器\n\n------\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n<!--more-->\n![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\n\n### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)\n\n> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。\n\n------\n\n## 什么是 Markdown\n\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，**粗体** 或者 *斜体* 某些文字，更棒的是，它还可以\n\n### 1. 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)\n\n- [ ] 支持以 PDF 格式导出文稿\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n- [x] 修复 LaTex 公式渲染问题\n- [x] 新增 LaTex 公式编号功能\n\n### 2. 书写一个质能守恒公式[^LaTeX]\n\n$$E=mc^2$$\n\n### 3. 高亮一段代码[^code]\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n### 4. 高效绘制 [流程图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图)\n\n```flow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n### 5. 高效绘制 [序列图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图)\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n### 6. 绘制表格\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n### 7. 更详细语法说明\n\n想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\n\n总而言之，不同于其它 *所见即所得* 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。**Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。** 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n---\n\n## 什么是 Cmd Markdown\n\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n\n### 1. 实时同步预览\n\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n\n### 2. 编辑工具栏\n\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\n\n### 3. 编辑模式\n\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右测的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n\n### 4. 实时的云端文稿\n\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n\n### 5. 离线模式\n\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n\n### 6. 管理工具栏\n\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\n\n通过管理工具栏可以：\n\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\n\n### 7. 阅读工具栏\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\n\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\n\n工具栏上的五个图标依次为：\n\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n### 8. 阅读模式\n\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n\n### 9. 标签、分类和搜索\n\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n\n标签： 未分类\n\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\n\n### 10. 文稿发布和分享\n\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n------\n\n再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n\n作者 [@ghosert][3]     \n2015 年 06月 15日    \n\n[^LaTeX]: 支持 **LaTeX** 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。\n\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\n[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\n[3]: http://weibo.com/ghosert\n[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n","slug":"howto-use-markdownedit","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsw0001aqk5cd82wadf4","content":"<h1 id=\"欢迎使用-Cmd-Markdown-编辑阅读器\"><a href=\"#欢迎使用-Cmd-Markdown-编辑阅读器\" class=\"headerlink\" title=\"欢迎使用 Cmd Markdown 编辑阅读器\"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>\n<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>\n<blockquote>\n<ul>\n<li>整理知识，学习笔记</li>\n<li>发布日记，杂文，所见所想</li>\n<li>撰写发布技术文稿（代码支持）</li>\n<li>撰写发布学术论文（LaTeX 公式支持）<a id=\"more\"></a>\n<img src=\"https://www.zybuluo.com/static/img/logo.png\" alt=\"cmd-markdown-logo\"></li>\n</ul>\n</blockquote>\n<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>\n<h3 id=\"Windows-Mac-Linux-全平台客户端\"><a href=\"#Windows-Mac-Linux-全平台客户端\" class=\"headerlink\" title=\"Windows/Mac/Linux 全平台客户端\"></a><a href=\"https://www.zybuluo.com/cmd/\" target=\"_blank\" rel=\"external\">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>\n<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>\n</blockquote>\n<hr>\n<h2 id=\"什么是-Markdown\"><a href=\"#什么是-Markdown\" class=\"headerlink\" title=\"什么是 Markdown\"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>\n<h3 id=\"1-制作一份待办事宜-Todo-列表\"><a href=\"#1-制作一份待办事宜-Todo-列表\" class=\"headerlink\" title=\"1. 制作一份待办事宜 Todo 列表\"></a>1. 制作一份待办事宜 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表\" target=\"_blank\" rel=\"external\">Todo 列表</a></h3><ul>\n<li>[ ] 支持以 PDF 格式导出文稿</li>\n<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li>[x] 新增 Todo 列表功能</li>\n<li>[x] 修复 LaTex 公式渲染问题</li>\n<li>[x] 新增 LaTex 公式编号功能</li>\n</ul>\n<h3 id=\"2-书写一个质能守恒公式-LaTeX\"><a href=\"#2-书写一个质能守恒公式-LaTeX\" class=\"headerlink\" title=\"2. 书写一个质能守恒公式[^LaTeX]\"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>\n<h3 id=\"3-高亮一段代码-code\"><a href=\"#3-高亮一段代码-code\" class=\"headerlink\" title=\"3. 高亮一段代码[^code]\"></a>3. 高亮一段代码[^code]</h3><pre><code class=\"python\">@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == &#39;__main__&#39;:\n    # A comment\n    print &#39;hello world&#39;\n</code></pre>\n<h3 id=\"4-高效绘制-流程图\"><a href=\"#4-高效绘制-流程图\" class=\"headerlink\" title=\"4. 高效绘制 流程图\"></a>4. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图\" target=\"_blank\" rel=\"external\">流程图</a></h3><pre><code class=\"flow\">st=&gt;start: Start\nop=&gt;operation: Your Operation\ncond=&gt;condition: Yes or No?\ne=&gt;end\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</code></pre>\n<h3 id=\"5-高效绘制-序列图\"><a href=\"#5-高效绘制-序列图\" class=\"headerlink\" title=\"5. 高效绘制 序列图\"></a>5. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图\" target=\"_blank\" rel=\"external\">序列图</a></h3><pre><code class=\"seq\">Alice-&gt;Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob--&gt;Alice: I am good thanks!\n</code></pre>\n<h3 id=\"6-绘制表格\"><a href=\"#6-绘制表格\" class=\"headerlink\" title=\"6. 绘制表格\"></a>6. 绘制表格</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算机</td>\n<td style=\"text-align:right\">\\$1600</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td style=\"text-align:right\">\\$12</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td style=\"text-align:right\">\\$1</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"7-更详细语法说明\"><a href=\"#7-更详细语法说明\" class=\"headerlink\" title=\"7. 更详细语法说明\"></a>7. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\" target=\"_blank\" rel=\"external\">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\" target=\"_blank\" rel=\"external\">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>\n<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>\n<hr>\n<h2 id=\"什么是-Cmd-Markdown\"><a href=\"#什么是-Cmd-Markdown\" class=\"headerlink\" title=\"什么是 Cmd Markdown\"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>\n<h3 id=\"1-实时同步预览\"><a href=\"#1-实时同步预览\" class=\"headerlink\" title=\"1. 实时同步预览\"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>\n<h3 id=\"2-编辑工具栏\"><a href=\"#2-编辑工具栏\" class=\"headerlink\" title=\"2. 编辑工具栏\"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-editor.png\" alt=\"tool-editor\"></p>\n<h3 id=\"3-编辑模式\"><a href=\"#3-编辑模式\" class=\"headerlink\" title=\"3. 编辑模式\"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右测的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>\n<h3 id=\"4-实时的云端文稿\"><a href=\"#4-实时的云端文稿\" class=\"headerlink\" title=\"4. 实时的云端文稿\"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>\n<h3 id=\"5-离线模式\"><a href=\"#5-离线模式\" class=\"headerlink\" title=\"5. 离线模式\"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>\n<h3 id=\"6-管理工具栏\"><a href=\"#6-管理工具栏\" class=\"headerlink\" title=\"6. 管理工具栏\"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-manager.jpg\" alt=\"tool-manager\"></p>\n<p>通过管理工具栏可以：</p>\n<p><i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿<br><i class=\"icon-trash\"></i> 删除：删除当前的文稿<br><i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>\n<h3 id=\"7-阅读工具栏\"><a href=\"#7-阅读工具栏\" class=\"headerlink\" title=\"7. 阅读工具栏\"></a>7. 阅读工具栏</h3><p><img src=\"https://www.zybuluo.com/static/img/toolbar-reader.jpg\" alt=\"tool-manager\"></p>\n<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>\n<p>工具栏上的五个图标依次为：</p>\n<p><i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>\n<h3 id=\"8-阅读模式\"><a href=\"#8-阅读模式\" class=\"headerlink\" title=\"8. 阅读模式\"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class=\"icon-desktop\"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>\n<h3 id=\"9-标签、分类和搜索\"><a href=\"#9-标签、分类和搜索\" class=\"headerlink\" title=\"9. 标签、分类和搜索\"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>\n<p>标签： 未分类</p>\n<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/file-list.png\" alt=\"file-list\"></p>\n<h3 id=\"10-文稿发布和分享\"><a href=\"#10-文稿发布和分享\" class=\"headerlink\" title=\"10. 文稿发布和分享\"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>\n<hr>\n<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>\n<p>作者 <a href=\"http://weibo.com/ghosert\" target=\"_blank\" rel=\"external\">@ghosert</a><br>2015 年 06月 15日    </p>\n<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"external\">MathJax</a> 参考更多使用方法。</p>\n<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>\n","excerpt":"<h1 id=\"欢迎使用-Cmd-Markdown-编辑阅读器\"><a href=\"#欢迎使用-Cmd-Markdown-编辑阅读器\" class=\"headerlink\" title=\"欢迎使用 Cmd Markdown 编辑阅读器\"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>\n<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>\n<blockquote>\n<ul>\n<li>整理知识，学习笔记</li>\n<li>发布日记，杂文，所见所想</li>\n<li>撰写发布技术文稿（代码支持）</li>\n<li>撰写发布学术论文（LaTeX 公式支持）","more":"<img src=\"https://www.zybuluo.com/static/img/logo.png\" alt=\"cmd-markdown-logo\"></li>\n</ul>\n</blockquote>\n<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>\n<h3 id=\"Windows-Mac-Linux-全平台客户端\"><a href=\"#Windows-Mac-Linux-全平台客户端\" class=\"headerlink\" title=\"Windows/Mac/Linux 全平台客户端\"></a><a href=\"https://www.zybuluo.com/cmd/\">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>\n<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>\n</blockquote>\n<hr>\n<h2 id=\"什么是-Markdown\"><a href=\"#什么是-Markdown\" class=\"headerlink\" title=\"什么是 Markdown\"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>\n<h3 id=\"1-制作一份待办事宜-Todo-列表\"><a href=\"#1-制作一份待办事宜-Todo-列表\" class=\"headerlink\" title=\"1. 制作一份待办事宜 Todo 列表\"></a>1. 制作一份待办事宜 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表\">Todo 列表</a></h3><ul>\n<li>[ ] 支持以 PDF 格式导出文稿</li>\n<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li>[x] 新增 Todo 列表功能</li>\n<li>[x] 修复 LaTex 公式渲染问题</li>\n<li>[x] 新增 LaTex 公式编号功能</li>\n</ul>\n<h3 id=\"2-书写一个质能守恒公式-LaTeX\"><a href=\"#2-书写一个质能守恒公式-LaTeX\" class=\"headerlink\" title=\"2. 书写一个质能守恒公式[^LaTeX]\"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>\n<h3 id=\"3-高亮一段代码-code\"><a href=\"#3-高亮一段代码-code\" class=\"headerlink\" title=\"3. 高亮一段代码[^code]\"></a>3. 高亮一段代码[^code]</h3><pre><code class=\"python\">@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == &#39;__main__&#39;:\n    # A comment\n    print &#39;hello world&#39;\n</code></pre>\n<h3 id=\"4-高效绘制-流程图\"><a href=\"#4-高效绘制-流程图\" class=\"headerlink\" title=\"4. 高效绘制 流程图\"></a>4. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图\">流程图</a></h3><pre><code class=\"flow\">st=&gt;start: Start\nop=&gt;operation: Your Operation\ncond=&gt;condition: Yes or No?\ne=&gt;end\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op\n</code></pre>\n<h3 id=\"5-高效绘制-序列图\"><a href=\"#5-高效绘制-序列图\" class=\"headerlink\" title=\"5. 高效绘制 序列图\"></a>5. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图\">序列图</a></h3><pre><code class=\"seq\">Alice-&gt;Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob--&gt;Alice: I am good thanks!\n</code></pre>\n<h3 id=\"6-绘制表格\"><a href=\"#6-绘制表格\" class=\"headerlink\" title=\"6. 绘制表格\"></a>6. 绘制表格</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算机</td>\n<td style=\"text-align:right\">\\$1600</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td style=\"text-align:right\">\\$12</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td style=\"text-align:right\">\\$1</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"7-更详细语法说明\"><a href=\"#7-更详细语法说明\" class=\"headerlink\" title=\"7. 更详细语法说明\"></a>7. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>\n<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>\n<hr>\n<h2 id=\"什么是-Cmd-Markdown\"><a href=\"#什么是-Cmd-Markdown\" class=\"headerlink\" title=\"什么是 Cmd Markdown\"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>\n<h3 id=\"1-实时同步预览\"><a href=\"#1-实时同步预览\" class=\"headerlink\" title=\"1. 实时同步预览\"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>\n<h3 id=\"2-编辑工具栏\"><a href=\"#2-编辑工具栏\" class=\"headerlink\" title=\"2. 编辑工具栏\"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-editor.png\" alt=\"tool-editor\"></p>\n<h3 id=\"3-编辑模式\"><a href=\"#3-编辑模式\" class=\"headerlink\" title=\"3. 编辑模式\"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右测的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>\n<h3 id=\"4-实时的云端文稿\"><a href=\"#4-实时的云端文稿\" class=\"headerlink\" title=\"4. 实时的云端文稿\"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>\n<h3 id=\"5-离线模式\"><a href=\"#5-离线模式\" class=\"headerlink\" title=\"5. 离线模式\"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>\n<h3 id=\"6-管理工具栏\"><a href=\"#6-管理工具栏\" class=\"headerlink\" title=\"6. 管理工具栏\"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-manager.jpg\" alt=\"tool-manager\"></p>\n<p>通过管理工具栏可以：</p>\n<p><i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿<br><i class=\"icon-trash\"></i> 删除：删除当前的文稿<br><i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>\n<h3 id=\"7-阅读工具栏\"><a href=\"#7-阅读工具栏\" class=\"headerlink\" title=\"7. 阅读工具栏\"></a>7. 阅读工具栏</h3><p><img src=\"https://www.zybuluo.com/static/img/toolbar-reader.jpg\" alt=\"tool-manager\"></p>\n<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>\n<p>工具栏上的五个图标依次为：</p>\n<p><i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>\n<h3 id=\"8-阅读模式\"><a href=\"#8-阅读模式\" class=\"headerlink\" title=\"8. 阅读模式\"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class=\"icon-desktop\"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>\n<h3 id=\"9-标签、分类和搜索\"><a href=\"#9-标签、分类和搜索\" class=\"headerlink\" title=\"9. 标签、分类和搜索\"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>\n<p>标签： 未分类</p>\n<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/file-list.png\" alt=\"file-list\"></p>\n<h3 id=\"10-文稿发布和分享\"><a href=\"#10-文稿发布和分享\" class=\"headerlink\" title=\"10. 文稿发布和分享\"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>\n<hr>\n<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>\n<p>作者 <a href=\"http://weibo.com/ghosert\">@ghosert</a><br>2015 年 06月 15日    </p>\n<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">MathJax</a> 参考更多使用方法。</p>\n<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>"},{"title":"开发乱码问题缘由分析","date":"2017-02-18T09:56:39.000Z","_content":"","source":"_posts/java-encoding.md","raw":"---\ntitle: 开发乱码问题缘由分析\ndate: 2017-02-18 17:56:39\ntags:\n---\n","slug":"java-encoding","published":1,"updated":"2017-02-18T12:30:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsw3001dqk5cntpkb4d2","content":"","excerpt":"","more":""},{"title":"jquery实现页面置顶功能","date":"2013-11-26T01:14:00.000Z","_content":"\n### 实现代码\n<br/>\n```js\n<html>\n<head>\n <title></title><br><script type='text/javascript>\n//回到顶部功能\nfunction gotoTop(min_height) {\n    $(\"#toTop\").click(//定义返回顶部点击向上滚动的动画\n        function () {\n            $('html,body').animate({ scrollTop: 0 }, 700);\n        });\n    //获取页面的最小高度，无传入值则默认为600像素\n    min_height ? min_height = min_height : min_height = 600;\n    //为窗口的scroll事件绑定处理函数\n    $(window).scroll(function () {\n        //获取窗口的滚动条的垂直位置\n        var s = $(window).scrollTop();\n        //当窗口的滚动条的垂直位置大于页面的最小高度时，让返回顶部元素渐现，否则渐隐\n        if (s > min_height) {\n            $(\"#totop\").fadeIn(100);\n        } else {\n            $(\"#toTop\").fadeOut(200);\n        };\n    });\n};\n</script>'\n </head>\n    <body>\n       <div id='toTop' ></div>\n   </body>\n</html>\n```\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3442638.html)\n","source":"_posts/jquery实现页面置顶功能.md","raw":"---\ntitle: jquery实现页面置顶功能\ndate: 2013-11-26 09:14\ncategories: 代码片段\ntags: ['js']\n---\n\n### 实现代码\n<br/>\n```js\n<html>\n<head>\n <title></title><br><script type='text/javascript>\n//回到顶部功能\nfunction gotoTop(min_height) {\n    $(\"#toTop\").click(//定义返回顶部点击向上滚动的动画\n        function () {\n            $('html,body').animate({ scrollTop: 0 }, 700);\n        });\n    //获取页面的最小高度，无传入值则默认为600像素\n    min_height ? min_height = min_height : min_height = 600;\n    //为窗口的scroll事件绑定处理函数\n    $(window).scroll(function () {\n        //获取窗口的滚动条的垂直位置\n        var s = $(window).scrollTop();\n        //当窗口的滚动条的垂直位置大于页面的最小高度时，让返回顶部元素渐现，否则渐隐\n        if (s > min_height) {\n            $(\"#totop\").fadeIn(100);\n        } else {\n            $(\"#toTop\").fadeOut(200);\n        };\n    });\n};\n</script>'\n </head>\n    <body>\n       <div id='toTop' ></div>\n   </body>\n</html>\n```\n\n博客搬家至此，原文可以访问[这里](http://www.cnblogs.com/yja9010/p/3442638.html)\n","slug":"jquery实现页面置顶功能","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsw4001hqk5cjgazfegy","content":"<h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><p><br></p>\n<pre><code class=\"js\">&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;&lt;/title&gt;&lt;br&gt;&lt;script type=&#39;text/javascript&gt;\n//回到顶部功能\nfunction gotoTop(min_height) {\n    $(&quot;#toTop&quot;).click(//定义返回顶部点击向上滚动的动画\n        function () {\n            $(&#39;html,body&#39;).animate({ scrollTop: 0 }, 700);\n        });\n    //获取页面的最小高度，无传入值则默认为600像素\n    min_height ? min_height = min_height : min_height = 600;\n    //为窗口的scroll事件绑定处理函数\n    $(window).scroll(function () {\n        //获取窗口的滚动条的垂直位置\n        var s = $(window).scrollTop();\n        //当窗口的滚动条的垂直位置大于页面的最小高度时，让返回顶部元素渐现，否则渐隐\n        if (s &gt; min_height) {\n            $(&quot;#totop&quot;).fadeIn(100);\n        } else {\n            $(&quot;#toTop&quot;).fadeOut(200);\n        };\n    });\n};\n&lt;/script&gt;&#39;\n &lt;/head&gt;\n    &lt;body&gt;\n       &lt;div id=&#39;toTop&#39; &gt;&lt;/div&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3442638.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"","more":"<h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><p><br/></p>\n<pre><code class=\"js\">&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;&lt;/title&gt;&lt;br&gt;&lt;script type=&#39;text/javascript&gt;\n//回到顶部功能\nfunction gotoTop(min_height) {\n    $(&quot;#toTop&quot;).click(//定义返回顶部点击向上滚动的动画\n        function () {\n            $(&#39;html,body&#39;).animate({ scrollTop: 0 }, 700);\n        });\n    //获取页面的最小高度，无传入值则默认为600像素\n    min_height ? min_height = min_height : min_height = 600;\n    //为窗口的scroll事件绑定处理函数\n    $(window).scroll(function () {\n        //获取窗口的滚动条的垂直位置\n        var s = $(window).scrollTop();\n        //当窗口的滚动条的垂直位置大于页面的最小高度时，让返回顶部元素渐现，否则渐隐\n        if (s &gt; min_height) {\n            $(&quot;#totop&quot;).fadeIn(100);\n        } else {\n            $(&quot;#toTop&quot;).fadeOut(200);\n        };\n    });\n};\n&lt;/script&gt;&#39;\n &lt;/head&gt;\n    &lt;body&gt;\n       &lt;div id=&#39;toTop&#39; &gt;&lt;/div&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>博客搬家至此，原文可以访问<a href=\"http://www.cnblogs.com/yja9010/p/3442638.html\">这里</a></p>\n"},{"title":"linux命令拾遗(1)-whatis info man which whereis","date":"2016-08-07T06:47:17.000Z","_content":"\n### 简述\n\n接触和学习过linux的同学相比都知道linux命令的繁多和复杂，无论是linux初学者还是老司机，也不可能把所有linux的命令都记住，好在linux有一一些强大的帮助命令，让我们不用担心不熟悉或者暂时遗忘的命令的情况，下面我们来看怎么去正确的使用这些命令\n<!--more-->\n\n>1. 在只记得部分关键字的时候，可以通过man -k 来搜索\n>2. 查看某个命令的简单功能描述，可以通过whatis\n>3. 查看某个命令更详细的说明可以用info 命令\n>4. 要查看某个命令的具体位置，可以使用which\n>5. 对于要查看某个命令的具体参数的含义及使用方法，可以借助强大的man命令\n\n### whatis\n\nwhatis命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上\n\n>whatis命令在用catman -w命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用man -f命令\n\n#### 用法\n\n```\nwhatis 命令名称\n```\n\n#### 使用\n\n```\n[root@centos etc]# whatis cp\ncp                   (1)  - copy files and directories\n[root@centos etc]# whatis ls\nls                   (1)  - list directory contents\n[root@centos etc]# whatis chown\nchown                (1)  - change file owner and group\n[root@centos etc]# whatis rm\nrm                   (1)  - remove files or directories\n```\n\n### info\n\n查看某个命令更详细的说明\n\n>就内容来说，info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。\n\n#### 用法\n```\ninfo [选项] [参数]\n```\n#### 选项列举\n|命令选项|说明|\n|:---:|:----|\n|-d|添加包含info格式帮助文档的目录|\n|-f|指定要读取的info格式的帮助文档|\n|-n|指定首先访问的info帮助文件的节点|\n|-o|输出被选择的节点内容到指定文件|\n\n\n#### 使用\n\n```\n[root@centos etc]# info cp\n\nFile: coreutils.info,  Node: cp invocation,  Next: dd invocation,  Up: Basic operations\n\n11.1 `cp': Copy files and directories\n=====================================\n`cp' copies files (or, optionally, directories).  The copy is\ncompletely independent of the original.  You can either copy one file to\nanother, or copy arbitrarily many files to a destination directory.\nSynopses:\n\n     cp [OPTION]... [-T] SOURCE DEST\n     cp [OPTION]... SOURCE... DIRECTORY\n     cp [OPTION]... -t DIRECTORY SOURCE...\n\n   * If two file names are given, `cp' copies the first file to the\n     second.\n\n   * If the `--target-directory' (`-t') option is given, or failing\n     that if the last file is a directory and the\n     `--no-target-directory' (`-T') option is not given, `cp' copies\n     each SOURCE file to the specified directory, using the SOURCEs'\n     names.\n\n   Generally, files are written just as they are read.  For exceptions,\nsee the `--sparse' option below.\n省略...\n```\n#### 快捷键\n在info命令执行后处于帮助文档显示状态时，可以使用如下快捷操作\n\n|快捷键|说明|\n|:---:|:----|\n|?键|它就会显示info的常用快捷键。\n|N键|显示（相对于本节点的）下一节点的文档内容。\n|P键|显示（相对于本节点的）前一节点的文档内容。\n|U键|进入当前命令所在的主题。\n|M键|敲M键后输入命令的名称就可以查看该命令的帮助文档了。\n|G键|敲G键后输入主题名称，进入该主题。\n|L键|回到上一个访问的页面。\n|SPACE键|向前滚动一页。\n|BACKUP或DEL键|向后滚动一页。\n|Q|退出info。\n\n### man\n\nman命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息\n\n#### 用法\n\n```\nman [选项] [参数]\n```\n\n#### 选项列举\n\n|命令选项|说明|\n|:---:|:----|\n|-a|在所有的man帮助手册中搜索；\n|-f|等价于whatis指令，显示给定关键字的简短描述信息；\n|-P|指定内容时使用分页程序；\n|-M|指定man手册搜索的路径。\n\n#### 使用\n\n```shell\n[root@centos etc]# man rm\nRM(1)                            User Commands                           RM(1)\n\nNAME\n       rm - remove files or directories\n\nSYNOPSIS\n       rm [OPTION]... FILE...\n\nDESCRIPTION\n       This manual page documents the GNU version of rm.  rm removes each specified file.  By default, it does not remove directories.\n....省略以下输出...       \n```\n\n### which\n\nwhich命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n#### 用法\n\n```\nwhich [选项] [参数]\n```\n\n#### 选项列举\n\n|命令选项|说明|\n|:---:|:----|\n|-n<文件名长度>|制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；\n|-p<文件名长度>|与-n参数相同，但此处的<文件名长度>包含了文件的路径；\n|-w|指定输出时栏位的宽度；\n|-V|显示版本信息。\n\n#### 使用\n\n```\n[root@centos etc]# which -V chown\nGNU which v2.19, Copyright (C) 1999 - 2008 Carlo Wood.\nGNU which comes with ABSOLUTELY NO WARRANTY;\nThis program is free software; your freedom to use, change\nand distribute this program is protected by the GPL.\n[root@centos etc]# which adduser\n/usr/sbin/adduser\n[root@centos etc]# which pwd\n/bin/pwd\n```\n### whereis\n\nwhereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\n>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。\n\n#### 用法\n\n```\nwhereis [选项] [参数]\n```\n\n#### 选项列举\n\n|命令选项|说明|\n|:---:|:----|\n|-b|只查找二进制文件；\n|-B<目录>|只在设置的目录下查找二进制文件；\n|-f|不显示文件名前的路径名称；\n|-m|只查找说明文件；\n|-M<目录>|只在设置的目录下查找说明文件；\n|-s|只查找原始代码文件；\n|-S<目录>只在设置的目录下查找原始代码文件；\n|-u|查找不包含指定类型的文件。\n\n#### 使用\n\n```\n[root@centos etc]# which pwd\n/bin/pwd\n[root@centos etc]# whereis pwd\npwd: /bin/pwd /usr/include/pwd.h /usr/share/man/mann/pwd.n.gz /usr/share/man/man1/pwd.1.gz\n[root@centos etc]# whereis -b  pwd\npwd: /bin/pwd /usr/include/pwd.h\n[root@centos etc]# whereis -s  pwd\npwd:\n```\n\n### 参考资料\n1. linux命令手册大全：[http://man.linuxde.net/](http://man.linuxde.net/ 'linux命令手册大全')\n","source":"_posts/linux命令拾遗-1.md","raw":"---\ntitle: linux命令拾遗(1)-whatis info man which whereis\ndate: 2016-08-07 14:47:17\ncategories: linux\ntags: ['linux','linux命令']\n---\n\n### 简述\n\n接触和学习过linux的同学相比都知道linux命令的繁多和复杂，无论是linux初学者还是老司机，也不可能把所有linux的命令都记住，好在linux有一一些强大的帮助命令，让我们不用担心不熟悉或者暂时遗忘的命令的情况，下面我们来看怎么去正确的使用这些命令\n<!--more-->\n\n>1. 在只记得部分关键字的时候，可以通过man -k 来搜索\n>2. 查看某个命令的简单功能描述，可以通过whatis\n>3. 查看某个命令更详细的说明可以用info 命令\n>4. 要查看某个命令的具体位置，可以使用which\n>5. 对于要查看某个命令的具体参数的含义及使用方法，可以借助强大的man命令\n\n### whatis\n\nwhatis命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上\n\n>whatis命令在用catman -w命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用man -f命令\n\n#### 用法\n\n```\nwhatis 命令名称\n```\n\n#### 使用\n\n```\n[root@centos etc]# whatis cp\ncp                   (1)  - copy files and directories\n[root@centos etc]# whatis ls\nls                   (1)  - list directory contents\n[root@centos etc]# whatis chown\nchown                (1)  - change file owner and group\n[root@centos etc]# whatis rm\nrm                   (1)  - remove files or directories\n```\n\n### info\n\n查看某个命令更详细的说明\n\n>就内容来说，info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。\n\n#### 用法\n```\ninfo [选项] [参数]\n```\n#### 选项列举\n|命令选项|说明|\n|:---:|:----|\n|-d|添加包含info格式帮助文档的目录|\n|-f|指定要读取的info格式的帮助文档|\n|-n|指定首先访问的info帮助文件的节点|\n|-o|输出被选择的节点内容到指定文件|\n\n\n#### 使用\n\n```\n[root@centos etc]# info cp\n\nFile: coreutils.info,  Node: cp invocation,  Next: dd invocation,  Up: Basic operations\n\n11.1 `cp': Copy files and directories\n=====================================\n`cp' copies files (or, optionally, directories).  The copy is\ncompletely independent of the original.  You can either copy one file to\nanother, or copy arbitrarily many files to a destination directory.\nSynopses:\n\n     cp [OPTION]... [-T] SOURCE DEST\n     cp [OPTION]... SOURCE... DIRECTORY\n     cp [OPTION]... -t DIRECTORY SOURCE...\n\n   * If two file names are given, `cp' copies the first file to the\n     second.\n\n   * If the `--target-directory' (`-t') option is given, or failing\n     that if the last file is a directory and the\n     `--no-target-directory' (`-T') option is not given, `cp' copies\n     each SOURCE file to the specified directory, using the SOURCEs'\n     names.\n\n   Generally, files are written just as they are read.  For exceptions,\nsee the `--sparse' option below.\n省略...\n```\n#### 快捷键\n在info命令执行后处于帮助文档显示状态时，可以使用如下快捷操作\n\n|快捷键|说明|\n|:---:|:----|\n|?键|它就会显示info的常用快捷键。\n|N键|显示（相对于本节点的）下一节点的文档内容。\n|P键|显示（相对于本节点的）前一节点的文档内容。\n|U键|进入当前命令所在的主题。\n|M键|敲M键后输入命令的名称就可以查看该命令的帮助文档了。\n|G键|敲G键后输入主题名称，进入该主题。\n|L键|回到上一个访问的页面。\n|SPACE键|向前滚动一页。\n|BACKUP或DEL键|向后滚动一页。\n|Q|退出info。\n\n### man\n\nman命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息\n\n#### 用法\n\n```\nman [选项] [参数]\n```\n\n#### 选项列举\n\n|命令选项|说明|\n|:---:|:----|\n|-a|在所有的man帮助手册中搜索；\n|-f|等价于whatis指令，显示给定关键字的简短描述信息；\n|-P|指定内容时使用分页程序；\n|-M|指定man手册搜索的路径。\n\n#### 使用\n\n```shell\n[root@centos etc]# man rm\nRM(1)                            User Commands                           RM(1)\n\nNAME\n       rm - remove files or directories\n\nSYNOPSIS\n       rm [OPTION]... FILE...\n\nDESCRIPTION\n       This manual page documents the GNU version of rm.  rm removes each specified file.  By default, it does not remove directories.\n....省略以下输出...       \n```\n\n### which\n\nwhich命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n#### 用法\n\n```\nwhich [选项] [参数]\n```\n\n#### 选项列举\n\n|命令选项|说明|\n|:---:|:----|\n|-n<文件名长度>|制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；\n|-p<文件名长度>|与-n参数相同，但此处的<文件名长度>包含了文件的路径；\n|-w|指定输出时栏位的宽度；\n|-V|显示版本信息。\n\n#### 使用\n\n```\n[root@centos etc]# which -V chown\nGNU which v2.19, Copyright (C) 1999 - 2008 Carlo Wood.\nGNU which comes with ABSOLUTELY NO WARRANTY;\nThis program is free software; your freedom to use, change\nand distribute this program is protected by the GPL.\n[root@centos etc]# which adduser\n/usr/sbin/adduser\n[root@centos etc]# which pwd\n/bin/pwd\n```\n### whereis\n\nwhereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\n>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。\n\n#### 用法\n\n```\nwhereis [选项] [参数]\n```\n\n#### 选项列举\n\n|命令选项|说明|\n|:---:|:----|\n|-b|只查找二进制文件；\n|-B<目录>|只在设置的目录下查找二进制文件；\n|-f|不显示文件名前的路径名称；\n|-m|只查找说明文件；\n|-M<目录>|只在设置的目录下查找说明文件；\n|-s|只查找原始代码文件；\n|-S<目录>只在设置的目录下查找原始代码文件；\n|-u|查找不包含指定类型的文件。\n\n#### 使用\n\n```\n[root@centos etc]# which pwd\n/bin/pwd\n[root@centos etc]# whereis pwd\npwd: /bin/pwd /usr/include/pwd.h /usr/share/man/mann/pwd.n.gz /usr/share/man/man1/pwd.1.gz\n[root@centos etc]# whereis -b  pwd\npwd: /bin/pwd /usr/include/pwd.h\n[root@centos etc]# whereis -s  pwd\npwd:\n```\n\n### 参考资料\n1. linux命令手册大全：[http://man.linuxde.net/](http://man.linuxde.net/ 'linux命令手册大全')\n","slug":"linux命令拾遗-1","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsw5001jqk5cbjyir2h2","content":"<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>接触和学习过linux的同学相比都知道linux命令的繁多和复杂，无论是linux初学者还是老司机，也不可能把所有linux的命令都记住，好在linux有一一些强大的帮助命令，让我们不用担心不熟悉或者暂时遗忘的命令的情况，下面我们来看怎么去正确的使用这些命令<br><a id=\"more\"></a></p>\n<blockquote>\n<ol>\n<li>在只记得部分关键字的时候，可以通过man -k 来搜索</li>\n<li>查看某个命令的简单功能描述，可以通过whatis</li>\n<li>查看某个命令更详细的说明可以用info 命令</li>\n<li>要查看某个命令的具体位置，可以使用which</li>\n<li>对于要查看某个命令的具体参数的含义及使用方法，可以借助强大的man命令</li>\n</ol>\n</blockquote>\n<h3 id=\"whatis\"><a href=\"#whatis\" class=\"headerlink\" title=\"whatis\"></a>whatis</h3><p>whatis命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上</p>\n<blockquote>\n<p>whatis命令在用catman -w命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用man -f命令</p>\n</blockquote>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>whatis 命令名称\n</code></pre><h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# whatis cp\ncp                   (1)  - copy files and directories\n[root@centos etc]# whatis ls\nls                   (1)  - list directory contents\n[root@centos etc]# whatis chown\nchown                (1)  - change file owner and group\n[root@centos etc]# whatis rm\nrm                   (1)  - remove files or directories\n</code></pre><h3 id=\"info\"><a href=\"#info\" class=\"headerlink\" title=\"info\"></a>info</h3><p>查看某个命令更详细的说明</p>\n<blockquote>\n<p>就内容来说，info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。</p>\n</blockquote>\n<h4 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>info [选项] [参数]\n</code></pre><h4 id=\"选项列举\"><a href=\"#选项列举\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:left\">添加包含info格式帮助文档的目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:left\">指定要读取的info格式的帮助文档</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:left\">指定首先访问的info帮助文件的节点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-o</td>\n<td style=\"text-align:left\">输出被选择的节点内容到指定文件</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# info cp\n\nFile: coreutils.info,  Node: cp invocation,  Next: dd invocation,  Up: Basic operations\n\n11.1 `cp&#39;: Copy files and directories\n=====================================\n`cp&#39; copies files (or, optionally, directories).  The copy is\ncompletely independent of the original.  You can either copy one file to\nanother, or copy arbitrarily many files to a destination directory.\nSynopses:\n\n     cp [OPTION]... [-T] SOURCE DEST\n     cp [OPTION]... SOURCE... DIRECTORY\n     cp [OPTION]... -t DIRECTORY SOURCE...\n\n   * If two file names are given, `cp&#39; copies the first file to the\n     second.\n\n   * If the `--target-directory&#39; (`-t&#39;) option is given, or failing\n     that if the last file is a directory and the\n     `--no-target-directory&#39; (`-T&#39;) option is not given, `cp&#39; copies\n     each SOURCE file to the specified directory, using the SOURCEs&#39;\n     names.\n\n   Generally, files are written just as they are read.  For exceptions,\nsee the `--sparse&#39; option below.\n省略...\n</code></pre><h4 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><p>在info命令执行后处于帮助文档显示状态时，可以使用如下快捷操作</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">快捷键</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">?键</td>\n<td style=\"text-align:left\">它就会显示info的常用快捷键。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N键</td>\n<td style=\"text-align:left\">显示（相对于本节点的）下一节点的文档内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">P键</td>\n<td style=\"text-align:left\">显示（相对于本节点的）前一节点的文档内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U键</td>\n<td style=\"text-align:left\">进入当前命令所在的主题。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">M键</td>\n<td style=\"text-align:left\">敲M键后输入命令的名称就可以查看该命令的帮助文档了。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G键</td>\n<td style=\"text-align:left\">敲G键后输入主题名称，进入该主题。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">L键</td>\n<td style=\"text-align:left\">回到上一个访问的页面。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SPACE键</td>\n<td style=\"text-align:left\">向前滚动一页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BACKUP或DEL键</td>\n<td style=\"text-align:left\">向后滚动一页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Q</td>\n<td style=\"text-align:left\">退出info。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</p>\n<h4 id=\"用法-2\"><a href=\"#用法-2\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>man [选项] [参数]\n</code></pre><h4 id=\"选项列举-1\"><a href=\"#选项列举-1\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:left\">在所有的man帮助手册中搜索；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:left\">等价于whatis指令，显示给定关键字的简短描述信息；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-P</td>\n<td style=\"text-align:left\">指定内容时使用分页程序；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-M</td>\n<td style=\"text-align:left\">指定man手册搜索的路径。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code class=\"shell\">[root@centos etc]# man rm\nRM(1)                            User Commands                           RM(1)\n\nNAME\n       rm - remove files or directories\n\nSYNOPSIS\n       rm [OPTION]... FILE...\n\nDESCRIPTION\n       This manual page documents the GNU version of rm.  rm removes each specified file.  By default, it does not remove directories.\n....省略以下输出...\n</code></pre>\n<h3 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h3><p>which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<h4 id=\"用法-3\"><a href=\"#用法-3\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>which [选项] [参数]\n</code></pre><h4 id=\"选项列举-2\"><a href=\"#选项列举-2\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n&lt;文件名长度&gt;</td>\n<td style=\"text-align:left\">制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p&lt;文件名长度&gt;</td>\n<td style=\"text-align:left\">与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-w</td>\n<td style=\"text-align:left\">指定输出时栏位的宽度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-V</td>\n<td style=\"text-align:left\">显示版本信息。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# which -V chown\nGNU which v2.19, Copyright (C) 1999 - 2008 Carlo Wood.\nGNU which comes with ABSOLUTELY NO WARRANTY;\nThis program is free software; your freedom to use, change\nand distribute this program is protected by the GPL.\n[root@centos etc]# which adduser\n/usr/sbin/adduser\n[root@centos etc]# which pwd\n/bin/pwd\n</code></pre><h3 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h3><p>whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<blockquote>\n<p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。</p>\n</blockquote>\n<h4 id=\"用法-4\"><a href=\"#用法-4\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>whereis [选项] [参数]\n</code></pre><h4 id=\"选项列举-3\"><a href=\"#选项列举-3\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:left\">只查找二进制文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-B&lt;目录&gt;</td>\n<td style=\"text-align:left\">只在设置的目录下查找二进制文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:left\">不显示文件名前的路径名称；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-m</td>\n<td style=\"text-align:left\">只查找说明文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-M&lt;目录&gt;</td>\n<td style=\"text-align:left\">只在设置的目录下查找说明文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:left\">只查找原始代码文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-S&lt;目录&gt;只在设置的目录下查找原始代码文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:left\">查找不包含指定类型的文件。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# which pwd\n/bin/pwd\n[root@centos etc]# whereis pwd\npwd: /bin/pwd /usr/include/pwd.h /usr/share/man/mann/pwd.n.gz /usr/share/man/man1/pwd.1.gz\n[root@centos etc]# whereis -b  pwd\npwd: /bin/pwd /usr/include/pwd.h\n[root@centos etc]# whereis -s  pwd\npwd:\n</code></pre><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li>linux命令手册大全：<a href=\"http://man.linuxde.net/\" title=\"linux命令手册大全\" target=\"_blank\" rel=\"external\">http://man.linuxde.net/</a></li>\n</ol>\n","excerpt":"<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>接触和学习过linux的同学相比都知道linux命令的繁多和复杂，无论是linux初学者还是老司机，也不可能把所有linux的命令都记住，好在linux有一一些强大的帮助命令，让我们不用担心不熟悉或者暂时遗忘的命令的情况，下面我们来看怎么去正确的使用这些命令<br>","more":"</p>\n<blockquote>\n<ol>\n<li>在只记得部分关键字的时候，可以通过man -k 来搜索</li>\n<li>查看某个命令的简单功能描述，可以通过whatis</li>\n<li>查看某个命令更详细的说明可以用info 命令</li>\n<li>要查看某个命令的具体位置，可以使用which</li>\n<li>对于要查看某个命令的具体参数的含义及使用方法，可以借助强大的man命令</li>\n</ol>\n</blockquote>\n<h3 id=\"whatis\"><a href=\"#whatis\" class=\"headerlink\" title=\"whatis\"></a>whatis</h3><p>whatis命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上</p>\n<blockquote>\n<p>whatis命令在用catman -w命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用man -f命令</p>\n</blockquote>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>whatis 命令名称\n</code></pre><h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# whatis cp\ncp                   (1)  - copy files and directories\n[root@centos etc]# whatis ls\nls                   (1)  - list directory contents\n[root@centos etc]# whatis chown\nchown                (1)  - change file owner and group\n[root@centos etc]# whatis rm\nrm                   (1)  - remove files or directories\n</code></pre><h3 id=\"info\"><a href=\"#info\" class=\"headerlink\" title=\"info\"></a>info</h3><p>查看某个命令更详细的说明</p>\n<blockquote>\n<p>就内容来说，info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。</p>\n</blockquote>\n<h4 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>info [选项] [参数]\n</code></pre><h4 id=\"选项列举\"><a href=\"#选项列举\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:left\">添加包含info格式帮助文档的目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:left\">指定要读取的info格式的帮助文档</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:left\">指定首先访问的info帮助文件的节点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-o</td>\n<td style=\"text-align:left\">输出被选择的节点内容到指定文件</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# info cp\n\nFile: coreutils.info,  Node: cp invocation,  Next: dd invocation,  Up: Basic operations\n\n11.1 `cp&#39;: Copy files and directories\n=====================================\n`cp&#39; copies files (or, optionally, directories).  The copy is\ncompletely independent of the original.  You can either copy one file to\nanother, or copy arbitrarily many files to a destination directory.\nSynopses:\n\n     cp [OPTION]... [-T] SOURCE DEST\n     cp [OPTION]... SOURCE... DIRECTORY\n     cp [OPTION]... -t DIRECTORY SOURCE...\n\n   * If two file names are given, `cp&#39; copies the first file to the\n     second.\n\n   * If the `--target-directory&#39; (`-t&#39;) option is given, or failing\n     that if the last file is a directory and the\n     `--no-target-directory&#39; (`-T&#39;) option is not given, `cp&#39; copies\n     each SOURCE file to the specified directory, using the SOURCEs&#39;\n     names.\n\n   Generally, files are written just as they are read.  For exceptions,\nsee the `--sparse&#39; option below.\n省略...\n</code></pre><h4 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><p>在info命令执行后处于帮助文档显示状态时，可以使用如下快捷操作</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">快捷键</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">?键</td>\n<td style=\"text-align:left\">它就会显示info的常用快捷键。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N键</td>\n<td style=\"text-align:left\">显示（相对于本节点的）下一节点的文档内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">P键</td>\n<td style=\"text-align:left\">显示（相对于本节点的）前一节点的文档内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U键</td>\n<td style=\"text-align:left\">进入当前命令所在的主题。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">M键</td>\n<td style=\"text-align:left\">敲M键后输入命令的名称就可以查看该命令的帮助文档了。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">G键</td>\n<td style=\"text-align:left\">敲G键后输入主题名称，进入该主题。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">L键</td>\n<td style=\"text-align:left\">回到上一个访问的页面。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SPACE键</td>\n<td style=\"text-align:left\">向前滚动一页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BACKUP或DEL键</td>\n<td style=\"text-align:left\">向后滚动一页。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Q</td>\n<td style=\"text-align:left\">退出info。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h3><p>man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</p>\n<h4 id=\"用法-2\"><a href=\"#用法-2\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>man [选项] [参数]\n</code></pre><h4 id=\"选项列举-1\"><a href=\"#选项列举-1\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:left\">在所有的man帮助手册中搜索；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:left\">等价于whatis指令，显示给定关键字的简短描述信息；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-P</td>\n<td style=\"text-align:left\">指定内容时使用分页程序；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-M</td>\n<td style=\"text-align:left\">指定man手册搜索的路径。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code class=\"shell\">[root@centos etc]# man rm\nRM(1)                            User Commands                           RM(1)\n\nNAME\n       rm - remove files or directories\n\nSYNOPSIS\n       rm [OPTION]... FILE...\n\nDESCRIPTION\n       This manual page documents the GNU version of rm.  rm removes each specified file.  By default, it does not remove directories.\n....省略以下输出...\n</code></pre>\n<h3 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h3><p>which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<h4 id=\"用法-3\"><a href=\"#用法-3\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>which [选项] [参数]\n</code></pre><h4 id=\"选项列举-2\"><a href=\"#选项列举-2\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n&lt;文件名长度&gt;</td>\n<td style=\"text-align:left\">制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p&lt;文件名长度&gt;</td>\n<td style=\"text-align:left\">与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-w</td>\n<td style=\"text-align:left\">指定输出时栏位的宽度；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-V</td>\n<td style=\"text-align:left\">显示版本信息。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# which -V chown\nGNU which v2.19, Copyright (C) 1999 - 2008 Carlo Wood.\nGNU which comes with ABSOLUTELY NO WARRANTY;\nThis program is free software; your freedom to use, change\nand distribute this program is protected by the GPL.\n[root@centos etc]# which adduser\n/usr/sbin/adduser\n[root@centos etc]# which pwd\n/bin/pwd\n</code></pre><h3 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h3><p>whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>\n<blockquote>\n<p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。</p>\n</blockquote>\n<h4 id=\"用法-4\"><a href=\"#用法-4\" class=\"headerlink\" title=\"用法\"></a>用法</h4><pre><code>whereis [选项] [参数]\n</code></pre><h4 id=\"选项列举-3\"><a href=\"#选项列举-3\" class=\"headerlink\" title=\"选项列举\"></a>选项列举</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令选项</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:left\">只查找二进制文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-B&lt;目录&gt;</td>\n<td style=\"text-align:left\">只在设置的目录下查找二进制文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:left\">不显示文件名前的路径名称；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-m</td>\n<td style=\"text-align:left\">只查找说明文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-M&lt;目录&gt;</td>\n<td style=\"text-align:left\">只在设置的目录下查找说明文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:left\">只查找原始代码文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-S&lt;目录&gt;只在设置的目录下查找原始代码文件；</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:left\">查找不包含指定类型的文件。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>[root@centos etc]# which pwd\n/bin/pwd\n[root@centos etc]# whereis pwd\npwd: /bin/pwd /usr/include/pwd.h /usr/share/man/mann/pwd.n.gz /usr/share/man/man1/pwd.1.gz\n[root@centos etc]# whereis -b  pwd\npwd: /bin/pwd /usr/include/pwd.h\n[root@centos etc]# whereis -s  pwd\npwd:\n</code></pre><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li>linux命令手册大全：<a href=\"http://man.linuxde.net/\" title=\"linux命令手册大全\">http://man.linuxde.net/</a></li>\n</ol>"},{"title":"maven随笔纪录","date":"2016-06-25T03:41:41.000Z","_content":"\n\n# 写在前面\n\n此篇随笔，主要用来纪录博主在日常使用maven过程中的技术知识碎片，里面会包括maven的基本操作和使用过程的问题\n\n\n# maven知识整理\n\n## 向本地仓库添加已有jar包  \n\n<!--more-->\n\n在maven仓库找不到引用的包，同时还要使用maven来管理，此时我们就需要先去其他官网找到我们自己要用的jar包，然后使用`mvn install`将其放到我们的本地的maven仓库，之后后在项目pom.xml里面添加此依赖包就可以\n\n比如引用sqljdbc4.jar包，maven仓库中没有，所以我们先从微软官网下载下来，然后使用下面的命令将期添加到自己的本地仓库中去\n\n```\nD:\\soft\\develop\\java-jars>mvn install:install-file -Dfile=sqljdbc4.jar -DgroupId=com.microsoft.sqlserver -DartifactId=sqljdbc4 -Dversion=4.0 -Dpackaging=jar\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Maven Stub Project (No POM) 1\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-install-plugin:2.3.1:install-file (default-cli) @ standalone-pom ---\n[INFO] Installing D:\\soft\\develop\\java-jars\\sqljdbc4.jar to C:\\Users\\yuanjinan\\.m2\\repository\\com\\microsoft\\sqlserver\\sqljdbc4\\4.0\\sqljdbc4-4.0.jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 0.427s\n[INFO] Finished at: Sat Jun 25 13:32:34 CST 2016\n[INFO] Final Memory: 5M/119M\n[INFO] ------------------------------------------------------------------------\n```\n接着在pom.xml添加依赖\n\n```xml\n<dependency>\n  <groupId>com.microsoft.sqlserver</groupId>\n  <artifactId>sqljdbc4</artifactId>\n  <version>4.0</version>\n</dependency>\n```\n此方法也可以方便把我们自己的项目的jar包安装到本地的maven仓库中去\n","source":"_posts/maven_suibi.md","raw":"---\ntitle: maven随笔纪录\ndate: 2016-06-25 11:41:41\ntags: [maven,随笔,maven使用教程]\ncategories: 知识整理\n---\n\n\n# 写在前面\n\n此篇随笔，主要用来纪录博主在日常使用maven过程中的技术知识碎片，里面会包括maven的基本操作和使用过程的问题\n\n\n# maven知识整理\n\n## 向本地仓库添加已有jar包  \n\n<!--more-->\n\n在maven仓库找不到引用的包，同时还要使用maven来管理，此时我们就需要先去其他官网找到我们自己要用的jar包，然后使用`mvn install`将其放到我们的本地的maven仓库，之后后在项目pom.xml里面添加此依赖包就可以\n\n比如引用sqljdbc4.jar包，maven仓库中没有，所以我们先从微软官网下载下来，然后使用下面的命令将期添加到自己的本地仓库中去\n\n```\nD:\\soft\\develop\\java-jars>mvn install:install-file -Dfile=sqljdbc4.jar -DgroupId=com.microsoft.sqlserver -DartifactId=sqljdbc4 -Dversion=4.0 -Dpackaging=jar\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Maven Stub Project (No POM) 1\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-install-plugin:2.3.1:install-file (default-cli) @ standalone-pom ---\n[INFO] Installing D:\\soft\\develop\\java-jars\\sqljdbc4.jar to C:\\Users\\yuanjinan\\.m2\\repository\\com\\microsoft\\sqlserver\\sqljdbc4\\4.0\\sqljdbc4-4.0.jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 0.427s\n[INFO] Finished at: Sat Jun 25 13:32:34 CST 2016\n[INFO] Final Memory: 5M/119M\n[INFO] ------------------------------------------------------------------------\n```\n接着在pom.xml添加依赖\n\n```xml\n<dependency>\n  <groupId>com.microsoft.sqlserver</groupId>\n  <artifactId>sqljdbc4</artifactId>\n  <version>4.0</version>\n</dependency>\n```\n此方法也可以方便把我们自己的项目的jar包安装到本地的maven仓库中去\n","slug":"maven_suibi","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsw6001mqk5cegb7548r","content":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>此篇随笔，主要用来纪录博主在日常使用maven过程中的技术知识碎片，里面会包括maven的基本操作和使用过程的问题</p>\n<h1 id=\"maven知识整理\"><a href=\"#maven知识整理\" class=\"headerlink\" title=\"maven知识整理\"></a>maven知识整理</h1><h2 id=\"向本地仓库添加已有jar包\"><a href=\"#向本地仓库添加已有jar包\" class=\"headerlink\" title=\"向本地仓库添加已有jar包\"></a>向本地仓库添加已有jar包</h2><a id=\"more\"></a>\n<p>在maven仓库找不到引用的包，同时还要使用maven来管理，此时我们就需要先去其他官网找到我们自己要用的jar包，然后使用<code>mvn install</code>将其放到我们的本地的maven仓库，之后后在项目pom.xml里面添加此依赖包就可以</p>\n<p>比如引用sqljdbc4.jar包，maven仓库中没有，所以我们先从微软官网下载下来，然后使用下面的命令将期添加到自己的本地仓库中去</p>\n<pre><code>D:\\soft\\develop\\java-jars&gt;mvn install:install-file -Dfile=sqljdbc4.jar -DgroupId=com.microsoft.sqlserver -DartifactId=sqljdbc4 -Dversion=4.0 -Dpackaging=jar\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Maven Stub Project (No POM) 1\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-install-plugin:2.3.1:install-file (default-cli) @ standalone-pom ---\n[INFO] Installing D:\\soft\\develop\\java-jars\\sqljdbc4.jar to C:\\Users\\yuanjinan\\.m2\\repository\\com\\microsoft\\sqlserver\\sqljdbc4\\4.0\\sqljdbc4-4.0.jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 0.427s\n[INFO] Finished at: Sat Jun 25 13:32:34 CST 2016\n[INFO] Final Memory: 5M/119M\n[INFO] ------------------------------------------------------------------------\n</code></pre><p>接着在pom.xml添加依赖</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n  &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;\n  &lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt;\n  &lt;version&gt;4.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>此方法也可以方便把我们自己的项目的jar包安装到本地的maven仓库中去</p>\n","excerpt":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>此篇随笔，主要用来纪录博主在日常使用maven过程中的技术知识碎片，里面会包括maven的基本操作和使用过程的问题</p>\n<h1 id=\"maven知识整理\"><a href=\"#maven知识整理\" class=\"headerlink\" title=\"maven知识整理\"></a>maven知识整理</h1><h2 id=\"向本地仓库添加已有jar包\"><a href=\"#向本地仓库添加已有jar包\" class=\"headerlink\" title=\"向本地仓库添加已有jar包\"></a>向本地仓库添加已有jar包</h2>","more":"<p>在maven仓库找不到引用的包，同时还要使用maven来管理，此时我们就需要先去其他官网找到我们自己要用的jar包，然后使用<code>mvn install</code>将其放到我们的本地的maven仓库，之后后在项目pom.xml里面添加此依赖包就可以</p>\n<p>比如引用sqljdbc4.jar包，maven仓库中没有，所以我们先从微软官网下载下来，然后使用下面的命令将期添加到自己的本地仓库中去</p>\n<pre><code>D:\\soft\\develop\\java-jars&gt;mvn install:install-file -Dfile=sqljdbc4.jar -DgroupId=com.microsoft.sqlserver -DartifactId=sqljdbc4 -Dversion=4.0 -Dpackaging=jar\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Maven Stub Project (No POM) 1\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-install-plugin:2.3.1:install-file (default-cli) @ standalone-pom ---\n[INFO] Installing D:\\soft\\develop\\java-jars\\sqljdbc4.jar to C:\\Users\\yuanjinan\\.m2\\repository\\com\\microsoft\\sqlserver\\sqljdbc4\\4.0\\sqljdbc4-4.0.jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 0.427s\n[INFO] Finished at: Sat Jun 25 13:32:34 CST 2016\n[INFO] Final Memory: 5M/119M\n[INFO] ------------------------------------------------------------------------\n</code></pre><p>接着在pom.xml添加依赖</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n  &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;\n  &lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt;\n  &lt;version&gt;4.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>此方法也可以方便把我们自己的项目的jar包安装到本地的maven仓库中去</p>"},{"title":"markdown语法手册","date":"2016-06-19T01:31:15.000Z","_content":"\n# Cmd Markdown 简明语法手册\n\n标签： Cmd-Markdown\n\n---\n\n### 1. 斜体和粗体\n\n使用 * 和 ** 表示斜体和粗体。\n\n示例：\n\n这是 *斜体*，这是 **粗体**。\n\n### 2. 分级标题\n\n使用 === 表示一级标题，使用 --- 表示二级标题。\n\n示例：\n\n<!--more-->\n\n```\n这是一个一级标题\n============================\n\n这是一个二级标题\n--------------------------------------------------\n\n### 这是一个三级标题\n```\n\n你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。\n\n### 3. 外链接\n\n使用 \\[描述](链接地址) 为文字增加外链接。\n\n示例：\n\n这是去往 [本人博客](http://jumpbyte.cn) 的链接。\n\n### 4. 无序列表\n\n使用 *，+，- 表示无序列表。\n\n示例：\n\n- 无序列表项 一\n- 无序列表项 二\n- 无序列表项 三\n\n### 5. 有序列表\n\n使用数字和点表示有序列表。\n\n示例：\n\n1. 有序列表项 一\n2. 有序列表项 二\n3. 有序列表项 三\n\n### 6. 文字引用\n\n使用 > 表示文字引用。\n\n示例：\n\n> 野火烧不尽，春风吹又生。\n\n### 7. 行内代码块\n\n使用 \\`代码` 表示行内代码块。\n\n示例：\n\n让我们聊聊 `html`。\n\n\n### 8.  代码块\n\n使用 四个缩进空格 表示代码块。\n\n示例：\n\n    这是一个代码块，此行左侧有四个不可见的空格。\n\n### 9.  插入图像\n\n使用 \\!\\[描述](图片链接地址) 插入图像。\n\n示例：\n\n![我的头像](http://tva4.sinaimg.cn/crop.154.494.1235.1235.180/7462786bjw8f4rmzsmb6kj216w1psdlj.jpg)\n\n# Cmd Markdown 高阶语法手册\n\n### 1. 内容目录\n\n在段落中填写 `[TOC]` 以显示全文内容的目录结构。\n\n[TOC]\n\n### 2. 标签分类\n\n在编辑区任意行的列首位置输入以下代码给文稿标签：\n\n标签： 数学 英语 Markdown\n\n或者\n\nTags： 数学 英语 Markdown\n\n### 3. 删除线\n\n使用 ~~ 表示删除线。\n\n~~这是一段错误的文本。~~\n\n### 4. 注脚\n\n使用 [^keyword] 表示注脚。\n\n这是一个注脚[^footnote]的样例。\n\n这是第二个注脚[^footnote2]的样例。\n\n### 5. LaTeX 公式\n\n$ 表示行内公式：\n\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n\n$$ 表示整行公式：\n\n$$\\sum_{i=1}^n a_i=0$$\n\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$\n\n访问 [MathJax](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference) 参考更多使用方法。\n\n### 6. 加强的代码块\n\n支持四十一种编程语言的语法高亮的显示，行号显示。\n\n非代码示例：\n\n```\n$ sudo apt-get install vim-gnome\n```\n\nPython 示例：\n\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n\n>>> message = '''interpreter\n... prompt'''\n```\n\nJavaScript 示例：\n\n``` javascript\n/**\n* nth element in the fibonacci series.\n* @param n >= 0\n* @return the nth element, >= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n >= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n\ndocument.write(fib(10));\n```\n\n### 7. 流程图\n\n#### 示例\n\n```flow\nst=>start: Start:>https://www.zybuluo.com\nio=>inputoutput: verification\nop=>operation: Your Operation\ncond=>condition: Yes or No?\nsub=>subroutine: Your Subroutine\ne=>end\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n#### 更多语法参考：[流程图语法参考](http://adrai.github.io/flowchart.js/)\n\n### 8. 序列图\n\n#### 示例 1\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n#### 示例 2\n\n```seq\nTitle: Here is a title\nA->B: Normal line\nB-->C: Dashed line\nC->>D: Open arrow\nD-->>A: Dashed open arrow\n```\n\n#### 更多语法参考：[序列图语法参考](http://bramp.github.io/js-sequence-diagrams/)\n\n### 9. 表格支持\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n\n### 10. 定义型列表\n\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n\n        代码块（左侧有八个不可见的空格）\n\n### 11. Html 标签\n\n本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：\n\n    <table>\n        <tr>\n            <th rowspan=\"2\">值班人员</th>\n            <th>星期一</th>\n            <th>星期二</th>\n            <th>星期三</th>\n        </tr>\n        <tr>\n            <td>李强</td>\n            <td>张明</td>\n            <td>王平</td>\n        </tr>\n    </table>\n\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n### 12. 内嵌图标\n\n本站的图标系统对外开放，在文档中输入\n\n    <i class=\"icon-weibo\"></i>\n\n即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i>\n\n替换 上述 `i 标签` 内的 `icon-weibo` 以显示不同的图标，例如：\n\n    <i class=\"icon-renren\"></i>\n\n即显示人人的图标： <i class=\"icon-renren icon-2x\"></i>\n\n更多的图标和玩法可以参看 [font-awesome](http://fortawesome.github.io/Font-Awesome/3.2.1/icons/) 官方网站。\n\n### 13. 待办事宜 Todo 列表\n\n使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：\n\n    - [ ] **Cmd Markdown 开发**\n        - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n        - [ ] 支持以 PDF 格式导出文稿\n        - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n        - [x] 改进 LaTex 功能\n            - [x] 修复 LaTex 公式渲染问题\n            - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n    - [ ] **七月旅行准备**\n        - [ ] 准备邮轮上需要携带的物品\n        - [ ] 浏览日本免税店的物品\n        - [x] 购买蓝宝石公主号七月一日的船票\n\n对应显示如下待办事宜 Todo 列表：\n\n- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票\n\n\n[^footnote]: 这是一个 *注脚* 的 **文本**。\n\n[^footnote2]: 这是另一个 *注脚* 的 **文本**。\n","source":"_posts/md-help.md","raw":"---\ntitle: markdown语法手册\ndate: 2016-06-19 09:31:15\ncategories: markdown\ntags: [markdown,markdown语法]\n---\n\n# Cmd Markdown 简明语法手册\n\n标签： Cmd-Markdown\n\n---\n\n### 1. 斜体和粗体\n\n使用 * 和 ** 表示斜体和粗体。\n\n示例：\n\n这是 *斜体*，这是 **粗体**。\n\n### 2. 分级标题\n\n使用 === 表示一级标题，使用 --- 表示二级标题。\n\n示例：\n\n<!--more-->\n\n```\n这是一个一级标题\n============================\n\n这是一个二级标题\n--------------------------------------------------\n\n### 这是一个三级标题\n```\n\n你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。\n\n### 3. 外链接\n\n使用 \\[描述](链接地址) 为文字增加外链接。\n\n示例：\n\n这是去往 [本人博客](http://jumpbyte.cn) 的链接。\n\n### 4. 无序列表\n\n使用 *，+，- 表示无序列表。\n\n示例：\n\n- 无序列表项 一\n- 无序列表项 二\n- 无序列表项 三\n\n### 5. 有序列表\n\n使用数字和点表示有序列表。\n\n示例：\n\n1. 有序列表项 一\n2. 有序列表项 二\n3. 有序列表项 三\n\n### 6. 文字引用\n\n使用 > 表示文字引用。\n\n示例：\n\n> 野火烧不尽，春风吹又生。\n\n### 7. 行内代码块\n\n使用 \\`代码` 表示行内代码块。\n\n示例：\n\n让我们聊聊 `html`。\n\n\n### 8.  代码块\n\n使用 四个缩进空格 表示代码块。\n\n示例：\n\n    这是一个代码块，此行左侧有四个不可见的空格。\n\n### 9.  插入图像\n\n使用 \\!\\[描述](图片链接地址) 插入图像。\n\n示例：\n\n![我的头像](http://tva4.sinaimg.cn/crop.154.494.1235.1235.180/7462786bjw8f4rmzsmb6kj216w1psdlj.jpg)\n\n# Cmd Markdown 高阶语法手册\n\n### 1. 内容目录\n\n在段落中填写 `[TOC]` 以显示全文内容的目录结构。\n\n[TOC]\n\n### 2. 标签分类\n\n在编辑区任意行的列首位置输入以下代码给文稿标签：\n\n标签： 数学 英语 Markdown\n\n或者\n\nTags： 数学 英语 Markdown\n\n### 3. 删除线\n\n使用 ~~ 表示删除线。\n\n~~这是一段错误的文本。~~\n\n### 4. 注脚\n\n使用 [^keyword] 表示注脚。\n\n这是一个注脚[^footnote]的样例。\n\n这是第二个注脚[^footnote2]的样例。\n\n### 5. LaTeX 公式\n\n$ 表示行内公式：\n\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n\n$$ 表示整行公式：\n\n$$\\sum_{i=1}^n a_i=0$$\n\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$\n\n访问 [MathJax](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference) 参考更多使用方法。\n\n### 6. 加强的代码块\n\n支持四十一种编程语言的语法高亮的显示，行号显示。\n\n非代码示例：\n\n```\n$ sudo apt-get install vim-gnome\n```\n\nPython 示例：\n\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n\n>>> message = '''interpreter\n... prompt'''\n```\n\nJavaScript 示例：\n\n``` javascript\n/**\n* nth element in the fibonacci series.\n* @param n >= 0\n* @return the nth element, >= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n >= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n\ndocument.write(fib(10));\n```\n\n### 7. 流程图\n\n#### 示例\n\n```flow\nst=>start: Start:>https://www.zybuluo.com\nio=>inputoutput: verification\nop=>operation: Your Operation\ncond=>condition: Yes or No?\nsub=>subroutine: Your Subroutine\ne=>end\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n#### 更多语法参考：[流程图语法参考](http://adrai.github.io/flowchart.js/)\n\n### 8. 序列图\n\n#### 示例 1\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n#### 示例 2\n\n```seq\nTitle: Here is a title\nA->B: Normal line\nB-->C: Dashed line\nC->>D: Open arrow\nD-->>A: Dashed open arrow\n```\n\n#### 更多语法参考：[序列图语法参考](http://bramp.github.io/js-sequence-diagrams/)\n\n### 9. 表格支持\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n\n### 10. 定义型列表\n\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n\n        代码块（左侧有八个不可见的空格）\n\n### 11. Html 标签\n\n本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：\n\n    <table>\n        <tr>\n            <th rowspan=\"2\">值班人员</th>\n            <th>星期一</th>\n            <th>星期二</th>\n            <th>星期三</th>\n        </tr>\n        <tr>\n            <td>李强</td>\n            <td>张明</td>\n            <td>王平</td>\n        </tr>\n    </table>\n\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n### 12. 内嵌图标\n\n本站的图标系统对外开放，在文档中输入\n\n    <i class=\"icon-weibo\"></i>\n\n即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i>\n\n替换 上述 `i 标签` 内的 `icon-weibo` 以显示不同的图标，例如：\n\n    <i class=\"icon-renren\"></i>\n\n即显示人人的图标： <i class=\"icon-renren icon-2x\"></i>\n\n更多的图标和玩法可以参看 [font-awesome](http://fortawesome.github.io/Font-Awesome/3.2.1/icons/) 官方网站。\n\n### 13. 待办事宜 Todo 列表\n\n使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：\n\n    - [ ] **Cmd Markdown 开发**\n        - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n        - [ ] 支持以 PDF 格式导出文稿\n        - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n        - [x] 改进 LaTex 功能\n            - [x] 修复 LaTex 公式渲染问题\n            - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n    - [ ] **七月旅行准备**\n        - [ ] 准备邮轮上需要携带的物品\n        - [ ] 浏览日本免税店的物品\n        - [x] 购买蓝宝石公主号七月一日的船票\n\n对应显示如下待办事宜 Todo 列表：\n\n- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票\n\n\n[^footnote]: 这是一个 *注脚* 的 **文本**。\n\n[^footnote2]: 这是另一个 *注脚* 的 **文本**。\n","slug":"md-help","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obsw7001oqk5cyf12xcmp","content":"<h1 id=\"Cmd-Markdown-简明语法手册\"><a href=\"#Cmd-Markdown-简明语法手册\" class=\"headerlink\" title=\"Cmd Markdown 简明语法手册\"></a>Cmd Markdown 简明语法手册</h1><p>标签： Cmd-Markdown</p>\n<hr>\n<h3 id=\"1-斜体和粗体\"><a href=\"#1-斜体和粗体\" class=\"headerlink\" title=\"1. 斜体和粗体\"></a>1. 斜体和粗体</h3><p>使用 <em> 和 *</em> 表示斜体和粗体。</p>\n<p>示例：</p>\n<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>\n<h3 id=\"2-分级标题\"><a href=\"#2-分级标题\" class=\"headerlink\" title=\"2. 分级标题\"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p>\n<p>示例：</p>\n<a id=\"more\"></a>\n<pre><code>这是一个一级标题\n============================\n\n这是一个二级标题\n--------------------------------------------------\n\n### 这是一个三级标题\n</code></pre><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p>\n<h3 id=\"3-外链接\"><a href=\"#3-外链接\" class=\"headerlink\" title=\"3. 外链接\"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>\n<p>示例：</p>\n<p>这是去往 <a href=\"http://jumpbyte.cn\" target=\"_blank\" rel=\"external\">本人博客</a> 的链接。</p>\n<h3 id=\"4-无序列表\"><a href=\"#4-无序列表\" class=\"headerlink\" title=\"4. 无序列表\"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p>\n<p>示例：</p>\n<ul>\n<li>无序列表项 一</li>\n<li>无序列表项 二</li>\n<li>无序列表项 三</li>\n</ul>\n<h3 id=\"5-有序列表\"><a href=\"#5-有序列表\" class=\"headerlink\" title=\"5. 有序列表\"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p>\n<p>示例：</p>\n<ol>\n<li>有序列表项 一</li>\n<li>有序列表项 二</li>\n<li>有序列表项 三</li>\n</ol>\n<h3 id=\"6-文字引用\"><a href=\"#6-文字引用\" class=\"headerlink\" title=\"6. 文字引用\"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p>\n<p>示例：</p>\n<blockquote>\n<p>野火烧不尽，春风吹又生。</p>\n</blockquote>\n<h3 id=\"7-行内代码块\"><a href=\"#7-行内代码块\" class=\"headerlink\" title=\"7. 行内代码块\"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>\n<p>示例：</p>\n<p>让我们聊聊 <code>html</code>。</p>\n<h3 id=\"8-代码块\"><a href=\"#8-代码块\" class=\"headerlink\" title=\"8.  代码块\"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p>\n<p>示例：</p>\n<pre><code>这是一个代码块，此行左侧有四个不可见的空格。\n</code></pre><h3 id=\"9-插入图像\"><a href=\"#9-插入图像\" class=\"headerlink\" title=\"9.  插入图像\"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>\n<p>示例：</p>\n<p><img src=\"http://tva4.sinaimg.cn/crop.154.494.1235.1235.180/7462786bjw8f4rmzsmb6kj216w1psdlj.jpg\" alt=\"我的头像\"></p>\n<h1 id=\"Cmd-Markdown-高阶语法手册\"><a href=\"#Cmd-Markdown-高阶语法手册\" class=\"headerlink\" title=\"Cmd Markdown 高阶语法手册\"></a>Cmd Markdown 高阶语法手册</h1><h3 id=\"1-内容目录\"><a href=\"#1-内容目录\" class=\"headerlink\" title=\"1. 内容目录\"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>\n<p>[TOC]</p>\n<h3 id=\"2-标签分类\"><a href=\"#2-标签分类\" class=\"headerlink\" title=\"2. 标签分类\"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>\n<p>标签： 数学 英语 Markdown</p>\n<p>或者</p>\n<p>Tags： 数学 英语 Markdown</p>\n<h3 id=\"3-删除线\"><a href=\"#3-删除线\" class=\"headerlink\" title=\"3. 删除线\"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p>\n<p><del>这是一段错误的文本。</del></p>\n<h3 id=\"4-注脚\"><a href=\"#4-注脚\" class=\"headerlink\" title=\"4. 注脚\"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p>\n<p>这是一个注脚[^footnote]的样例。</p>\n<p>这是第二个注脚[^footnote2]的样例。</p>\n<h3 id=\"5-LaTeX-公式\"><a href=\"#5-LaTeX-公式\" class=\"headerlink\" title=\"5. LaTeX 公式\"></a>5. LaTeX 公式</h3><p>$ 表示行内公式：</p>\n<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>\n<p>$$ 表示整行公式：</p>\n<p>$$\\sum_{i=1}^n a_i=0$$</p>\n<p>$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$</p>\n<p>$$\\sum^{j-1}<em>{k=0}{\\widehat{\\gamma}</em>{kj} z_k}$$</p>\n<p>访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"external\">MathJax</a> 参考更多使用方法。</p>\n<h3 id=\"6-加强的代码块\"><a href=\"#6-加强的代码块\" class=\"headerlink\" title=\"6. 加强的代码块\"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>\n<p>非代码示例：</p>\n<pre><code>$ sudo apt-get install vim-gnome\n</code></pre><p>Python 示例：</p>\n<pre><code class=\"python\">@requires_authorization\ndef somefunc(param1=&#39;&#39;, param2=0):\n    &#39;&#39;&#39;A docstring&#39;&#39;&#39;\n    if param1 &gt; param2: # interesting\n        print &#39;Greater&#39;\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n\n&gt;&gt;&gt; message = &#39;&#39;&#39;interpreter\n... prompt&#39;&#39;&#39;\n</code></pre>\n<p>JavaScript 示例：</p>\n<pre><code class=\"javascript\">/**\n* nth element in the fibonacci series.\n* @param n &gt;= 0\n* @return the nth element, &gt;= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n &gt;= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n\ndocument.write(fib(10));\n</code></pre>\n<h3 id=\"7-流程图\"><a href=\"#7-流程图\" class=\"headerlink\" title=\"7. 流程图\"></a>7. 流程图</h3><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><pre><code class=\"flow\">st=&gt;start: Start:&gt;https://www.zybuluo.com\nio=&gt;inputoutput: verification\nop=&gt;operation: Your Operation\ncond=&gt;condition: Yes or No?\nsub=&gt;subroutine: Your Subroutine\ne=&gt;end\n\nst-&gt;io-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;sub-&gt;io\n</code></pre>\n<h4 id=\"更多语法参考：流程图语法参考\"><a href=\"#更多语法参考：流程图语法参考\" class=\"headerlink\" title=\"更多语法参考：流程图语法参考\"></a>更多语法参考：<a href=\"http://adrai.github.io/flowchart.js/\" target=\"_blank\" rel=\"external\">流程图语法参考</a></h4><h3 id=\"8-序列图\"><a href=\"#8-序列图\" class=\"headerlink\" title=\"8. 序列图\"></a>8. 序列图</h3><h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1\"></a>示例 1</h4><pre><code class=\"seq\">Alice-&gt;Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob--&gt;Alice: I am good thanks!\n</code></pre>\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2\"></a>示例 2</h4><pre><code class=\"seq\">Title: Here is a title\nA-&gt;B: Normal line\nB--&gt;C: Dashed line\nC-&gt;&gt;D: Open arrow\nD--&gt;&gt;A: Dashed open arrow\n</code></pre>\n<h4 id=\"更多语法参考：序列图语法参考\"><a href=\"#更多语法参考：序列图语法参考\" class=\"headerlink\" title=\"更多语法参考：序列图语法参考\"></a>更多语法参考：<a href=\"http://bramp.github.io/js-sequence-diagrams/\" target=\"_blank\" rel=\"external\">序列图语法参考</a></h4><h3 id=\"9-表格支持\"><a href=\"#9-表格支持\" class=\"headerlink\" title=\"9. 表格支持\"></a>9. 表格支持</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算机</td>\n<td style=\"text-align:right\">\\$1600</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td style=\"text-align:right\">\\$12</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td style=\"text-align:right\">\\$1</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"10-定义型列表\"><a href=\"#10-定义型列表\" class=\"headerlink\" title=\"10. 定义型列表\"></a>10. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p>\n<p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p>\n<pre><code>    代码块（左侧有八个不可见的空格）\n</code></pre><h3 id=\"11-Html-标签\"><a href=\"#11-Html-标签\" class=\"headerlink\" title=\"11. Html 标签\"></a>11. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>\n<pre><code>&lt;table&gt;\n    &lt;tr&gt;\n        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;\n        &lt;th&gt;星期一&lt;/th&gt;\n        &lt;th&gt;星期二&lt;/th&gt;\n        &lt;th&gt;星期三&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;李强&lt;/td&gt;\n        &lt;td&gt;张明&lt;/td&gt;\n        &lt;td&gt;王平&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre><table><br>    <tr><br>        <th rowspan=\"2\">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td>李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table>\n\n<h3 id=\"12-内嵌图标\"><a href=\"#12-内嵌图标\" class=\"headerlink\" title=\"12. 内嵌图标\"></a>12. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p>\n<pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;\n</code></pre><p>即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i></p>\n<p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p>\n<pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;\n</code></pre><p>即显示人人的图标： <i class=\"icon-renren icon-2x\"></i></p>\n<p>更多的图标和玩法可以参看 <a href=\"http://fortawesome.github.io/Font-Awesome/3.2.1/icons/\" target=\"_blank\" rel=\"external\">font-awesome</a> 官方网站。</p>\n<h3 id=\"13-待办事宜-Todo-列表\"><a href=\"#13-待办事宜-Todo-列表\" class=\"headerlink\" title=\"13. 待办事宜 Todo 列表\"></a>13. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>\n<pre><code>- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票\n</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>\n<ul>\n<li>[ ] <strong>Cmd Markdown 开发</strong><ul>\n<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li>[ ] 支持以 PDF 格式导出文稿</li>\n<li>[x] 新增Todo列表功能 <a href=\"https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments\" target=\"_blank\" rel=\"external\">语法参考</a></li>\n<li>[x] 改进 LaTex 功能<ul>\n<li>[x] 修复 LaTex 公式渲染问题</li>\n<li>[x] 新增 LaTex 公式编号功能 <a href=\"http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers\" target=\"_blank\" rel=\"external\">语法参考</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>[ ] <strong>七月旅行准备</strong><ul>\n<li>[ ] 准备邮轮上需要携带的物品</li>\n<li>[ ] 浏览日本免税店的物品</li>\n<li>[x] 购买蓝宝石公主号七月一日的船票</li>\n</ul>\n</li>\n</ul>\n<p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p>\n<p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>\n","excerpt":"<h1 id=\"Cmd-Markdown-简明语法手册\"><a href=\"#Cmd-Markdown-简明语法手册\" class=\"headerlink\" title=\"Cmd Markdown 简明语法手册\"></a>Cmd Markdown 简明语法手册</h1><p>标签： Cmd-Markdown</p>\n<hr>\n<h3 id=\"1-斜体和粗体\"><a href=\"#1-斜体和粗体\" class=\"headerlink\" title=\"1. 斜体和粗体\"></a>1. 斜体和粗体</h3><p>使用 <em> 和 *</em> 表示斜体和粗体。</p>\n<p>示例：</p>\n<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>\n<h3 id=\"2-分级标题\"><a href=\"#2-分级标题\" class=\"headerlink\" title=\"2. 分级标题\"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p>\n<p>示例：</p>","more":"<pre><code>这是一个一级标题\n============================\n\n这是一个二级标题\n--------------------------------------------------\n\n### 这是一个三级标题\n</code></pre><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p>\n<h3 id=\"3-外链接\"><a href=\"#3-外链接\" class=\"headerlink\" title=\"3. 外链接\"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>\n<p>示例：</p>\n<p>这是去往 <a href=\"http://jumpbyte.cn\">本人博客</a> 的链接。</p>\n<h3 id=\"4-无序列表\"><a href=\"#4-无序列表\" class=\"headerlink\" title=\"4. 无序列表\"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p>\n<p>示例：</p>\n<ul>\n<li>无序列表项 一</li>\n<li>无序列表项 二</li>\n<li>无序列表项 三</li>\n</ul>\n<h3 id=\"5-有序列表\"><a href=\"#5-有序列表\" class=\"headerlink\" title=\"5. 有序列表\"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p>\n<p>示例：</p>\n<ol>\n<li>有序列表项 一</li>\n<li>有序列表项 二</li>\n<li>有序列表项 三</li>\n</ol>\n<h3 id=\"6-文字引用\"><a href=\"#6-文字引用\" class=\"headerlink\" title=\"6. 文字引用\"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p>\n<p>示例：</p>\n<blockquote>\n<p>野火烧不尽，春风吹又生。</p>\n</blockquote>\n<h3 id=\"7-行内代码块\"><a href=\"#7-行内代码块\" class=\"headerlink\" title=\"7. 行内代码块\"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>\n<p>示例：</p>\n<p>让我们聊聊 <code>html</code>。</p>\n<h3 id=\"8-代码块\"><a href=\"#8-代码块\" class=\"headerlink\" title=\"8.  代码块\"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p>\n<p>示例：</p>\n<pre><code>这是一个代码块，此行左侧有四个不可见的空格。\n</code></pre><h3 id=\"9-插入图像\"><a href=\"#9-插入图像\" class=\"headerlink\" title=\"9.  插入图像\"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>\n<p>示例：</p>\n<p><img src=\"http://tva4.sinaimg.cn/crop.154.494.1235.1235.180/7462786bjw8f4rmzsmb6kj216w1psdlj.jpg\" alt=\"我的头像\"></p>\n<h1 id=\"Cmd-Markdown-高阶语法手册\"><a href=\"#Cmd-Markdown-高阶语法手册\" class=\"headerlink\" title=\"Cmd Markdown 高阶语法手册\"></a>Cmd Markdown 高阶语法手册</h1><h3 id=\"1-内容目录\"><a href=\"#1-内容目录\" class=\"headerlink\" title=\"1. 内容目录\"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>\n<p>[TOC]</p>\n<h3 id=\"2-标签分类\"><a href=\"#2-标签分类\" class=\"headerlink\" title=\"2. 标签分类\"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>\n<p>标签： 数学 英语 Markdown</p>\n<p>或者</p>\n<p>Tags： 数学 英语 Markdown</p>\n<h3 id=\"3-删除线\"><a href=\"#3-删除线\" class=\"headerlink\" title=\"3. 删除线\"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p>\n<p><del>这是一段错误的文本。</del></p>\n<h3 id=\"4-注脚\"><a href=\"#4-注脚\" class=\"headerlink\" title=\"4. 注脚\"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p>\n<p>这是一个注脚[^footnote]的样例。</p>\n<p>这是第二个注脚[^footnote2]的样例。</p>\n<h3 id=\"5-LaTeX-公式\"><a href=\"#5-LaTeX-公式\" class=\"headerlink\" title=\"5. LaTeX 公式\"></a>5. LaTeX 公式</h3><p>$ 表示行内公式：</p>\n<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>\n<p>$$ 表示整行公式：</p>\n<p>$$\\sum_{i=1}^n a_i=0$$</p>\n<p>$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$</p>\n<p>$$\\sum^{j-1}<em>{k=0}{\\widehat{\\gamma}</em>{kj} z_k}$$</p>\n<p>访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">MathJax</a> 参考更多使用方法。</p>\n<h3 id=\"6-加强的代码块\"><a href=\"#6-加强的代码块\" class=\"headerlink\" title=\"6. 加强的代码块\"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>\n<p>非代码示例：</p>\n<pre><code>$ sudo apt-get install vim-gnome\n</code></pre><p>Python 示例：</p>\n<pre><code class=\"python\">@requires_authorization\ndef somefunc(param1=&#39;&#39;, param2=0):\n    &#39;&#39;&#39;A docstring&#39;&#39;&#39;\n    if param1 &gt; param2: # interesting\n        print &#39;Greater&#39;\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n\n&gt;&gt;&gt; message = &#39;&#39;&#39;interpreter\n... prompt&#39;&#39;&#39;\n</code></pre>\n<p>JavaScript 示例：</p>\n<pre><code class=\"javascript\">/**\n* nth element in the fibonacci series.\n* @param n &gt;= 0\n* @return the nth element, &gt;= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n &gt;= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n\ndocument.write(fib(10));\n</code></pre>\n<h3 id=\"7-流程图\"><a href=\"#7-流程图\" class=\"headerlink\" title=\"7. 流程图\"></a>7. 流程图</h3><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><pre><code class=\"flow\">st=&gt;start: Start:&gt;https://www.zybuluo.com\nio=&gt;inputoutput: verification\nop=&gt;operation: Your Operation\ncond=&gt;condition: Yes or No?\nsub=&gt;subroutine: Your Subroutine\ne=&gt;end\n\nst-&gt;io-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;sub-&gt;io\n</code></pre>\n<h4 id=\"更多语法参考：流程图语法参考\"><a href=\"#更多语法参考：流程图语法参考\" class=\"headerlink\" title=\"更多语法参考：流程图语法参考\"></a>更多语法参考：<a href=\"http://adrai.github.io/flowchart.js/\">流程图语法参考</a></h4><h3 id=\"8-序列图\"><a href=\"#8-序列图\" class=\"headerlink\" title=\"8. 序列图\"></a>8. 序列图</h3><h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1\"></a>示例 1</h4><pre><code class=\"seq\">Alice-&gt;Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob--&gt;Alice: I am good thanks!\n</code></pre>\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2\"></a>示例 2</h4><pre><code class=\"seq\">Title: Here is a title\nA-&gt;B: Normal line\nB--&gt;C: Dashed line\nC-&gt;&gt;D: Open arrow\nD--&gt;&gt;A: Dashed open arrow\n</code></pre>\n<h4 id=\"更多语法参考：序列图语法参考\"><a href=\"#更多语法参考：序列图语法参考\" class=\"headerlink\" title=\"更多语法参考：序列图语法参考\"></a>更多语法参考：<a href=\"http://bramp.github.io/js-sequence-diagrams/\">序列图语法参考</a></h4><h3 id=\"9-表格支持\"><a href=\"#9-表格支持\" class=\"headerlink\" title=\"9. 表格支持\"></a>9. 表格支持</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算机</td>\n<td style=\"text-align:right\">\\$1600</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td style=\"text-align:right\">\\$12</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td style=\"text-align:right\">\\$1</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"10-定义型列表\"><a href=\"#10-定义型列表\" class=\"headerlink\" title=\"10. 定义型列表\"></a>10. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p>\n<p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p>\n<pre><code>    代码块（左侧有八个不可见的空格）\n</code></pre><h3 id=\"11-Html-标签\"><a href=\"#11-Html-标签\" class=\"headerlink\" title=\"11. Html 标签\"></a>11. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>\n<pre><code>&lt;table&gt;\n    &lt;tr&gt;\n        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;\n        &lt;th&gt;星期一&lt;/th&gt;\n        &lt;th&gt;星期二&lt;/th&gt;\n        &lt;th&gt;星期三&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;李强&lt;/td&gt;\n        &lt;td&gt;张明&lt;/td&gt;\n        &lt;td&gt;王平&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre><table><br>    <tr><br>        <th rowspan=\"2\">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td>李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table>\n\n<h3 id=\"12-内嵌图标\"><a href=\"#12-内嵌图标\" class=\"headerlink\" title=\"12. 内嵌图标\"></a>12. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p>\n<pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;\n</code></pre><p>即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i></p>\n<p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p>\n<pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;\n</code></pre><p>即显示人人的图标： <i class=\"icon-renren icon-2x\"></i></p>\n<p>更多的图标和玩法可以参看 <a href=\"http://fortawesome.github.io/Font-Awesome/3.2.1/icons/\">font-awesome</a> 官方网站。</p>\n<h3 id=\"13-待办事宜-Todo-列表\"><a href=\"#13-待办事宜-Todo-列表\" class=\"headerlink\" title=\"13. 待办事宜 Todo 列表\"></a>13. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>\n<pre><code>- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票\n</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>\n<ul>\n<li>[ ] <strong>Cmd Markdown 开发</strong><ul>\n<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li>[ ] 支持以 PDF 格式导出文稿</li>\n<li>[x] 新增Todo列表功能 <a href=\"https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments\">语法参考</a></li>\n<li>[x] 改进 LaTex 功能<ul>\n<li>[x] 修复 LaTex 公式渲染问题</li>\n<li>[x] 新增 LaTex 公式编号功能 <a href=\"http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers\">语法参考</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>[ ] <strong>七月旅行准备</strong><ul>\n<li>[ ] 准备邮轮上需要携带的物品</li>\n<li>[ ] 浏览日本免税店的物品</li>\n<li>[x] 购买蓝宝石公主号七月一日的船票</li>\n</ul>\n</li>\n</ul>\n<p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p>\n<p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>"},{"title":"Spring Boot+SpringMVC4实现单文件多文件上传","date":"2016-09-02T09:33:38.000Z","_content":"\n本文我们将学习如何在SpringMVC4中实现文件的上传，示例将提供单文件和多文件的上传的演示。使用更少的XML配置，我们将需要为文件上传配置一个MultipartConfigElement Bean对象，控制器中方法的参数应该使用MultipartFile类接受上传文件。同时在JSP页面表单，enctype属性要设置成多部分表单数据(multipart/form-data),现在来说下我们的示例代码\n<!--more-->\n\n### 开发工具\n\n  运行此示例我们需要准备好以下软件环境\n- JDK7\n- Eclipse\n- Tomcat7\n- Gradle 2.0 for Spring Boot\n\n### Eclipse示例项目结构\n\n为了更好的理解，我们先整体看下示例类文件和JSP页面的存放结构\n![ Eclipse示例项目结构](http://oaefo3hoy.bkt.clouddn.com/16-9-2/15447753.jpg)\n\n### 控制器：使用MultipartFile类\n\n本示例我们要演示单文件和多文件上传，所以我们创建了两个不同上传文件的方法。\n\n单文件上传方法里需要包含有如下的一个参数：\n\n```Java\n@RequestParam(\"file\") MultipartFile file\n```\n多文件上传方法中，方法参数如下：\n```java\n@RequestParam(\"file\") MultipartFile[]  file\n```\n从MultipartFile对象中获取上传文件的名称保存到你期望保存路径位置，整个上传文件代码逻辑如下：\n\n**文件清单：FileUploadController.java**\n```\npackage com.concretepage;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\n@Controller\npublic class FileUploadController {\n    @RequestMapping(value=\"/singleUpload\")\n    public String singleUpload(){\n    \treturn \"singleUpload\";\n    }\n    @RequestMapping(value=\"/singleSave\", method=RequestMethod.POST )\n    public @ResponseBody String singleSave(@RequestParam(\"file\") MultipartFile file, @RequestParam(\"desc\") String desc ){\n    \tSystem.out.println(\"File Description:\"+desc);\n    \tString fileName = null;\n    \tif (!file.isEmpty()) {\n            try {\n                fileName = file.getOriginalFilename();\n                byte[] bytes = file.getBytes();\n                BufferedOutputStream buffStream =\n                        new BufferedOutputStream(new FileOutputStream(new File(\"F:/cp/\" + fileName)));\n                buffStream.write(bytes);\n                buffStream.close();\n                return \"You have successfully uploaded \" + fileName;\n            } catch (Exception e) {\n                return \"You failed to upload \" + fileName + \": \" + e.getMessage();\n            }\n        } else {\n            return \"Unable to upload. File is empty.\";\n        }\n    }\n    @RequestMapping(value=\"/multipleUpload\")\n    public String multiUpload(){\n    \treturn \"multipleUpload\";\n    }\n    @RequestMapping(value=\"/multipleSave\", method=RequestMethod.POST )\n    public @ResponseBody String multipleSave(@RequestParam(\"file\") MultipartFile[] files){\n    \tString fileName = null;\n    \tString msg = \"\";\n    \tif (files != null && files.length >0) {\n    \t\tfor(int i =0 ;i< files.length; i++){\n\t            try {\n\t                fileName = files[i].getOriginalFilename();\n\t                byte[] bytes = files[i].getBytes();\n\t                BufferedOutputStream buffStream =\n\t                        new BufferedOutputStream(new FileOutputStream(new File(\"F:/cp/\" + fileName)));\n\t                buffStream.write(bytes);\n\t                buffStream.close();\n\t                msg += \"You have successfully uploaded \" + fileName +\"<br/>\";\n\t            } catch (Exception e) {\n\t                return \"You failed to upload \" + fileName + \": \" + e.getMessage() +\"<br/>\";\n\t            }\n    \t\t}\n    \t\treturn msg;\n        } else {\n            return \"Unable to upload. File is empty.\";\n        }\n    }\n}\n```\n### 使用MultipartConfigElement上传配置类\n\n在配置代码里面,我们需要使用到MultipartConfigElement和UrlBasedViewResolver两个配置类。MultipartConfigElement支持文件上传，例如我们可以设置最大文件大小,最大请求大小等。MultipartConfigElement需要在WebApplicationInitializer中被配置到Dispatcher servlet中。UrlBasedViewResolver定义JSP位置和文件扩展名的输出模式\n\n**代码清单：AppConfig.java**\n```\npackage com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.context.embedded.MultipartConfigFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.view.JstlView;\nimport org.springframework.web.servlet.view.UrlBasedViewResolver;\n@Configuration\n@ComponentScan\n@EnableWebMvc\n@EnableAutoConfiguration\npublic class AppConfig {\n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        factory.setMaxFileSize(\"128KB\");\n        factory.setMaxRequestSize(\"128KB\");\n        return factory.createMultipartConfig();\n    }\n    @Bean  \n    public UrlBasedViewResolver setupViewResolver() {  \n        UrlBasedViewResolver resolver = new UrlBasedViewResolver();  \n        resolver.setPrefix(\"/views/\");  \n        resolver.setSuffix(\".jsp\");  \n        resolver.setViewClass(JstlView.class);\n        return resolver;  \n    }\n}\n```\n\n### WebApplicationInitializer初始化\n\nWebApplicationInitializer使我们的应用程序不再依赖web.xml文件，也一样可以支持所有应用功能。为了支持文件上传，我们的dispatcher必须注入多文件上传配置类\n\n**文件清单：WebAppInitializer.java**\n```\npackage com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport javax.servlet.ServletContext;  \nimport javax.servlet.ServletException;  \nimport javax.servlet.ServletRegistration.Dynamic;  \nimport org.springframework.web.WebApplicationInitializer;  \nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  \nimport org.springframework.web.servlet.DispatcherServlet;  \npublic class WebAppInitializer implements WebApplicationInitializer {\n\tpublic void onStartup(ServletContext servletContext) throws ServletException {  \n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();  \n        ctx.register(AppConfig.class);  \n        ctx.setServletContext(servletContext);\n        ctx.refresh();\n        Dynamic dynamic = servletContext.addServlet(\"dispatcher\", new DispatcherServlet(ctx));  \n        dynamic.addMapping(\"/\");  \n        dynamic.setLoadOnStartup(1);\n        dynamic.setMultipartConfig(ctx.getBean(MultipartConfigElement.class));\n   }  \n}  \n```\n\n### 视图页面配置\n\n使用jsp视图，为了支持文件上传,必须设置enctype为多部分表单数据,并添加一个file输入框。我们有两个JSP，找到单文件上传的JSP页面如下\n**文件清单：singleUpload.jsp**\n```\n<html>\n<body>\n<h1>Single File Upload</h1>\n\t<form method=\"post\" enctype=\"multipart/form-data\" action=\"singleSave\">\n\t\tUpload File: <input type=\"file\" name=\"file\">\n\t\t<br /><br />\n\t\tDescription: <input type=\"text\" name=\"desc\"/>\n\t\t<br/><br/><input type=\"submit\" value=\"Upload\">\n\t</form>\n</body>\n</html>\n```\n找到多文件上传JSP页面，我们需要注意每个file输入框name必须一致，这样可以在后台通过一个集合数组来访问\n**文件清单：multipleUpload.jsp**\n```\n<html>\n<body>\n    <h1> Multiple File Upload </h1>\n\t<form method=\"post\" enctype=\"multipart/form-data\" action=\"multipleSave\">\n\t\tUpload File 1: <input type=\"file\" name=\"file\"> <br/>\n\t\tUpload File 2: <input type=\"file\" name=\"file\"> <br/>\n\t\tUpload File 3: <input type=\"file\" name=\"file\"> <br/>\n\t\tUpload File 4: <input type=\"file\" name=\"file\"> <br/>\n\t\t<br /><br /><input type=\"submit\" value=\"Upload\">\n\t</form>\n</body>\n</html>\n```\n### 使用Gradle管理Spring Boot包依赖\n\n在gradle脚本添加JAR依赖项，构建项目创建WAR文件。此示例用到了Spring boot web和security依赖\n**文件清单：build.gradle**\n```\napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'war'\narchivesBaseName = 'CP'\nrepositories {\n    mavenCentral()\n}\ndependencies {\n   compile 'org.springframework.boot:spring-boot-starter-web:1.1.4.RELEASE'\n   compile 'org.springframework.boot:spring-boot-starter-security:1.1.4.RELEASE'\n   compile 'javax.servlet:jstl:1.2'\n   compile 'commons-fileupload:commons-fileupload:1.3.1'\n}  \n```\n### Tomcat7部署示例运行\n到项目build目录，在lib下会得到一个war文件， 将此war部署到tomcat运行测试\n\n**单个文件上传输出**\n\n访问URL[http://localhost:8080/CP/singleUpload](http://localhost:8080/CP/singleUpload)\n![单个文件上传](http://oaefo3hoy.bkt.clouddn.com/16-9-2/84536250.jpg)\n![单个文件上传]](http://oaefo3hoy.bkt.clouddn.com/16-9-2/16535556.jpg)\n\n**多文件上传输出**\n访问URL[http://localhost:8080/CP/multipleUpload](http://localhost:8080/CP/multipleUpload)\n![多文件上传](http://oaefo3hoy.bkt.clouddn.com/16-9-2/6931726.jpg)\n![多文件上传](http://oaefo3hoy.bkt.clouddn.com/16-9-2/8079858.jpg)\n\n### 源码下载\n\n[spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip](http://www.concretepage.com/spring-4/download/spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip)\n\n### 博主声明\n\n本文属于博主原创英文技术文章翻译，原文连接请点击[这里](http://www.concretepage.com/spring-4/spring-4-mvc-single-multiple-file-upload-example-with-tomcat),翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读\n\n由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！\n","source":"_posts/spring-4-mvc-single-multiple-file-upload-example-with-springboot.md","raw":"---\ntitle: Spring Boot+SpringMVC4实现单文件多文件上传\ndate: 2016-09-02 17:33:38\ncategories: SpringBoot\ntags: ['Spring Boot','java','文件上传','示例','原创翻译']\n---\n\n本文我们将学习如何在SpringMVC4中实现文件的上传，示例将提供单文件和多文件的上传的演示。使用更少的XML配置，我们将需要为文件上传配置一个MultipartConfigElement Bean对象，控制器中方法的参数应该使用MultipartFile类接受上传文件。同时在JSP页面表单，enctype属性要设置成多部分表单数据(multipart/form-data),现在来说下我们的示例代码\n<!--more-->\n\n### 开发工具\n\n  运行此示例我们需要准备好以下软件环境\n- JDK7\n- Eclipse\n- Tomcat7\n- Gradle 2.0 for Spring Boot\n\n### Eclipse示例项目结构\n\n为了更好的理解，我们先整体看下示例类文件和JSP页面的存放结构\n![ Eclipse示例项目结构](http://oaefo3hoy.bkt.clouddn.com/16-9-2/15447753.jpg)\n\n### 控制器：使用MultipartFile类\n\n本示例我们要演示单文件和多文件上传，所以我们创建了两个不同上传文件的方法。\n\n单文件上传方法里需要包含有如下的一个参数：\n\n```Java\n@RequestParam(\"file\") MultipartFile file\n```\n多文件上传方法中，方法参数如下：\n```java\n@RequestParam(\"file\") MultipartFile[]  file\n```\n从MultipartFile对象中获取上传文件的名称保存到你期望保存路径位置，整个上传文件代码逻辑如下：\n\n**文件清单：FileUploadController.java**\n```\npackage com.concretepage;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\n@Controller\npublic class FileUploadController {\n    @RequestMapping(value=\"/singleUpload\")\n    public String singleUpload(){\n    \treturn \"singleUpload\";\n    }\n    @RequestMapping(value=\"/singleSave\", method=RequestMethod.POST )\n    public @ResponseBody String singleSave(@RequestParam(\"file\") MultipartFile file, @RequestParam(\"desc\") String desc ){\n    \tSystem.out.println(\"File Description:\"+desc);\n    \tString fileName = null;\n    \tif (!file.isEmpty()) {\n            try {\n                fileName = file.getOriginalFilename();\n                byte[] bytes = file.getBytes();\n                BufferedOutputStream buffStream =\n                        new BufferedOutputStream(new FileOutputStream(new File(\"F:/cp/\" + fileName)));\n                buffStream.write(bytes);\n                buffStream.close();\n                return \"You have successfully uploaded \" + fileName;\n            } catch (Exception e) {\n                return \"You failed to upload \" + fileName + \": \" + e.getMessage();\n            }\n        } else {\n            return \"Unable to upload. File is empty.\";\n        }\n    }\n    @RequestMapping(value=\"/multipleUpload\")\n    public String multiUpload(){\n    \treturn \"multipleUpload\";\n    }\n    @RequestMapping(value=\"/multipleSave\", method=RequestMethod.POST )\n    public @ResponseBody String multipleSave(@RequestParam(\"file\") MultipartFile[] files){\n    \tString fileName = null;\n    \tString msg = \"\";\n    \tif (files != null && files.length >0) {\n    \t\tfor(int i =0 ;i< files.length; i++){\n\t            try {\n\t                fileName = files[i].getOriginalFilename();\n\t                byte[] bytes = files[i].getBytes();\n\t                BufferedOutputStream buffStream =\n\t                        new BufferedOutputStream(new FileOutputStream(new File(\"F:/cp/\" + fileName)));\n\t                buffStream.write(bytes);\n\t                buffStream.close();\n\t                msg += \"You have successfully uploaded \" + fileName +\"<br/>\";\n\t            } catch (Exception e) {\n\t                return \"You failed to upload \" + fileName + \": \" + e.getMessage() +\"<br/>\";\n\t            }\n    \t\t}\n    \t\treturn msg;\n        } else {\n            return \"Unable to upload. File is empty.\";\n        }\n    }\n}\n```\n### 使用MultipartConfigElement上传配置类\n\n在配置代码里面,我们需要使用到MultipartConfigElement和UrlBasedViewResolver两个配置类。MultipartConfigElement支持文件上传，例如我们可以设置最大文件大小,最大请求大小等。MultipartConfigElement需要在WebApplicationInitializer中被配置到Dispatcher servlet中。UrlBasedViewResolver定义JSP位置和文件扩展名的输出模式\n\n**代码清单：AppConfig.java**\n```\npackage com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.context.embedded.MultipartConfigFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.view.JstlView;\nimport org.springframework.web.servlet.view.UrlBasedViewResolver;\n@Configuration\n@ComponentScan\n@EnableWebMvc\n@EnableAutoConfiguration\npublic class AppConfig {\n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        factory.setMaxFileSize(\"128KB\");\n        factory.setMaxRequestSize(\"128KB\");\n        return factory.createMultipartConfig();\n    }\n    @Bean  \n    public UrlBasedViewResolver setupViewResolver() {  \n        UrlBasedViewResolver resolver = new UrlBasedViewResolver();  \n        resolver.setPrefix(\"/views/\");  \n        resolver.setSuffix(\".jsp\");  \n        resolver.setViewClass(JstlView.class);\n        return resolver;  \n    }\n}\n```\n\n### WebApplicationInitializer初始化\n\nWebApplicationInitializer使我们的应用程序不再依赖web.xml文件，也一样可以支持所有应用功能。为了支持文件上传，我们的dispatcher必须注入多文件上传配置类\n\n**文件清单：WebAppInitializer.java**\n```\npackage com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport javax.servlet.ServletContext;  \nimport javax.servlet.ServletException;  \nimport javax.servlet.ServletRegistration.Dynamic;  \nimport org.springframework.web.WebApplicationInitializer;  \nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  \nimport org.springframework.web.servlet.DispatcherServlet;  \npublic class WebAppInitializer implements WebApplicationInitializer {\n\tpublic void onStartup(ServletContext servletContext) throws ServletException {  \n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();  \n        ctx.register(AppConfig.class);  \n        ctx.setServletContext(servletContext);\n        ctx.refresh();\n        Dynamic dynamic = servletContext.addServlet(\"dispatcher\", new DispatcherServlet(ctx));  \n        dynamic.addMapping(\"/\");  \n        dynamic.setLoadOnStartup(1);\n        dynamic.setMultipartConfig(ctx.getBean(MultipartConfigElement.class));\n   }  \n}  \n```\n\n### 视图页面配置\n\n使用jsp视图，为了支持文件上传,必须设置enctype为多部分表单数据,并添加一个file输入框。我们有两个JSP，找到单文件上传的JSP页面如下\n**文件清单：singleUpload.jsp**\n```\n<html>\n<body>\n<h1>Single File Upload</h1>\n\t<form method=\"post\" enctype=\"multipart/form-data\" action=\"singleSave\">\n\t\tUpload File: <input type=\"file\" name=\"file\">\n\t\t<br /><br />\n\t\tDescription: <input type=\"text\" name=\"desc\"/>\n\t\t<br/><br/><input type=\"submit\" value=\"Upload\">\n\t</form>\n</body>\n</html>\n```\n找到多文件上传JSP页面，我们需要注意每个file输入框name必须一致，这样可以在后台通过一个集合数组来访问\n**文件清单：multipleUpload.jsp**\n```\n<html>\n<body>\n    <h1> Multiple File Upload </h1>\n\t<form method=\"post\" enctype=\"multipart/form-data\" action=\"multipleSave\">\n\t\tUpload File 1: <input type=\"file\" name=\"file\"> <br/>\n\t\tUpload File 2: <input type=\"file\" name=\"file\"> <br/>\n\t\tUpload File 3: <input type=\"file\" name=\"file\"> <br/>\n\t\tUpload File 4: <input type=\"file\" name=\"file\"> <br/>\n\t\t<br /><br /><input type=\"submit\" value=\"Upload\">\n\t</form>\n</body>\n</html>\n```\n### 使用Gradle管理Spring Boot包依赖\n\n在gradle脚本添加JAR依赖项，构建项目创建WAR文件。此示例用到了Spring boot web和security依赖\n**文件清单：build.gradle**\n```\napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'war'\narchivesBaseName = 'CP'\nrepositories {\n    mavenCentral()\n}\ndependencies {\n   compile 'org.springframework.boot:spring-boot-starter-web:1.1.4.RELEASE'\n   compile 'org.springframework.boot:spring-boot-starter-security:1.1.4.RELEASE'\n   compile 'javax.servlet:jstl:1.2'\n   compile 'commons-fileupload:commons-fileupload:1.3.1'\n}  \n```\n### Tomcat7部署示例运行\n到项目build目录，在lib下会得到一个war文件， 将此war部署到tomcat运行测试\n\n**单个文件上传输出**\n\n访问URL[http://localhost:8080/CP/singleUpload](http://localhost:8080/CP/singleUpload)\n![单个文件上传](http://oaefo3hoy.bkt.clouddn.com/16-9-2/84536250.jpg)\n![单个文件上传]](http://oaefo3hoy.bkt.clouddn.com/16-9-2/16535556.jpg)\n\n**多文件上传输出**\n访问URL[http://localhost:8080/CP/multipleUpload](http://localhost:8080/CP/multipleUpload)\n![多文件上传](http://oaefo3hoy.bkt.clouddn.com/16-9-2/6931726.jpg)\n![多文件上传](http://oaefo3hoy.bkt.clouddn.com/16-9-2/8079858.jpg)\n\n### 源码下载\n\n[spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip](http://www.concretepage.com/spring-4/download/spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip)\n\n### 博主声明\n\n本文属于博主原创英文技术文章翻译，原文连接请点击[这里](http://www.concretepage.com/spring-4/spring-4-mvc-single-multiple-file-upload-example-with-tomcat),翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读\n\n由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！\n","slug":"spring-4-mvc-single-multiple-file-upload-example-with-springboot","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obswc001tqk5c8grn0ik3","content":"<p>本文我们将学习如何在SpringMVC4中实现文件的上传，示例将提供单文件和多文件的上传的演示。使用更少的XML配置，我们将需要为文件上传配置一个MultipartConfigElement Bean对象，控制器中方法的参数应该使用MultipartFile类接受上传文件。同时在JSP页面表单，enctype属性要设置成多部分表单数据(multipart/form-data),现在来说下我们的示例代码<br><a id=\"more\"></a></p>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><p>  运行此示例我们需要准备好以下软件环境</p>\n<ul>\n<li>JDK7</li>\n<li>Eclipse</li>\n<li>Tomcat7</li>\n<li>Gradle 2.0 for Spring Boot</li>\n</ul>\n<h3 id=\"Eclipse示例项目结构\"><a href=\"#Eclipse示例项目结构\" class=\"headerlink\" title=\"Eclipse示例项目结构\"></a>Eclipse示例项目结构</h3><p>为了更好的理解，我们先整体看下示例类文件和JSP页面的存放结构<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/15447753.jpg\" alt=\" Eclipse示例项目结构\"></p>\n<h3 id=\"控制器：使用MultipartFile类\"><a href=\"#控制器：使用MultipartFile类\" class=\"headerlink\" title=\"控制器：使用MultipartFile类\"></a>控制器：使用MultipartFile类</h3><p>本示例我们要演示单文件和多文件上传，所以我们创建了两个不同上传文件的方法。</p>\n<p>单文件上传方法里需要包含有如下的一个参数：</p>\n<pre><code class=\"Java\">@RequestParam(&quot;file&quot;) MultipartFile file\n</code></pre>\n<p>多文件上传方法中，方法参数如下：</p>\n<pre><code class=\"java\">@RequestParam(&quot;file&quot;) MultipartFile[]  file\n</code></pre>\n<p>从MultipartFile对象中获取上传文件的名称保存到你期望保存路径位置，整个上传文件代码逻辑如下：</p>\n<p><strong>文件清单：FileUploadController.java</strong></p>\n<pre><code>package com.concretepage;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\n@Controller\npublic class FileUploadController {\n    @RequestMapping(value=&quot;/singleUpload&quot;)\n    public String singleUpload(){\n        return &quot;singleUpload&quot;;\n    }\n    @RequestMapping(value=&quot;/singleSave&quot;, method=RequestMethod.POST )\n    public @ResponseBody String singleSave(@RequestParam(&quot;file&quot;) MultipartFile file, @RequestParam(&quot;desc&quot;) String desc ){\n        System.out.println(&quot;File Description:&quot;+desc);\n        String fileName = null;\n        if (!file.isEmpty()) {\n            try {\n                fileName = file.getOriginalFilename();\n                byte[] bytes = file.getBytes();\n                BufferedOutputStream buffStream =\n                        new BufferedOutputStream(new FileOutputStream(new File(&quot;F:/cp/&quot; + fileName)));\n                buffStream.write(bytes);\n                buffStream.close();\n                return &quot;You have successfully uploaded &quot; + fileName;\n            } catch (Exception e) {\n                return &quot;You failed to upload &quot; + fileName + &quot;: &quot; + e.getMessage();\n            }\n        } else {\n            return &quot;Unable to upload. File is empty.&quot;;\n        }\n    }\n    @RequestMapping(value=&quot;/multipleUpload&quot;)\n    public String multiUpload(){\n        return &quot;multipleUpload&quot;;\n    }\n    @RequestMapping(value=&quot;/multipleSave&quot;, method=RequestMethod.POST )\n    public @ResponseBody String multipleSave(@RequestParam(&quot;file&quot;) MultipartFile[] files){\n        String fileName = null;\n        String msg = &quot;&quot;;\n        if (files != null &amp;&amp; files.length &gt;0) {\n            for(int i =0 ;i&lt; files.length; i++){\n                try {\n                    fileName = files[i].getOriginalFilename();\n                    byte[] bytes = files[i].getBytes();\n                    BufferedOutputStream buffStream =\n                            new BufferedOutputStream(new FileOutputStream(new File(&quot;F:/cp/&quot; + fileName)));\n                    buffStream.write(bytes);\n                    buffStream.close();\n                    msg += &quot;You have successfully uploaded &quot; + fileName +&quot;&lt;br/&gt;&quot;;\n                } catch (Exception e) {\n                    return &quot;You failed to upload &quot; + fileName + &quot;: &quot; + e.getMessage() +&quot;&lt;br/&gt;&quot;;\n                }\n            }\n            return msg;\n        } else {\n            return &quot;Unable to upload. File is empty.&quot;;\n        }\n    }\n}\n</code></pre><h3 id=\"使用MultipartConfigElement上传配置类\"><a href=\"#使用MultipartConfigElement上传配置类\" class=\"headerlink\" title=\"使用MultipartConfigElement上传配置类\"></a>使用MultipartConfigElement上传配置类</h3><p>在配置代码里面,我们需要使用到MultipartConfigElement和UrlBasedViewResolver两个配置类。MultipartConfigElement支持文件上传，例如我们可以设置最大文件大小,最大请求大小等。MultipartConfigElement需要在WebApplicationInitializer中被配置到Dispatcher servlet中。UrlBasedViewResolver定义JSP位置和文件扩展名的输出模式</p>\n<p><strong>代码清单：AppConfig.java</strong></p>\n<pre><code>package com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.context.embedded.MultipartConfigFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.view.JstlView;\nimport org.springframework.web.servlet.view.UrlBasedViewResolver;\n@Configuration\n@ComponentScan\n@EnableWebMvc\n@EnableAutoConfiguration\npublic class AppConfig {\n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        factory.setMaxFileSize(&quot;128KB&quot;);\n        factory.setMaxRequestSize(&quot;128KB&quot;);\n        return factory.createMultipartConfig();\n    }\n    @Bean  \n    public UrlBasedViewResolver setupViewResolver() {  \n        UrlBasedViewResolver resolver = new UrlBasedViewResolver();  \n        resolver.setPrefix(&quot;/views/&quot;);  \n        resolver.setSuffix(&quot;.jsp&quot;);  \n        resolver.setViewClass(JstlView.class);\n        return resolver;  \n    }\n}\n</code></pre><h3 id=\"WebApplicationInitializer初始化\"><a href=\"#WebApplicationInitializer初始化\" class=\"headerlink\" title=\"WebApplicationInitializer初始化\"></a>WebApplicationInitializer初始化</h3><p>WebApplicationInitializer使我们的应用程序不再依赖web.xml文件，也一样可以支持所有应用功能。为了支持文件上传，我们的dispatcher必须注入多文件上传配置类</p>\n<p><strong>文件清单：WebAppInitializer.java</strong></p>\n<pre><code>package com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport javax.servlet.ServletContext;  \nimport javax.servlet.ServletException;  \nimport javax.servlet.ServletRegistration.Dynamic;  \nimport org.springframework.web.WebApplicationInitializer;  \nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  \nimport org.springframework.web.servlet.DispatcherServlet;  \npublic class WebAppInitializer implements WebApplicationInitializer {\n    public void onStartup(ServletContext servletContext) throws ServletException {  \n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();  \n        ctx.register(AppConfig.class);  \n        ctx.setServletContext(servletContext);\n        ctx.refresh();\n        Dynamic dynamic = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(ctx));  \n        dynamic.addMapping(&quot;/&quot;);  \n        dynamic.setLoadOnStartup(1);\n        dynamic.setMultipartConfig(ctx.getBean(MultipartConfigElement.class));\n   }  \n}\n</code></pre><h3 id=\"视图页面配置\"><a href=\"#视图页面配置\" class=\"headerlink\" title=\"视图页面配置\"></a>视图页面配置</h3><p>使用jsp视图，为了支持文件上传,必须设置enctype为多部分表单数据,并添加一个file输入框。我们有两个JSP，找到单文件上传的JSP页面如下<br><strong>文件清单：singleUpload.jsp</strong></p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;Single File Upload&lt;/h1&gt;\n    &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;singleSave&quot;&gt;\n        Upload File: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;\n        &lt;br /&gt;&lt;br /&gt;\n        Description: &lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;\n        &lt;br/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>找到多文件上传JSP页面，我们需要注意每个file输入框name必须一致，这样可以在后台通过一个集合数组来访问<br><strong>文件清单：multipleUpload.jsp</strong></p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt; Multiple File Upload &lt;/h1&gt;\n    &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;multipleSave&quot;&gt;\n        Upload File 1: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        Upload File 2: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        Upload File 3: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        Upload File 4: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        &lt;br /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"使用Gradle管理Spring-Boot包依赖\"><a href=\"#使用Gradle管理Spring-Boot包依赖\" class=\"headerlink\" title=\"使用Gradle管理Spring Boot包依赖\"></a>使用Gradle管理Spring Boot包依赖</h3><p>在gradle脚本添加JAR依赖项，构建项目创建WAR文件。此示例用到了Spring boot web和security依赖<br><strong>文件清单：build.gradle</strong></p>\n<pre><code>apply plugin: &#39;java&#39;\napply plugin: &#39;eclipse&#39;\napply plugin: &#39;war&#39;\narchivesBaseName = &#39;CP&#39;\nrepositories {\n    mavenCentral()\n}\ndependencies {\n   compile &#39;org.springframework.boot:spring-boot-starter-web:1.1.4.RELEASE&#39;\n   compile &#39;org.springframework.boot:spring-boot-starter-security:1.1.4.RELEASE&#39;\n   compile &#39;javax.servlet:jstl:1.2&#39;\n   compile &#39;commons-fileupload:commons-fileupload:1.3.1&#39;\n}\n</code></pre><h3 id=\"Tomcat7部署示例运行\"><a href=\"#Tomcat7部署示例运行\" class=\"headerlink\" title=\"Tomcat7部署示例运行\"></a>Tomcat7部署示例运行</h3><p>到项目build目录，在lib下会得到一个war文件， 将此war部署到tomcat运行测试</p>\n<p><strong>单个文件上传输出</strong></p>\n<p>访问URL<a href=\"http://localhost:8080/CP/singleUpload\" target=\"_blank\" rel=\"external\">http://localhost:8080/CP/singleUpload</a><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/84536250.jpg\" alt=\"单个文件上传\"><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/16535556.jpg\" alt=\"单个文件上传]\"></p>\n<p><strong>多文件上传输出</strong><br>访问URL<a href=\"http://localhost:8080/CP/multipleUpload\" target=\"_blank\" rel=\"external\">http://localhost:8080/CP/multipleUpload</a><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/6931726.jpg\" alt=\"多文件上传\"><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/8079858.jpg\" alt=\"多文件上传\"></p>\n<h3 id=\"源码下载\"><a href=\"#源码下载\" class=\"headerlink\" title=\"源码下载\"></a>源码下载</h3><p><a href=\"http://www.concretepage.com/spring-4/download/spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip\" target=\"_blank\" rel=\"external\">spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip</a></p>\n<h3 id=\"博主声明\"><a href=\"#博主声明\" class=\"headerlink\" title=\"博主声明\"></a>博主声明</h3><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href=\"http://www.concretepage.com/spring-4/spring-4-mvc-single-multiple-file-upload-example-with-tomcat\" target=\"_blank\" rel=\"external\">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p>\n<p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>\n","excerpt":"<p>本文我们将学习如何在SpringMVC4中实现文件的上传，示例将提供单文件和多文件的上传的演示。使用更少的XML配置，我们将需要为文件上传配置一个MultipartConfigElement Bean对象，控制器中方法的参数应该使用MultipartFile类接受上传文件。同时在JSP页面表单，enctype属性要设置成多部分表单数据(multipart/form-data),现在来说下我们的示例代码<br>","more":"</p>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><p>  运行此示例我们需要准备好以下软件环境</p>\n<ul>\n<li>JDK7</li>\n<li>Eclipse</li>\n<li>Tomcat7</li>\n<li>Gradle 2.0 for Spring Boot</li>\n</ul>\n<h3 id=\"Eclipse示例项目结构\"><a href=\"#Eclipse示例项目结构\" class=\"headerlink\" title=\"Eclipse示例项目结构\"></a>Eclipse示例项目结构</h3><p>为了更好的理解，我们先整体看下示例类文件和JSP页面的存放结构<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/15447753.jpg\" alt=\" Eclipse示例项目结构\"></p>\n<h3 id=\"控制器：使用MultipartFile类\"><a href=\"#控制器：使用MultipartFile类\" class=\"headerlink\" title=\"控制器：使用MultipartFile类\"></a>控制器：使用MultipartFile类</h3><p>本示例我们要演示单文件和多文件上传，所以我们创建了两个不同上传文件的方法。</p>\n<p>单文件上传方法里需要包含有如下的一个参数：</p>\n<pre><code class=\"Java\">@RequestParam(&quot;file&quot;) MultipartFile file\n</code></pre>\n<p>多文件上传方法中，方法参数如下：</p>\n<pre><code class=\"java\">@RequestParam(&quot;file&quot;) MultipartFile[]  file\n</code></pre>\n<p>从MultipartFile对象中获取上传文件的名称保存到你期望保存路径位置，整个上传文件代码逻辑如下：</p>\n<p><strong>文件清单：FileUploadController.java</strong></p>\n<pre><code>package com.concretepage;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\n@Controller\npublic class FileUploadController {\n    @RequestMapping(value=&quot;/singleUpload&quot;)\n    public String singleUpload(){\n        return &quot;singleUpload&quot;;\n    }\n    @RequestMapping(value=&quot;/singleSave&quot;, method=RequestMethod.POST )\n    public @ResponseBody String singleSave(@RequestParam(&quot;file&quot;) MultipartFile file, @RequestParam(&quot;desc&quot;) String desc ){\n        System.out.println(&quot;File Description:&quot;+desc);\n        String fileName = null;\n        if (!file.isEmpty()) {\n            try {\n                fileName = file.getOriginalFilename();\n                byte[] bytes = file.getBytes();\n                BufferedOutputStream buffStream =\n                        new BufferedOutputStream(new FileOutputStream(new File(&quot;F:/cp/&quot; + fileName)));\n                buffStream.write(bytes);\n                buffStream.close();\n                return &quot;You have successfully uploaded &quot; + fileName;\n            } catch (Exception e) {\n                return &quot;You failed to upload &quot; + fileName + &quot;: &quot; + e.getMessage();\n            }\n        } else {\n            return &quot;Unable to upload. File is empty.&quot;;\n        }\n    }\n    @RequestMapping(value=&quot;/multipleUpload&quot;)\n    public String multiUpload(){\n        return &quot;multipleUpload&quot;;\n    }\n    @RequestMapping(value=&quot;/multipleSave&quot;, method=RequestMethod.POST )\n    public @ResponseBody String multipleSave(@RequestParam(&quot;file&quot;) MultipartFile[] files){\n        String fileName = null;\n        String msg = &quot;&quot;;\n        if (files != null &amp;&amp; files.length &gt;0) {\n            for(int i =0 ;i&lt; files.length; i++){\n                try {\n                    fileName = files[i].getOriginalFilename();\n                    byte[] bytes = files[i].getBytes();\n                    BufferedOutputStream buffStream =\n                            new BufferedOutputStream(new FileOutputStream(new File(&quot;F:/cp/&quot; + fileName)));\n                    buffStream.write(bytes);\n                    buffStream.close();\n                    msg += &quot;You have successfully uploaded &quot; + fileName +&quot;&lt;br/&gt;&quot;;\n                } catch (Exception e) {\n                    return &quot;You failed to upload &quot; + fileName + &quot;: &quot; + e.getMessage() +&quot;&lt;br/&gt;&quot;;\n                }\n            }\n            return msg;\n        } else {\n            return &quot;Unable to upload. File is empty.&quot;;\n        }\n    }\n}\n</code></pre><h3 id=\"使用MultipartConfigElement上传配置类\"><a href=\"#使用MultipartConfigElement上传配置类\" class=\"headerlink\" title=\"使用MultipartConfigElement上传配置类\"></a>使用MultipartConfigElement上传配置类</h3><p>在配置代码里面,我们需要使用到MultipartConfigElement和UrlBasedViewResolver两个配置类。MultipartConfigElement支持文件上传，例如我们可以设置最大文件大小,最大请求大小等。MultipartConfigElement需要在WebApplicationInitializer中被配置到Dispatcher servlet中。UrlBasedViewResolver定义JSP位置和文件扩展名的输出模式</p>\n<p><strong>代码清单：AppConfig.java</strong></p>\n<pre><code>package com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.context.embedded.MultipartConfigFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.view.JstlView;\nimport org.springframework.web.servlet.view.UrlBasedViewResolver;\n@Configuration\n@ComponentScan\n@EnableWebMvc\n@EnableAutoConfiguration\npublic class AppConfig {\n    @Bean\n    public MultipartConfigElement multipartConfigElement() {\n        MultipartConfigFactory factory = new MultipartConfigFactory();\n        factory.setMaxFileSize(&quot;128KB&quot;);\n        factory.setMaxRequestSize(&quot;128KB&quot;);\n        return factory.createMultipartConfig();\n    }\n    @Bean  \n    public UrlBasedViewResolver setupViewResolver() {  \n        UrlBasedViewResolver resolver = new UrlBasedViewResolver();  \n        resolver.setPrefix(&quot;/views/&quot;);  \n        resolver.setSuffix(&quot;.jsp&quot;);  \n        resolver.setViewClass(JstlView.class);\n        return resolver;  \n    }\n}\n</code></pre><h3 id=\"WebApplicationInitializer初始化\"><a href=\"#WebApplicationInitializer初始化\" class=\"headerlink\" title=\"WebApplicationInitializer初始化\"></a>WebApplicationInitializer初始化</h3><p>WebApplicationInitializer使我们的应用程序不再依赖web.xml文件，也一样可以支持所有应用功能。为了支持文件上传，我们的dispatcher必须注入多文件上传配置类</p>\n<p><strong>文件清单：WebAppInitializer.java</strong></p>\n<pre><code>package com.concretepage;\nimport javax.servlet.MultipartConfigElement;\nimport javax.servlet.ServletContext;  \nimport javax.servlet.ServletException;  \nimport javax.servlet.ServletRegistration.Dynamic;  \nimport org.springframework.web.WebApplicationInitializer;  \nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  \nimport org.springframework.web.servlet.DispatcherServlet;  \npublic class WebAppInitializer implements WebApplicationInitializer {\n    public void onStartup(ServletContext servletContext) throws ServletException {  \n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();  \n        ctx.register(AppConfig.class);  \n        ctx.setServletContext(servletContext);\n        ctx.refresh();\n        Dynamic dynamic = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(ctx));  \n        dynamic.addMapping(&quot;/&quot;);  \n        dynamic.setLoadOnStartup(1);\n        dynamic.setMultipartConfig(ctx.getBean(MultipartConfigElement.class));\n   }  \n}\n</code></pre><h3 id=\"视图页面配置\"><a href=\"#视图页面配置\" class=\"headerlink\" title=\"视图页面配置\"></a>视图页面配置</h3><p>使用jsp视图，为了支持文件上传,必须设置enctype为多部分表单数据,并添加一个file输入框。我们有两个JSP，找到单文件上传的JSP页面如下<br><strong>文件清单：singleUpload.jsp</strong></p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;Single File Upload&lt;/h1&gt;\n    &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;singleSave&quot;&gt;\n        Upload File: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;\n        &lt;br /&gt;&lt;br /&gt;\n        Description: &lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;\n        &lt;br/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>找到多文件上传JSP页面，我们需要注意每个file输入框name必须一致，这样可以在后台通过一个集合数组来访问<br><strong>文件清单：multipleUpload.jsp</strong></p>\n<pre><code>&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt; Multiple File Upload &lt;/h1&gt;\n    &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;multipleSave&quot;&gt;\n        Upload File 1: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        Upload File 2: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        Upload File 3: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        Upload File 4: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;\n        &lt;br /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"使用Gradle管理Spring-Boot包依赖\"><a href=\"#使用Gradle管理Spring-Boot包依赖\" class=\"headerlink\" title=\"使用Gradle管理Spring Boot包依赖\"></a>使用Gradle管理Spring Boot包依赖</h3><p>在gradle脚本添加JAR依赖项，构建项目创建WAR文件。此示例用到了Spring boot web和security依赖<br><strong>文件清单：build.gradle</strong></p>\n<pre><code>apply plugin: &#39;java&#39;\napply plugin: &#39;eclipse&#39;\napply plugin: &#39;war&#39;\narchivesBaseName = &#39;CP&#39;\nrepositories {\n    mavenCentral()\n}\ndependencies {\n   compile &#39;org.springframework.boot:spring-boot-starter-web:1.1.4.RELEASE&#39;\n   compile &#39;org.springframework.boot:spring-boot-starter-security:1.1.4.RELEASE&#39;\n   compile &#39;javax.servlet:jstl:1.2&#39;\n   compile &#39;commons-fileupload:commons-fileupload:1.3.1&#39;\n}\n</code></pre><h3 id=\"Tomcat7部署示例运行\"><a href=\"#Tomcat7部署示例运行\" class=\"headerlink\" title=\"Tomcat7部署示例运行\"></a>Tomcat7部署示例运行</h3><p>到项目build目录，在lib下会得到一个war文件， 将此war部署到tomcat运行测试</p>\n<p><strong>单个文件上传输出</strong></p>\n<p>访问URL<a href=\"http://localhost:8080/CP/singleUpload\">http://localhost:8080/CP/singleUpload</a><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/84536250.jpg\" alt=\"单个文件上传\"><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/16535556.jpg\" alt=\"单个文件上传]\"></p>\n<p><strong>多文件上传输出</strong><br>访问URL<a href=\"http://localhost:8080/CP/multipleUpload\">http://localhost:8080/CP/multipleUpload</a><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/6931726.jpg\" alt=\"多文件上传\"><br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-9-2/8079858.jpg\" alt=\"多文件上传\"></p>\n<h3 id=\"源码下载\"><a href=\"#源码下载\" class=\"headerlink\" title=\"源码下载\"></a>源码下载</h3><p><a href=\"http://www.concretepage.com/spring-4/download/spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip\">spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip</a></p>\n<h3 id=\"博主声明\"><a href=\"#博主声明\" class=\"headerlink\" title=\"博主声明\"></a>博主声明</h3><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href=\"http://www.concretepage.com/spring-4/spring-4-mvc-single-multiple-file-upload-example-with-tomcat\">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p>\n<p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>"},{"title":"基于Spring Boot运行Spring MVC 应用程序","date":"2016-08-20T03:52:31.000Z","_content":"### 前言\n\n本教程适合对于有兴趣学习Spring Boot如何结合Spring MVC一起开发的初学者。通过本教程,您可以使用Spring Boot运行一个简单的Spring MVC应用程序\n<!--more-->\n>SpringBoot是一个Spring IO中的一个项目，它旨在减少Spring应用程序启动配置和连接。开发人员只专注于编写应用程序，SpringBoot将简化打包和部署的流程，而且不需要任何显示的声明配置。它就是如此在容器之外工作的! 在这里,我将解释如何使用Spring Boot运行一个简单且带有执行CRUD操作的Spring MVC应用程序。开始这个例子之前,请[在eclipse中创建web项目](http://www.javabeat.net/maven-eclipse/)。\n\n- 扩展阅读:[http://www.javabeat.net/spring-boot/](http://www.javabeat.net/spring-boot/)\n\n### 开始\n\n我已经实现了一个例子，例子做了如下的工作\n1. 创建一个Web 页面\n2. 用户可以想数据库中添加员工\n3. 用户可以在浏览器页面查看已添加到数据中的员工列表(JSON形式的结果)\n\n上面展现的工作使用到了Spring MVC, Hibernate and Spring Boot这些技术\n\n### 创建领域对象\n\n第一步，创建一个用来存储员工详细信息的Employee类，它是一个简单的POJO对象\n\n```java\n@Entity\npublic class Employee {\n\n    @Id\n    @NotNull\n    @Size(max = 64)\n    @Column(name = \"id\", nullable = false, updatable = false)\n    private String id;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = \"city\", nullable = false)\n    private String city;\n\n    Employee() {\n    }\n\n    public Employee(final String id, final String name,final String city) {\n        this.id = id;\n        this.name = name;\n        this.city = city;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    @Override\n    public String toString() {\n        return Objects.toStringHelper(this)\n                .add(\"id\", id)\n                .add(\"name\", name)\n                .add(city, city)\n                .toString();\n    }\n}\n```\n\n### 创建Spring Data JPA仓库\n\nSpring Data JPA是一个非常简单的方法保存数据到后端，如果你看了下面的代码，这就是你要持久化员工类将要写的代码，Spring Data在内部为你实现了必要的类和CRUD的操作，你只需要像下面一样提供一个接口即可，如果你对于Spring Data有兴趣，请阅读我们的[Spring Data JPA教程](http://www.javabeat.net/spring-data-jpa-tutorial/)\n\n```\npublic interface EmployeeRepository extends JpaRepository<Employee, String> {\n}\n```\n\n### 创建服务的实现类\n\n```java\n@Service\n@Validated\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(EmployeeServiceImpl.class);\n    private final EmployeeRepository repository;\n\n    @Inject\n    public EmployeeServiceImpl(final EmployeeRepository repository) {\n        this.repository = repository;\n    }\n\n    @Transactional\n    public Employee save(@NotNull @Valid final Employee employee) {\n        LOGGER.debug(\"Creating {}\", employee);\n        return repository.save(employee);\n    }\n\n    @Transactional(readOnly = true)\n    public List<Employee> getList() {\n        LOGGER.debug(\"Retrieving the list of all users\");\n        return repository.findAll();\n    }\n}\n```\n### 创建SpringMVC控制器\n\n这里对于Spring的开发者来说没有任何新的特性，我们只是创建一个简单实现了对员工的详细信息的添加和列表浏览\n\n```\n@RestController\npublic class EmployeeController {\n    private final EmployeeService employeeService;\n\n    @Inject\n    public EmployeeController(final EmployeeService employeeService) {\n        this.employeeService = employeeService;\n    }\n\n    @RequestMapping(value = \"/employee\", method = RequestMethod.GET)\n    public List<Employee> listEmployees() {\n        List<Employee> employees = employeeService.getList();\n        return employees;\n    }\n    @RequestMapping(value=\"/add\",method = RequestMethod.GET)\n    public void addEmployee(@RequestParam(value = \"employeeName\", required = false) String employeeName,\n    \t\t@RequestParam(value = \"employeeId\", required = false) String employeeId,\n    \t\t@RequestParam(value = \"employeeCity\", required = false) String employeeCity){\n    \tEmployee employee = new Employee(employeeId,employeeName,employeeCity);\n    \temployeeService.save(employee);\n    }\n}\n```\n\n### 创建JSP页面\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello WebSocket</title>\n</head>\n<body>\n<form action=\"/add\">\n\t<input type=\"input\" name=\"employeeName\">\n\t<input type=\"input\" name=\"employeeId\">\n\t<input type=\"input\" name=\"employeeCity\">\n\t<input type=\"submit\">\n</form>\n</body>\n</html>\n```\n\n### Spring Boot 应用程序\n\n最后，我们需要写一个Spring Boot application来运行我们的示例，这是一个主应用程序，当你试图执行应用程序时，它将会被SpringBoot调用\n\n- 扩展阅读:[REStful API using Spring Boot](http://www.javabeat.net/restful-springboot-mongodb/)\n\n```\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application extends SpringBootServletInitializer {\n\n    public static void main(final String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    protected final SpringApplicationBuilder configure(final SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n}\n```\n\n**@EnableAutoConfiguration**\n\n这个注解会试图在类路径下去查找启动应用程序所必需的beans，例如，如果你在类路径下有一个tomcat-embedded.jar，你可能会需要一个TomcatEmbeddedServletContainerFactory，这个包下的这个类被@EnableAutoConfiguration注解就有特殊的意义，通常会被作为默认的使用。再比如，当扫描带有@Entity注解的类它将被用到。通常推荐的做法，你可以在一个包的根下使用@EnableAutoConfiguration注解，这样所有子包和类都会被搜索\n\n**SpringApplication.run()**\n\nSpringApplication类是用于引导和启动Spring应用程序的。引导一个Spring应用程序创建适当的应用程序上下文，加载beans，触发任何命令式的bean对象等\n\n**SpringBootServletInitializer**\n\n这个是运行web应用所必须的，它将打开一个 servlet 容器，并将你的应用绑定到此容器内。\n\n\n### MAVEN配置\n\n这个运行SpringBoot应用非常重要的环节。SpringBoot需要通过在构建脚本文件中确定运行应用程序的包依赖，它能支持各种各样的构建工具，但SpringBoot官方文档中重点强调使用Maven和Gradle配置，因此，明智的做法是选择其中任何一个去简单的实现\n\n这里是使用maven配置如下：\n```xml\n<dependencies>\n       <!-- Spring Boot -->\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter</artifactId>\n       </dependency>\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-test</artifactId>\n           <scope>test</scope>\n       </dependency>\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-web</artifactId>\n       </dependency>\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-data-jpa</artifactId>\n       </dependency>\n       <!-- Hibernate validator -->\n       <dependency>\n           <groupId>org.hibernate</groupId>\n           <artifactId>hibernate-validator</artifactId>\n       </dependency>\n       <!-- HSQLDB -->\n       <dependency>\n           <groupId>org.hsqldb</groupId>\n           <artifactId>hsqldb</artifactId>\n           <scope>runtime</scope>\n       </dependency>\n       <!-- Guava -->\n       <dependency>\n           <groupId>com.google.guava</groupId>\n           <artifactId>guava</artifactId>\n           <version>${guava.version}</version>\n       </dependency>\n       <!-- Java EE -->\n       <dependency>\n           <groupId>javax.inject</groupId>\n           <artifactId>javax.inject</artifactId>\n           <version>1</version>\n       </dependency>\n   </dependencies>\n   <build>\n       <plugins>\n           <!-- Spring Boot Maven -->\n           <plugin>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-maven-plugin</artifactId>\n           </plugin>\n       </plugins>\n   </build>\n```\n\n**spring-boot-starter-\\***\n\nStarter POM是预定义的作为内置可用的POM集合描述，你不需要去搜索和配置那些依赖。比如，如果你正在为数据访问寻找Spring和JPA依赖，你只需把spring-boot-starter-data-jpa包含到你的POM文件中即可\n\n**spring-boot-maven-plugin**\n\n这个插件允许你将应用程序打包成一个可执行的JAR或WAR文件，它支持Maven 3.2以上版本。在我们的示例，当你使用“mvn install”命令运行项目，maven将构建此项目并且会在target目录创建一个可执行的JAR文件。\n\n**spring-boot-starter-parent**\n\n如果你想从spring-boot-starter-parent继承属性,然后简单地设置此父项目。如果你使用此父项目,版本号可以省略其他starters POM也如此。如果你有你自己的项目为你的项目,那么你可以使用它们代替由SpringBoot默认提供的父项目。配置如下：\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.0.1.RELEASE</version>\n</parent>\n```\n\n### 最终项目结构\n\n下面图是最终项目的包结构，这里我已经在一个包下面创建了一个Application.java。但好的实践是把这个文件直接放到包的根目录下\n![最终项目的包结构](http://oaefo3hoy.bkt.clouddn.com/16-8-20/18274027.jpg)\n\n### 运行SpringBoot可执行Jar包\n\n一旦你创建好了应用程序，运行这个命令来执行应用程序\n```\njava -jar target/mymodule-0.0.1-SNAPSHOT.jar\n```\n在你命令行程序运行上面的命令后，SpringBoot应用会在[http://localhost:8080/](http://localhost:8080/)运行此程序。你可以通过[http://localhost:8080/index.jsp](http://localhost:8080/index.jsp)访问应用的首页\n![访问应用的首页](http://oaefo3hoy.bkt.clouddn.com/16-8-20/78731535.jpg)\n\n你可以添加很多行员工数据，当你访问[http://localhost:8080/employee](http://localhost:8080/employee),你会在浏览器窗口看到类似下面的输出\n```\n[{\"id\":\"Krishna\",\"name\":\"001\",\"city\":\"Bangalore\"},{\"id\":\"Manisha Patil\",\"name\":\"005\",\"city\":\"Pune\"},{\"id\":\"Sanulla\",\"name\":\"001\",\"city\":\"Bangalore\"},{\"id\":\"Shunmuga Raja\",\"name\":\"001\",\"city\":\"Bangalore\"}]\n```\n\n### 源码下载\n\n[Spring Boot Spring MVC](http://javabeat.net/download/spring-boot-spring-mvc/?wpdmdl=22124)\n\n### 总结\n\n在本文中,我们已经讨论了如何创建一个maven项目和创建员工所需的不同组件管理Spring MVC应用程序。后来我们已经探讨了SpringBoot配置细节和SpringBoot应用所需的Maven POM文件内容。最后我们已经讨论了运行一个通过Maven打包生成可执行JAR文件。在本教程中,您将能够了解关于SpringBoot和Spring MVC是怎样一起工作\n\n### 博主声明\n\n本文属于博主原创英文技术文章翻译，原文连接请点击[这里](http://javabeat.net/spring-boot-spring-mvc/),翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读\n\n由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！\n","source":"_posts/spring-boot-spring-mvc.md","raw":"---\ntitle: 基于Spring Boot运行Spring MVC 应用程序\ndate: 2016-08-20 11:52:31\ncategories: SpringBoot\ntags: [\"SpringBoot\",\"Java\",\"原创翻译\"]\n---\n### 前言\n\n本教程适合对于有兴趣学习Spring Boot如何结合Spring MVC一起开发的初学者。通过本教程,您可以使用Spring Boot运行一个简单的Spring MVC应用程序\n<!--more-->\n>SpringBoot是一个Spring IO中的一个项目，它旨在减少Spring应用程序启动配置和连接。开发人员只专注于编写应用程序，SpringBoot将简化打包和部署的流程，而且不需要任何显示的声明配置。它就是如此在容器之外工作的! 在这里,我将解释如何使用Spring Boot运行一个简单且带有执行CRUD操作的Spring MVC应用程序。开始这个例子之前,请[在eclipse中创建web项目](http://www.javabeat.net/maven-eclipse/)。\n\n- 扩展阅读:[http://www.javabeat.net/spring-boot/](http://www.javabeat.net/spring-boot/)\n\n### 开始\n\n我已经实现了一个例子，例子做了如下的工作\n1. 创建一个Web 页面\n2. 用户可以想数据库中添加员工\n3. 用户可以在浏览器页面查看已添加到数据中的员工列表(JSON形式的结果)\n\n上面展现的工作使用到了Spring MVC, Hibernate and Spring Boot这些技术\n\n### 创建领域对象\n\n第一步，创建一个用来存储员工详细信息的Employee类，它是一个简单的POJO对象\n\n```java\n@Entity\npublic class Employee {\n\n    @Id\n    @NotNull\n    @Size(max = 64)\n    @Column(name = \"id\", nullable = false, updatable = false)\n    private String id;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = \"city\", nullable = false)\n    private String city;\n\n    Employee() {\n    }\n\n    public Employee(final String id, final String name,final String city) {\n        this.id = id;\n        this.name = name;\n        this.city = city;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    @Override\n    public String toString() {\n        return Objects.toStringHelper(this)\n                .add(\"id\", id)\n                .add(\"name\", name)\n                .add(city, city)\n                .toString();\n    }\n}\n```\n\n### 创建Spring Data JPA仓库\n\nSpring Data JPA是一个非常简单的方法保存数据到后端，如果你看了下面的代码，这就是你要持久化员工类将要写的代码，Spring Data在内部为你实现了必要的类和CRUD的操作，你只需要像下面一样提供一个接口即可，如果你对于Spring Data有兴趣，请阅读我们的[Spring Data JPA教程](http://www.javabeat.net/spring-data-jpa-tutorial/)\n\n```\npublic interface EmployeeRepository extends JpaRepository<Employee, String> {\n}\n```\n\n### 创建服务的实现类\n\n```java\n@Service\n@Validated\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(EmployeeServiceImpl.class);\n    private final EmployeeRepository repository;\n\n    @Inject\n    public EmployeeServiceImpl(final EmployeeRepository repository) {\n        this.repository = repository;\n    }\n\n    @Transactional\n    public Employee save(@NotNull @Valid final Employee employee) {\n        LOGGER.debug(\"Creating {}\", employee);\n        return repository.save(employee);\n    }\n\n    @Transactional(readOnly = true)\n    public List<Employee> getList() {\n        LOGGER.debug(\"Retrieving the list of all users\");\n        return repository.findAll();\n    }\n}\n```\n### 创建SpringMVC控制器\n\n这里对于Spring的开发者来说没有任何新的特性，我们只是创建一个简单实现了对员工的详细信息的添加和列表浏览\n\n```\n@RestController\npublic class EmployeeController {\n    private final EmployeeService employeeService;\n\n    @Inject\n    public EmployeeController(final EmployeeService employeeService) {\n        this.employeeService = employeeService;\n    }\n\n    @RequestMapping(value = \"/employee\", method = RequestMethod.GET)\n    public List<Employee> listEmployees() {\n        List<Employee> employees = employeeService.getList();\n        return employees;\n    }\n    @RequestMapping(value=\"/add\",method = RequestMethod.GET)\n    public void addEmployee(@RequestParam(value = \"employeeName\", required = false) String employeeName,\n    \t\t@RequestParam(value = \"employeeId\", required = false) String employeeId,\n    \t\t@RequestParam(value = \"employeeCity\", required = false) String employeeCity){\n    \tEmployee employee = new Employee(employeeId,employeeName,employeeCity);\n    \temployeeService.save(employee);\n    }\n}\n```\n\n### 创建JSP页面\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello WebSocket</title>\n</head>\n<body>\n<form action=\"/add\">\n\t<input type=\"input\" name=\"employeeName\">\n\t<input type=\"input\" name=\"employeeId\">\n\t<input type=\"input\" name=\"employeeCity\">\n\t<input type=\"submit\">\n</form>\n</body>\n</html>\n```\n\n### Spring Boot 应用程序\n\n最后，我们需要写一个Spring Boot application来运行我们的示例，这是一个主应用程序，当你试图执行应用程序时，它将会被SpringBoot调用\n\n- 扩展阅读:[REStful API using Spring Boot](http://www.javabeat.net/restful-springboot-mongodb/)\n\n```\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application extends SpringBootServletInitializer {\n\n    public static void main(final String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    protected final SpringApplicationBuilder configure(final SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n}\n```\n\n**@EnableAutoConfiguration**\n\n这个注解会试图在类路径下去查找启动应用程序所必需的beans，例如，如果你在类路径下有一个tomcat-embedded.jar，你可能会需要一个TomcatEmbeddedServletContainerFactory，这个包下的这个类被@EnableAutoConfiguration注解就有特殊的意义，通常会被作为默认的使用。再比如，当扫描带有@Entity注解的类它将被用到。通常推荐的做法，你可以在一个包的根下使用@EnableAutoConfiguration注解，这样所有子包和类都会被搜索\n\n**SpringApplication.run()**\n\nSpringApplication类是用于引导和启动Spring应用程序的。引导一个Spring应用程序创建适当的应用程序上下文，加载beans，触发任何命令式的bean对象等\n\n**SpringBootServletInitializer**\n\n这个是运行web应用所必须的，它将打开一个 servlet 容器，并将你的应用绑定到此容器内。\n\n\n### MAVEN配置\n\n这个运行SpringBoot应用非常重要的环节。SpringBoot需要通过在构建脚本文件中确定运行应用程序的包依赖，它能支持各种各样的构建工具，但SpringBoot官方文档中重点强调使用Maven和Gradle配置，因此，明智的做法是选择其中任何一个去简单的实现\n\n这里是使用maven配置如下：\n```xml\n<dependencies>\n       <!-- Spring Boot -->\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter</artifactId>\n       </dependency>\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-test</artifactId>\n           <scope>test</scope>\n       </dependency>\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-web</artifactId>\n       </dependency>\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-data-jpa</artifactId>\n       </dependency>\n       <!-- Hibernate validator -->\n       <dependency>\n           <groupId>org.hibernate</groupId>\n           <artifactId>hibernate-validator</artifactId>\n       </dependency>\n       <!-- HSQLDB -->\n       <dependency>\n           <groupId>org.hsqldb</groupId>\n           <artifactId>hsqldb</artifactId>\n           <scope>runtime</scope>\n       </dependency>\n       <!-- Guava -->\n       <dependency>\n           <groupId>com.google.guava</groupId>\n           <artifactId>guava</artifactId>\n           <version>${guava.version}</version>\n       </dependency>\n       <!-- Java EE -->\n       <dependency>\n           <groupId>javax.inject</groupId>\n           <artifactId>javax.inject</artifactId>\n           <version>1</version>\n       </dependency>\n   </dependencies>\n   <build>\n       <plugins>\n           <!-- Spring Boot Maven -->\n           <plugin>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-maven-plugin</artifactId>\n           </plugin>\n       </plugins>\n   </build>\n```\n\n**spring-boot-starter-\\***\n\nStarter POM是预定义的作为内置可用的POM集合描述，你不需要去搜索和配置那些依赖。比如，如果你正在为数据访问寻找Spring和JPA依赖，你只需把spring-boot-starter-data-jpa包含到你的POM文件中即可\n\n**spring-boot-maven-plugin**\n\n这个插件允许你将应用程序打包成一个可执行的JAR或WAR文件，它支持Maven 3.2以上版本。在我们的示例，当你使用“mvn install”命令运行项目，maven将构建此项目并且会在target目录创建一个可执行的JAR文件。\n\n**spring-boot-starter-parent**\n\n如果你想从spring-boot-starter-parent继承属性,然后简单地设置此父项目。如果你使用此父项目,版本号可以省略其他starters POM也如此。如果你有你自己的项目为你的项目,那么你可以使用它们代替由SpringBoot默认提供的父项目。配置如下：\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.0.1.RELEASE</version>\n</parent>\n```\n\n### 最终项目结构\n\n下面图是最终项目的包结构，这里我已经在一个包下面创建了一个Application.java。但好的实践是把这个文件直接放到包的根目录下\n![最终项目的包结构](http://oaefo3hoy.bkt.clouddn.com/16-8-20/18274027.jpg)\n\n### 运行SpringBoot可执行Jar包\n\n一旦你创建好了应用程序，运行这个命令来执行应用程序\n```\njava -jar target/mymodule-0.0.1-SNAPSHOT.jar\n```\n在你命令行程序运行上面的命令后，SpringBoot应用会在[http://localhost:8080/](http://localhost:8080/)运行此程序。你可以通过[http://localhost:8080/index.jsp](http://localhost:8080/index.jsp)访问应用的首页\n![访问应用的首页](http://oaefo3hoy.bkt.clouddn.com/16-8-20/78731535.jpg)\n\n你可以添加很多行员工数据，当你访问[http://localhost:8080/employee](http://localhost:8080/employee),你会在浏览器窗口看到类似下面的输出\n```\n[{\"id\":\"Krishna\",\"name\":\"001\",\"city\":\"Bangalore\"},{\"id\":\"Manisha Patil\",\"name\":\"005\",\"city\":\"Pune\"},{\"id\":\"Sanulla\",\"name\":\"001\",\"city\":\"Bangalore\"},{\"id\":\"Shunmuga Raja\",\"name\":\"001\",\"city\":\"Bangalore\"}]\n```\n\n### 源码下载\n\n[Spring Boot Spring MVC](http://javabeat.net/download/spring-boot-spring-mvc/?wpdmdl=22124)\n\n### 总结\n\n在本文中,我们已经讨论了如何创建一个maven项目和创建员工所需的不同组件管理Spring MVC应用程序。后来我们已经探讨了SpringBoot配置细节和SpringBoot应用所需的Maven POM文件内容。最后我们已经讨论了运行一个通过Maven打包生成可执行JAR文件。在本教程中,您将能够了解关于SpringBoot和Spring MVC是怎样一起工作\n\n### 博主声明\n\n本文属于博主原创英文技术文章翻译，原文连接请点击[这里](http://javabeat.net/spring-boot-spring-mvc/),翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读\n\n由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！\n","slug":"spring-boot-spring-mvc","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obswd001uqk5cg7ylkho4","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本教程适合对于有兴趣学习Spring Boot如何结合Spring MVC一起开发的初学者。通过本教程,您可以使用Spring Boot运行一个简单的Spring MVC应用程序<br><a id=\"more\"></a></p>\n<blockquote>\n<p>SpringBoot是一个Spring IO中的一个项目，它旨在减少Spring应用程序启动配置和连接。开发人员只专注于编写应用程序，SpringBoot将简化打包和部署的流程，而且不需要任何显示的声明配置。它就是如此在容器之外工作的! 在这里,我将解释如何使用Spring Boot运行一个简单且带有执行CRUD操作的Spring MVC应用程序。开始这个例子之前,请<a href=\"http://www.javabeat.net/maven-eclipse/\" target=\"_blank\" rel=\"external\">在eclipse中创建web项目</a>。</p>\n</blockquote>\n<ul>\n<li>扩展阅读:<a href=\"http://www.javabeat.net/spring-boot/\" target=\"_blank\" rel=\"external\">http://www.javabeat.net/spring-boot/</a></li>\n</ul>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>我已经实现了一个例子，例子做了如下的工作</p>\n<ol>\n<li>创建一个Web 页面</li>\n<li>用户可以想数据库中添加员工</li>\n<li>用户可以在浏览器页面查看已添加到数据中的员工列表(JSON形式的结果)</li>\n</ol>\n<p>上面展现的工作使用到了Spring MVC, Hibernate and Spring Boot这些技术</p>\n<h3 id=\"创建领域对象\"><a href=\"#创建领域对象\" class=\"headerlink\" title=\"创建领域对象\"></a>创建领域对象</h3><p>第一步，创建一个用来存储员工详细信息的Employee类，它是一个简单的POJO对象</p>\n<pre><code class=\"java\">@Entity\npublic class Employee {\n\n    @Id\n    @NotNull\n    @Size(max = 64)\n    @Column(name = &quot;id&quot;, nullable = false, updatable = false)\n    private String id;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = &quot;name&quot;, nullable = false)\n    private String name;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = &quot;city&quot;, nullable = false)\n    private String city;\n\n    Employee() {\n    }\n\n    public Employee(final String id, final String name,final String city) {\n        this.id = id;\n        this.name = name;\n        this.city = city;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    @Override\n    public String toString() {\n        return Objects.toStringHelper(this)\n                .add(&quot;id&quot;, id)\n                .add(&quot;name&quot;, name)\n                .add(city, city)\n                .toString();\n    }\n}\n</code></pre>\n<h3 id=\"创建Spring-Data-JPA仓库\"><a href=\"#创建Spring-Data-JPA仓库\" class=\"headerlink\" title=\"创建Spring Data JPA仓库\"></a>创建Spring Data JPA仓库</h3><p>Spring Data JPA是一个非常简单的方法保存数据到后端，如果你看了下面的代码，这就是你要持久化员工类将要写的代码，Spring Data在内部为你实现了必要的类和CRUD的操作，你只需要像下面一样提供一个接口即可，如果你对于Spring Data有兴趣，请阅读我们的<a href=\"http://www.javabeat.net/spring-data-jpa-tutorial/\" target=\"_blank\" rel=\"external\">Spring Data JPA教程</a></p>\n<pre><code>public interface EmployeeRepository extends JpaRepository&lt;Employee, String&gt; {\n}\n</code></pre><h3 id=\"创建服务的实现类\"><a href=\"#创建服务的实现类\" class=\"headerlink\" title=\"创建服务的实现类\"></a>创建服务的实现类</h3><pre><code class=\"java\">@Service\n@Validated\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(EmployeeServiceImpl.class);\n    private final EmployeeRepository repository;\n\n    @Inject\n    public EmployeeServiceImpl(final EmployeeRepository repository) {\n        this.repository = repository;\n    }\n\n    @Transactional\n    public Employee save(@NotNull @Valid final Employee employee) {\n        LOGGER.debug(&quot;Creating {}&quot;, employee);\n        return repository.save(employee);\n    }\n\n    @Transactional(readOnly = true)\n    public List&lt;Employee&gt; getList() {\n        LOGGER.debug(&quot;Retrieving the list of all users&quot;);\n        return repository.findAll();\n    }\n}\n</code></pre>\n<h3 id=\"创建SpringMVC控制器\"><a href=\"#创建SpringMVC控制器\" class=\"headerlink\" title=\"创建SpringMVC控制器\"></a>创建SpringMVC控制器</h3><p>这里对于Spring的开发者来说没有任何新的特性，我们只是创建一个简单实现了对员工的详细信息的添加和列表浏览</p>\n<pre><code>@RestController\npublic class EmployeeController {\n    private final EmployeeService employeeService;\n\n    @Inject\n    public EmployeeController(final EmployeeService employeeService) {\n        this.employeeService = employeeService;\n    }\n\n    @RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)\n    public List&lt;Employee&gt; listEmployees() {\n        List&lt;Employee&gt; employees = employeeService.getList();\n        return employees;\n    }\n    @RequestMapping(value=&quot;/add&quot;,method = RequestMethod.GET)\n    public void addEmployee(@RequestParam(value = &quot;employeeName&quot;, required = false) String employeeName,\n            @RequestParam(value = &quot;employeeId&quot;, required = false) String employeeId,\n            @RequestParam(value = &quot;employeeCity&quot;, required = false) String employeeCity){\n        Employee employee = new Employee(employeeId,employeeName,employeeCity);\n        employeeService.save(employee);\n    }\n}\n</code></pre><h3 id=\"创建JSP页面\"><a href=\"#创建JSP页面\" class=\"headerlink\" title=\"创建JSP页面\"></a>创建JSP页面</h3><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Hello WebSocket&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/add&quot;&gt;\n    &lt;input type=&quot;input&quot; name=&quot;employeeName&quot;&gt;\n    &lt;input type=&quot;input&quot; name=&quot;employeeId&quot;&gt;\n    &lt;input type=&quot;input&quot; name=&quot;employeeCity&quot;&gt;\n    &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"Spring-Boot-应用程序\"><a href=\"#Spring-Boot-应用程序\" class=\"headerlink\" title=\"Spring Boot 应用程序\"></a>Spring Boot 应用程序</h3><p>最后，我们需要写一个Spring Boot application来运行我们的示例，这是一个主应用程序，当你试图执行应用程序时，它将会被SpringBoot调用</p>\n<ul>\n<li>扩展阅读:<a href=\"http://www.javabeat.net/restful-springboot-mongodb/\" target=\"_blank\" rel=\"external\">REStful API using Spring Boot</a></li>\n</ul>\n<pre><code>@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application extends SpringBootServletInitializer {\n\n    public static void main(final String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    protected final SpringApplicationBuilder configure(final SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n}\n</code></pre><p><strong>@EnableAutoConfiguration</strong></p>\n<p>这个注解会试图在类路径下去查找启动应用程序所必需的beans，例如，如果你在类路径下有一个tomcat-embedded.jar，你可能会需要一个TomcatEmbeddedServletContainerFactory，这个包下的这个类被@EnableAutoConfiguration注解就有特殊的意义，通常会被作为默认的使用。再比如，当扫描带有@Entity注解的类它将被用到。通常推荐的做法，你可以在一个包的根下使用@EnableAutoConfiguration注解，这样所有子包和类都会被搜索</p>\n<p><strong>SpringApplication.run()</strong></p>\n<p>SpringApplication类是用于引导和启动Spring应用程序的。引导一个Spring应用程序创建适当的应用程序上下文，加载beans，触发任何命令式的bean对象等</p>\n<p><strong>SpringBootServletInitializer</strong></p>\n<p>这个是运行web应用所必须的，它将打开一个 servlet 容器，并将你的应用绑定到此容器内。</p>\n<h3 id=\"MAVEN配置\"><a href=\"#MAVEN配置\" class=\"headerlink\" title=\"MAVEN配置\"></a>MAVEN配置</h3><p>这个运行SpringBoot应用非常重要的环节。SpringBoot需要通过在构建脚本文件中确定运行应用程序的包依赖，它能支持各种各样的构建工具，但SpringBoot官方文档中重点强调使用Maven和Gradle配置，因此，明智的做法是选择其中任何一个去简单的实现</p>\n<p>这里是使用maven配置如下：</p>\n<pre><code class=\"xml\">&lt;dependencies&gt;\n       &lt;!-- Spring Boot --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n           &lt;scope&gt;test&lt;/scope&gt;\n       &lt;/dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;!-- Hibernate validator --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n           &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;!-- HSQLDB --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;\n           &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;\n           &lt;scope&gt;runtime&lt;/scope&gt;\n       &lt;/dependency&gt;\n       &lt;!-- Guava --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n           &lt;artifactId&gt;guava&lt;/artifactId&gt;\n           &lt;version&gt;${guava.version}&lt;/version&gt;\n       &lt;/dependency&gt;\n       &lt;!-- Java EE --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;javax.inject&lt;/groupId&gt;\n           &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;\n           &lt;version&gt;1&lt;/version&gt;\n       &lt;/dependency&gt;\n   &lt;/dependencies&gt;\n   &lt;build&gt;\n       &lt;plugins&gt;\n           &lt;!-- Spring Boot Maven --&gt;\n           &lt;plugin&gt;\n               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n           &lt;/plugin&gt;\n       &lt;/plugins&gt;\n   &lt;/build&gt;\n</code></pre>\n<p><strong>spring-boot-starter-*</strong></p>\n<p>Starter POM是预定义的作为内置可用的POM集合描述，你不需要去搜索和配置那些依赖。比如，如果你正在为数据访问寻找Spring和JPA依赖，你只需把spring-boot-starter-data-jpa包含到你的POM文件中即可</p>\n<p><strong>spring-boot-maven-plugin</strong></p>\n<p>这个插件允许你将应用程序打包成一个可执行的JAR或WAR文件，它支持Maven 3.2以上版本。在我们的示例，当你使用“mvn install”命令运行项目，maven将构建此项目并且会在target目录创建一个可执行的JAR文件。</p>\n<p><strong>spring-boot-starter-parent</strong></p>\n<p>如果你想从spring-boot-starter-parent继承属性,然后简单地设置此父项目。如果你使用此父项目,版本号可以省略其他starters POM也如此。如果你有你自己的项目为你的项目,那么你可以使用它们代替由SpringBoot默认提供的父项目。配置如下：</p>\n<pre><code class=\"xml\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;1.0.1.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre>\n<h3 id=\"最终项目结构\"><a href=\"#最终项目结构\" class=\"headerlink\" title=\"最终项目结构\"></a>最终项目结构</h3><p>下面图是最终项目的包结构，这里我已经在一个包下面创建了一个Application.java。但好的实践是把这个文件直接放到包的根目录下<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-20/18274027.jpg\" alt=\"最终项目的包结构\"></p>\n<h3 id=\"运行SpringBoot可执行Jar包\"><a href=\"#运行SpringBoot可执行Jar包\" class=\"headerlink\" title=\"运行SpringBoot可执行Jar包\"></a>运行SpringBoot可执行Jar包</h3><p>一旦你创建好了应用程序，运行这个命令来执行应用程序</p>\n<pre><code>java -jar target/mymodule-0.0.1-SNAPSHOT.jar\n</code></pre><p>在你命令行程序运行上面的命令后，SpringBoot应用会在<a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"external\">http://localhost:8080/</a>运行此程序。你可以通过<a href=\"http://localhost:8080/index.jsp\" target=\"_blank\" rel=\"external\">http://localhost:8080/index.jsp</a>访问应用的首页<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-20/78731535.jpg\" alt=\"访问应用的首页\"></p>\n<p>你可以添加很多行员工数据，当你访问<a href=\"http://localhost:8080/employee\" target=\"_blank\" rel=\"external\">http://localhost:8080/employee</a>,你会在浏览器窗口看到类似下面的输出</p>\n<pre><code>[{&quot;id&quot;:&quot;Krishna&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;},{&quot;id&quot;:&quot;Manisha Patil&quot;,&quot;name&quot;:&quot;005&quot;,&quot;city&quot;:&quot;Pune&quot;},{&quot;id&quot;:&quot;Sanulla&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;},{&quot;id&quot;:&quot;Shunmuga Raja&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;}]\n</code></pre><h3 id=\"源码下载\"><a href=\"#源码下载\" class=\"headerlink\" title=\"源码下载\"></a>源码下载</h3><p><a href=\"http://javabeat.net/download/spring-boot-spring-mvc/?wpdmdl=22124\" target=\"_blank\" rel=\"external\">Spring Boot Spring MVC</a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在本文中,我们已经讨论了如何创建一个maven项目和创建员工所需的不同组件管理Spring MVC应用程序。后来我们已经探讨了SpringBoot配置细节和SpringBoot应用所需的Maven POM文件内容。最后我们已经讨论了运行一个通过Maven打包生成可执行JAR文件。在本教程中,您将能够了解关于SpringBoot和Spring MVC是怎样一起工作</p>\n<h3 id=\"博主声明\"><a href=\"#博主声明\" class=\"headerlink\" title=\"博主声明\"></a>博主声明</h3><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href=\"http://javabeat.net/spring-boot-spring-mvc/\" target=\"_blank\" rel=\"external\">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p>\n<p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>\n","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本教程适合对于有兴趣学习Spring Boot如何结合Spring MVC一起开发的初学者。通过本教程,您可以使用Spring Boot运行一个简单的Spring MVC应用程序<br>","more":"</p>\n<blockquote>\n<p>SpringBoot是一个Spring IO中的一个项目，它旨在减少Spring应用程序启动配置和连接。开发人员只专注于编写应用程序，SpringBoot将简化打包和部署的流程，而且不需要任何显示的声明配置。它就是如此在容器之外工作的! 在这里,我将解释如何使用Spring Boot运行一个简单且带有执行CRUD操作的Spring MVC应用程序。开始这个例子之前,请<a href=\"http://www.javabeat.net/maven-eclipse/\">在eclipse中创建web项目</a>。</p>\n</blockquote>\n<ul>\n<li>扩展阅读:<a href=\"http://www.javabeat.net/spring-boot/\">http://www.javabeat.net/spring-boot/</a></li>\n</ul>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>我已经实现了一个例子，例子做了如下的工作</p>\n<ol>\n<li>创建一个Web 页面</li>\n<li>用户可以想数据库中添加员工</li>\n<li>用户可以在浏览器页面查看已添加到数据中的员工列表(JSON形式的结果)</li>\n</ol>\n<p>上面展现的工作使用到了Spring MVC, Hibernate and Spring Boot这些技术</p>\n<h3 id=\"创建领域对象\"><a href=\"#创建领域对象\" class=\"headerlink\" title=\"创建领域对象\"></a>创建领域对象</h3><p>第一步，创建一个用来存储员工详细信息的Employee类，它是一个简单的POJO对象</p>\n<pre><code class=\"java\">@Entity\npublic class Employee {\n\n    @Id\n    @NotNull\n    @Size(max = 64)\n    @Column(name = &quot;id&quot;, nullable = false, updatable = false)\n    private String id;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = &quot;name&quot;, nullable = false)\n    private String name;\n\n    @NotNull\n    @Size(max = 64)\n    @Column(name = &quot;city&quot;, nullable = false)\n    private String city;\n\n    Employee() {\n    }\n\n    public Employee(final String id, final String name,final String city) {\n        this.id = id;\n        this.name = name;\n        this.city = city;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    @Override\n    public String toString() {\n        return Objects.toStringHelper(this)\n                .add(&quot;id&quot;, id)\n                .add(&quot;name&quot;, name)\n                .add(city, city)\n                .toString();\n    }\n}\n</code></pre>\n<h3 id=\"创建Spring-Data-JPA仓库\"><a href=\"#创建Spring-Data-JPA仓库\" class=\"headerlink\" title=\"创建Spring Data JPA仓库\"></a>创建Spring Data JPA仓库</h3><p>Spring Data JPA是一个非常简单的方法保存数据到后端，如果你看了下面的代码，这就是你要持久化员工类将要写的代码，Spring Data在内部为你实现了必要的类和CRUD的操作，你只需要像下面一样提供一个接口即可，如果你对于Spring Data有兴趣，请阅读我们的<a href=\"http://www.javabeat.net/spring-data-jpa-tutorial/\">Spring Data JPA教程</a></p>\n<pre><code>public interface EmployeeRepository extends JpaRepository&lt;Employee, String&gt; {\n}\n</code></pre><h3 id=\"创建服务的实现类\"><a href=\"#创建服务的实现类\" class=\"headerlink\" title=\"创建服务的实现类\"></a>创建服务的实现类</h3><pre><code class=\"java\">@Service\n@Validated\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(EmployeeServiceImpl.class);\n    private final EmployeeRepository repository;\n\n    @Inject\n    public EmployeeServiceImpl(final EmployeeRepository repository) {\n        this.repository = repository;\n    }\n\n    @Transactional\n    public Employee save(@NotNull @Valid final Employee employee) {\n        LOGGER.debug(&quot;Creating {}&quot;, employee);\n        return repository.save(employee);\n    }\n\n    @Transactional(readOnly = true)\n    public List&lt;Employee&gt; getList() {\n        LOGGER.debug(&quot;Retrieving the list of all users&quot;);\n        return repository.findAll();\n    }\n}\n</code></pre>\n<h3 id=\"创建SpringMVC控制器\"><a href=\"#创建SpringMVC控制器\" class=\"headerlink\" title=\"创建SpringMVC控制器\"></a>创建SpringMVC控制器</h3><p>这里对于Spring的开发者来说没有任何新的特性，我们只是创建一个简单实现了对员工的详细信息的添加和列表浏览</p>\n<pre><code>@RestController\npublic class EmployeeController {\n    private final EmployeeService employeeService;\n\n    @Inject\n    public EmployeeController(final EmployeeService employeeService) {\n        this.employeeService = employeeService;\n    }\n\n    @RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)\n    public List&lt;Employee&gt; listEmployees() {\n        List&lt;Employee&gt; employees = employeeService.getList();\n        return employees;\n    }\n    @RequestMapping(value=&quot;/add&quot;,method = RequestMethod.GET)\n    public void addEmployee(@RequestParam(value = &quot;employeeName&quot;, required = false) String employeeName,\n            @RequestParam(value = &quot;employeeId&quot;, required = false) String employeeId,\n            @RequestParam(value = &quot;employeeCity&quot;, required = false) String employeeCity){\n        Employee employee = new Employee(employeeId,employeeName,employeeCity);\n        employeeService.save(employee);\n    }\n}\n</code></pre><h3 id=\"创建JSP页面\"><a href=\"#创建JSP页面\" class=\"headerlink\" title=\"创建JSP页面\"></a>创建JSP页面</h3><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Hello WebSocket&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/add&quot;&gt;\n    &lt;input type=&quot;input&quot; name=&quot;employeeName&quot;&gt;\n    &lt;input type=&quot;input&quot; name=&quot;employeeId&quot;&gt;\n    &lt;input type=&quot;input&quot; name=&quot;employeeCity&quot;&gt;\n    &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"Spring-Boot-应用程序\"><a href=\"#Spring-Boot-应用程序\" class=\"headerlink\" title=\"Spring Boot 应用程序\"></a>Spring Boot 应用程序</h3><p>最后，我们需要写一个Spring Boot application来运行我们的示例，这是一个主应用程序，当你试图执行应用程序时，它将会被SpringBoot调用</p>\n<ul>\n<li>扩展阅读:<a href=\"http://www.javabeat.net/restful-springboot-mongodb/\">REStful API using Spring Boot</a></li>\n</ul>\n<pre><code>@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application extends SpringBootServletInitializer {\n\n    public static void main(final String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Override\n    protected final SpringApplicationBuilder configure(final SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n}\n</code></pre><p><strong>@EnableAutoConfiguration</strong></p>\n<p>这个注解会试图在类路径下去查找启动应用程序所必需的beans，例如，如果你在类路径下有一个tomcat-embedded.jar，你可能会需要一个TomcatEmbeddedServletContainerFactory，这个包下的这个类被@EnableAutoConfiguration注解就有特殊的意义，通常会被作为默认的使用。再比如，当扫描带有@Entity注解的类它将被用到。通常推荐的做法，你可以在一个包的根下使用@EnableAutoConfiguration注解，这样所有子包和类都会被搜索</p>\n<p><strong>SpringApplication.run()</strong></p>\n<p>SpringApplication类是用于引导和启动Spring应用程序的。引导一个Spring应用程序创建适当的应用程序上下文，加载beans，触发任何命令式的bean对象等</p>\n<p><strong>SpringBootServletInitializer</strong></p>\n<p>这个是运行web应用所必须的，它将打开一个 servlet 容器，并将你的应用绑定到此容器内。</p>\n<h3 id=\"MAVEN配置\"><a href=\"#MAVEN配置\" class=\"headerlink\" title=\"MAVEN配置\"></a>MAVEN配置</h3><p>这个运行SpringBoot应用非常重要的环节。SpringBoot需要通过在构建脚本文件中确定运行应用程序的包依赖，它能支持各种各样的构建工具，但SpringBoot官方文档中重点强调使用Maven和Gradle配置，因此，明智的做法是选择其中任何一个去简单的实现</p>\n<p>这里是使用maven配置如下：</p>\n<pre><code class=\"xml\">&lt;dependencies&gt;\n       &lt;!-- Spring Boot --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n           &lt;scope&gt;test&lt;/scope&gt;\n       &lt;/dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;!-- Hibernate validator --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n           &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n       &lt;/dependency&gt;\n       &lt;!-- HSQLDB --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;\n           &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;\n           &lt;scope&gt;runtime&lt;/scope&gt;\n       &lt;/dependency&gt;\n       &lt;!-- Guava --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n           &lt;artifactId&gt;guava&lt;/artifactId&gt;\n           &lt;version&gt;${guava.version}&lt;/version&gt;\n       &lt;/dependency&gt;\n       &lt;!-- Java EE --&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;javax.inject&lt;/groupId&gt;\n           &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;\n           &lt;version&gt;1&lt;/version&gt;\n       &lt;/dependency&gt;\n   &lt;/dependencies&gt;\n   &lt;build&gt;\n       &lt;plugins&gt;\n           &lt;!-- Spring Boot Maven --&gt;\n           &lt;plugin&gt;\n               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n           &lt;/plugin&gt;\n       &lt;/plugins&gt;\n   &lt;/build&gt;\n</code></pre>\n<p><strong>spring-boot-starter-*</strong></p>\n<p>Starter POM是预定义的作为内置可用的POM集合描述，你不需要去搜索和配置那些依赖。比如，如果你正在为数据访问寻找Spring和JPA依赖，你只需把spring-boot-starter-data-jpa包含到你的POM文件中即可</p>\n<p><strong>spring-boot-maven-plugin</strong></p>\n<p>这个插件允许你将应用程序打包成一个可执行的JAR或WAR文件，它支持Maven 3.2以上版本。在我们的示例，当你使用“mvn install”命令运行项目，maven将构建此项目并且会在target目录创建一个可执行的JAR文件。</p>\n<p><strong>spring-boot-starter-parent</strong></p>\n<p>如果你想从spring-boot-starter-parent继承属性,然后简单地设置此父项目。如果你使用此父项目,版本号可以省略其他starters POM也如此。如果你有你自己的项目为你的项目,那么你可以使用它们代替由SpringBoot默认提供的父项目。配置如下：</p>\n<pre><code class=\"xml\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;1.0.1.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre>\n<h3 id=\"最终项目结构\"><a href=\"#最终项目结构\" class=\"headerlink\" title=\"最终项目结构\"></a>最终项目结构</h3><p>下面图是最终项目的包结构，这里我已经在一个包下面创建了一个Application.java。但好的实践是把这个文件直接放到包的根目录下<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-20/18274027.jpg\" alt=\"最终项目的包结构\"></p>\n<h3 id=\"运行SpringBoot可执行Jar包\"><a href=\"#运行SpringBoot可执行Jar包\" class=\"headerlink\" title=\"运行SpringBoot可执行Jar包\"></a>运行SpringBoot可执行Jar包</h3><p>一旦你创建好了应用程序，运行这个命令来执行应用程序</p>\n<pre><code>java -jar target/mymodule-0.0.1-SNAPSHOT.jar\n</code></pre><p>在你命令行程序运行上面的命令后，SpringBoot应用会在<a href=\"http://localhost:8080/\">http://localhost:8080/</a>运行此程序。你可以通过<a href=\"http://localhost:8080/index.jsp\">http://localhost:8080/index.jsp</a>访问应用的首页<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-20/78731535.jpg\" alt=\"访问应用的首页\"></p>\n<p>你可以添加很多行员工数据，当你访问<a href=\"http://localhost:8080/employee\">http://localhost:8080/employee</a>,你会在浏览器窗口看到类似下面的输出</p>\n<pre><code>[{&quot;id&quot;:&quot;Krishna&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;},{&quot;id&quot;:&quot;Manisha Patil&quot;,&quot;name&quot;:&quot;005&quot;,&quot;city&quot;:&quot;Pune&quot;},{&quot;id&quot;:&quot;Sanulla&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;},{&quot;id&quot;:&quot;Shunmuga Raja&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;}]\n</code></pre><h3 id=\"源码下载\"><a href=\"#源码下载\" class=\"headerlink\" title=\"源码下载\"></a>源码下载</h3><p><a href=\"http://javabeat.net/download/spring-boot-spring-mvc/?wpdmdl=22124\">Spring Boot Spring MVC</a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在本文中,我们已经讨论了如何创建一个maven项目和创建员工所需的不同组件管理Spring MVC应用程序。后来我们已经探讨了SpringBoot配置细节和SpringBoot应用所需的Maven POM文件内容。最后我们已经讨论了运行一个通过Maven打包生成可执行JAR文件。在本教程中,您将能够了解关于SpringBoot和Spring MVC是怎样一起工作</p>\n<h3 id=\"博主声明\"><a href=\"#博主声明\" class=\"headerlink\" title=\"博主声明\"></a>博主声明</h3><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href=\"http://javabeat.net/spring-boot-spring-mvc/\">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p>\n<p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>"},{"title":"为hexo博客加入prettify高亮插件","date":"2016-07-02T13:14:37.000Z","_content":"\n使用hexo的默认高亮插件总感觉支持的太少，代码高亮显示的不够细，下面我们来看下怎么把它替换为prettify高亮插件\n\n\n\n## 第一步：禁用默认高亮插件\n\n在hexo博客_config.yml中将highlight插件禁用\n```\nhighlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n```\n<!--more-->\n\n## 第二步：引用prettify插件\n\n### **下载插件**\n\n从github下载[prettify](https://github.com/google/code-prettify)源码，解压后将src目录重命名(如prettify)，然后拷贝至你的hexo博客的source目录，建议在博客source目录单独建立一个插件目录(plugins)存放，以后所有的插件都放置到此目录，这里我就是拷贝到source/plugins目录下,如图**（注：必须放在source目录下面，否则生成静态文章的时候无法输出到public目录）**\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5h1gmp2m7j20k709bmzm.jpg)\n\n接着我们还要对hexo的_config.yml做如下配置\n\n```yml\nskip_render:\n    - \"plugins/**\"\n```\n这个配置就是要告诉hexo对plugins目录下的所有文件跳过解析渲染，因为测试时发现如果不配置，加载prettify的相关js会报脚本错误，猜测hexo渲染造成的编码问题\n\n### **引用插件**\n\n在yilia的主题下面找到`yilia\\layout\\_partial\\head.ejs`和`yilia\\layout\\_partial\\after-footer.ejs`两个文件，分别引入样式和脚本文件（如果你用的是其他主题，可参照对应）\n\n在head.ejs中引入样式\n\n```js\n.....省略代码.......\n<!--prettify代码高亮主题css引入-->\n<link href=\"/plugins/prettify/prettify.css\" rel=\"stylesheet\">\n.....省略代码.......\n```\n\n在after-footer.ejs中引入脚本\n```js\n.....省略代码.......\n<!--prettify代码高亮脚本引入-->\n<script src=\"/plugins/prettify/prettify.js\"></script>\n<script type=\"text/javascript\">\n$(window).load(function(){\n$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');\n prettyPrint();\n})\n</script>\n.....省略代码.......\n```\n**注意：脚本文件引入注意一定要在jquery脚本之后**\n\n**启动生成浏览**\n\n此时我们用`hexo clean && hexo g && hexo server` 发布浏览，结果代码高亮怪怪的，如图:\n\n![](http://ww4.sinaimg.cn/large/7462786bgw1f5gnoo6byij210x0g5wi3.jpg)\n\n此时F12我们定位此块代码样式发现，刚第一步禁用的highlight高亮插件的样式还是会加载\n\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5gnphrzndj21es09kwj8.jpg)\n\n## 第三步：对yilia主题调整修改\n\n 上一步高亮结果显示有问题，于是立马怀疑yilia主题没有对highlight配置项做开关控制，结果发现在`themes\\yilia\\source\\css\\style.styl`文件确实没有做开关设置，而是直接引入\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5h231d2yjj20i60ccdhb.jpg)\n\n所以，接下来要稍微做下调整\n1. 把上面的红框标记的那一行注释掉\n2. 仔细观察发现还有样式文件的影响，继续找到`themes\\yilia\\source\\css\\_partial\\article.styl`文件先备份下，\n然后将其中搜下所有pre,code 标签关联的样式删除之\n3. 最后再在`themes\\yilia\\source\\css\\style.styl`文件中在加入下面几行调整样式\n\n  ```ss\n  /*解决prettyify在yilia主题下面行号显示问题*/\n  pre.prettyprint{\n    padding-left: 20px;\n  }\n\n  /*代码自动换行*/\n  pre{\n      word-break: break-all;\n      word-wrap: break-word;\n    }\n  ```\n\n### **大功告成**\n\n总算不白折腾，重新hexo生成发布浏览，prettify就能正常高亮代码了\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5h4twn7n2j210k0mitc3.jpg)\n\n但默认主题样式还不够炫(niu)酷(bi),这里给大家提供n套[prettify主题](https://github.com/jmblog/color-themes-for-google-code-prettify/blob/master/dist/themes.zip)供大家下载,下载后解压，在themes目录下面有多套主题样式，如图：\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5i9ibsy1uj20cd0jegp9.jpg)\n\n这里面每套主题都对应一个未压缩版和压缩版，而每套主题的效果，可以[点击此链接](https://jmblog.github.io/color-themes-for-google-code-prettify/)查看，喜欢那套样式，就直接重命名为prettify替换原来的prettify.css应用即可\n\n## 继续优化\n\n根据上述步骤，我们已经将默认高亮插件成功的替换成prettify高亮插件，但有两处不方便的地方\n1. prettify插件有很多高亮主题样式，如果以后我们想替换其他主题样式，没有提供可配置主题自动替换\n2. 想换回默认高亮插件得手动还原回去，不灵活\n基于上面的问题考虑，我们来通过加入几个配置项，使其能够做到灵活切换主题和插件\n\n### 增加配置项\n\n1. 在hexo博客的根目录找到_config.yml,加入下面配置\n    ```\n    #prettify 插件位置\n    # enable 启用和不启用\n    # theme 使用prettify高亮主题名称\n    prettify:\n      enable: true\n      theme: \"这里你可以定义上面下载的themes主题包里面样式文件名，不带.css后缀\"\n    ```\n\n2. 在你安装的主题根目录下面找到_config.yml,加入下面配置\n    ```\n    #highlight启用和禁用\n    highlight:\n      enable: false\n    ```\n3. 将你上面下载的prettify主题包解压后拷贝到博客`source/plugins/`目录，如下：\n\n   ![](http://ww2.sinaimg.cn/large/7462786bgw1f5ia1mb52vj20bm01ka9y.jpg)\n\n###  加入主题开关判断\n1. 修改 themes\\yilia\\source\\css\\_variables.styl 文件，在文件任意位置加入下面这行\n   ```\n    highlight = hexo-config(\"highlight.enable\")\n   ```\n2. 在themes\\yilia\\source\\css\\style.styl文件，加入开关判断\n    ```\n    if highlight{\n     @import \"_partial/highlight\"\n    }\n    ```\n3. 分别对`yilia\\layout\\_partial\\head.ejs`和`yilia\\layout\\_partial\\after-footer.ejs`两个文件做调整\n\n   head.ejs调整如下：\n   ```\n   <% if (config.prettify.enable){ %>\n     <!--prettify代码高亮主题css引入-->\n     <link href=\"/plugins/prettify/themes/<%= config.prettify.theme %>.css\" rel=\"stylesheet\">\n   <% } %>\n   ```\n   after-footer.ejs调整如下：\n   ```\n   <!--prettify代码高亮js引入-->\n   <% if (config.prettify.enable){ %>\n   <script src=\"/plugins/prettify/prettify.js\"></script>\n   <script type=\"text/javascript\">\n   $(window).load(function(){\n   $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');\n    prettyPrint();\n   })\n   </script>\n   <%}%>\n   ```\n   这里引用prettify的样式文件统一定位到/plugins/prettify/themes/下面，所以如果你用默认的prettify.css样式\n   只要要把默认样式也拷贝到/plugins/prettify/themes/目录下面即可\n\n通过以上的配置，我们就可以灵活的切换prettify高亮主题了，并且通过配置可以来回切换高亮插件，只要你想要，就是这么任性！\n","source":"_posts/use-and-install-prettify.md","raw":"---\ntitle: 为hexo博客加入prettify高亮插件\ndate: 2016-07-02 21:14:37\ntags: [hexo,prettify,高亮插件]\ncategories: 折腾记\n---\n\n使用hexo的默认高亮插件总感觉支持的太少，代码高亮显示的不够细，下面我们来看下怎么把它替换为prettify高亮插件\n\n\n\n## 第一步：禁用默认高亮插件\n\n在hexo博客_config.yml中将highlight插件禁用\n```\nhighlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n```\n<!--more-->\n\n## 第二步：引用prettify插件\n\n### **下载插件**\n\n从github下载[prettify](https://github.com/google/code-prettify)源码，解压后将src目录重命名(如prettify)，然后拷贝至你的hexo博客的source目录，建议在博客source目录单独建立一个插件目录(plugins)存放，以后所有的插件都放置到此目录，这里我就是拷贝到source/plugins目录下,如图**（注：必须放在source目录下面，否则生成静态文章的时候无法输出到public目录）**\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5h1gmp2m7j20k709bmzm.jpg)\n\n接着我们还要对hexo的_config.yml做如下配置\n\n```yml\nskip_render:\n    - \"plugins/**\"\n```\n这个配置就是要告诉hexo对plugins目录下的所有文件跳过解析渲染，因为测试时发现如果不配置，加载prettify的相关js会报脚本错误，猜测hexo渲染造成的编码问题\n\n### **引用插件**\n\n在yilia的主题下面找到`yilia\\layout\\_partial\\head.ejs`和`yilia\\layout\\_partial\\after-footer.ejs`两个文件，分别引入样式和脚本文件（如果你用的是其他主题，可参照对应）\n\n在head.ejs中引入样式\n\n```js\n.....省略代码.......\n<!--prettify代码高亮主题css引入-->\n<link href=\"/plugins/prettify/prettify.css\" rel=\"stylesheet\">\n.....省略代码.......\n```\n\n在after-footer.ejs中引入脚本\n```js\n.....省略代码.......\n<!--prettify代码高亮脚本引入-->\n<script src=\"/plugins/prettify/prettify.js\"></script>\n<script type=\"text/javascript\">\n$(window).load(function(){\n$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');\n prettyPrint();\n})\n</script>\n.....省略代码.......\n```\n**注意：脚本文件引入注意一定要在jquery脚本之后**\n\n**启动生成浏览**\n\n此时我们用`hexo clean && hexo g && hexo server` 发布浏览，结果代码高亮怪怪的，如图:\n\n![](http://ww4.sinaimg.cn/large/7462786bgw1f5gnoo6byij210x0g5wi3.jpg)\n\n此时F12我们定位此块代码样式发现，刚第一步禁用的highlight高亮插件的样式还是会加载\n\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5gnphrzndj21es09kwj8.jpg)\n\n## 第三步：对yilia主题调整修改\n\n 上一步高亮结果显示有问题，于是立马怀疑yilia主题没有对highlight配置项做开关控制，结果发现在`themes\\yilia\\source\\css\\style.styl`文件确实没有做开关设置，而是直接引入\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5h231d2yjj20i60ccdhb.jpg)\n\n所以，接下来要稍微做下调整\n1. 把上面的红框标记的那一行注释掉\n2. 仔细观察发现还有样式文件的影响，继续找到`themes\\yilia\\source\\css\\_partial\\article.styl`文件先备份下，\n然后将其中搜下所有pre,code 标签关联的样式删除之\n3. 最后再在`themes\\yilia\\source\\css\\style.styl`文件中在加入下面几行调整样式\n\n  ```ss\n  /*解决prettyify在yilia主题下面行号显示问题*/\n  pre.prettyprint{\n    padding-left: 20px;\n  }\n\n  /*代码自动换行*/\n  pre{\n      word-break: break-all;\n      word-wrap: break-word;\n    }\n  ```\n\n### **大功告成**\n\n总算不白折腾，重新hexo生成发布浏览，prettify就能正常高亮代码了\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5h4twn7n2j210k0mitc3.jpg)\n\n但默认主题样式还不够炫(niu)酷(bi),这里给大家提供n套[prettify主题](https://github.com/jmblog/color-themes-for-google-code-prettify/blob/master/dist/themes.zip)供大家下载,下载后解压，在themes目录下面有多套主题样式，如图：\n![](http://ww2.sinaimg.cn/large/7462786bgw1f5i9ibsy1uj20cd0jegp9.jpg)\n\n这里面每套主题都对应一个未压缩版和压缩版，而每套主题的效果，可以[点击此链接](https://jmblog.github.io/color-themes-for-google-code-prettify/)查看，喜欢那套样式，就直接重命名为prettify替换原来的prettify.css应用即可\n\n## 继续优化\n\n根据上述步骤，我们已经将默认高亮插件成功的替换成prettify高亮插件，但有两处不方便的地方\n1. prettify插件有很多高亮主题样式，如果以后我们想替换其他主题样式，没有提供可配置主题自动替换\n2. 想换回默认高亮插件得手动还原回去，不灵活\n基于上面的问题考虑，我们来通过加入几个配置项，使其能够做到灵活切换主题和插件\n\n### 增加配置项\n\n1. 在hexo博客的根目录找到_config.yml,加入下面配置\n    ```\n    #prettify 插件位置\n    # enable 启用和不启用\n    # theme 使用prettify高亮主题名称\n    prettify:\n      enable: true\n      theme: \"这里你可以定义上面下载的themes主题包里面样式文件名，不带.css后缀\"\n    ```\n\n2. 在你安装的主题根目录下面找到_config.yml,加入下面配置\n    ```\n    #highlight启用和禁用\n    highlight:\n      enable: false\n    ```\n3. 将你上面下载的prettify主题包解压后拷贝到博客`source/plugins/`目录，如下：\n\n   ![](http://ww2.sinaimg.cn/large/7462786bgw1f5ia1mb52vj20bm01ka9y.jpg)\n\n###  加入主题开关判断\n1. 修改 themes\\yilia\\source\\css\\_variables.styl 文件，在文件任意位置加入下面这行\n   ```\n    highlight = hexo-config(\"highlight.enable\")\n   ```\n2. 在themes\\yilia\\source\\css\\style.styl文件，加入开关判断\n    ```\n    if highlight{\n     @import \"_partial/highlight\"\n    }\n    ```\n3. 分别对`yilia\\layout\\_partial\\head.ejs`和`yilia\\layout\\_partial\\after-footer.ejs`两个文件做调整\n\n   head.ejs调整如下：\n   ```\n   <% if (config.prettify.enable){ %>\n     <!--prettify代码高亮主题css引入-->\n     <link href=\"/plugins/prettify/themes/<%= config.prettify.theme %>.css\" rel=\"stylesheet\">\n   <% } %>\n   ```\n   after-footer.ejs调整如下：\n   ```\n   <!--prettify代码高亮js引入-->\n   <% if (config.prettify.enable){ %>\n   <script src=\"/plugins/prettify/prettify.js\"></script>\n   <script type=\"text/javascript\">\n   $(window).load(function(){\n   $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');\n    prettyPrint();\n   })\n   </script>\n   <%}%>\n   ```\n   这里引用prettify的样式文件统一定位到/plugins/prettify/themes/下面，所以如果你用默认的prettify.css样式\n   只要要把默认样式也拷贝到/plugins/prettify/themes/目录下面即可\n\n通过以上的配置，我们就可以灵活的切换prettify高亮主题了，并且通过配置可以来回切换高亮插件，只要你想要，就是这么任性！\n","slug":"use-and-install-prettify","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obswf001yqk5cn6r3z3uu","content":"<p>使用hexo的默认高亮插件总感觉支持的太少，代码高亮显示的不够细，下面我们来看下怎么把它替换为prettify高亮插件</p>\n<h2 id=\"第一步：禁用默认高亮插件\"><a href=\"#第一步：禁用默认高亮插件\" class=\"headerlink\" title=\"第一步：禁用默认高亮插件\"></a>第一步：禁用默认高亮插件</h2><p>在hexo博客_config.yml中将highlight插件禁用</p>\n<pre><code>highlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n</code></pre><a id=\"more\"></a>\n<h2 id=\"第二步：引用prettify插件\"><a href=\"#第二步：引用prettify插件\" class=\"headerlink\" title=\"第二步：引用prettify插件\"></a>第二步：引用prettify插件</h2><h3 id=\"下载插件\"><a href=\"#下载插件\" class=\"headerlink\" title=\"下载插件\"></a><strong>下载插件</strong></h3><p>从github下载<a href=\"https://github.com/google/code-prettify\" target=\"_blank\" rel=\"external\">prettify</a>源码，解压后将src目录重命名(如prettify)，然后拷贝至你的hexo博客的source目录，建议在博客source目录单独建立一个插件目录(plugins)存放，以后所有的插件都放置到此目录，这里我就是拷贝到source/plugins目录下,如图<strong>（注：必须放在source目录下面，否则生成静态文章的时候无法输出到public目录）</strong><br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5h1gmp2m7j20k709bmzm.jpg\" alt=\"\"></p>\n<p>接着我们还要对hexo的_config.yml做如下配置</p>\n<pre><code class=\"yml\">skip_render:\n    - &quot;plugins/**&quot;\n</code></pre>\n<p>这个配置就是要告诉hexo对plugins目录下的所有文件跳过解析渲染，因为测试时发现如果不配置，加载prettify的相关js会报脚本错误，猜测hexo渲染造成的编码问题</p>\n<h3 id=\"引用插件\"><a href=\"#引用插件\" class=\"headerlink\" title=\"引用插件\"></a><strong>引用插件</strong></h3><p>在yilia的主题下面找到<code>yilia\\layout\\_partial\\head.ejs</code>和<code>yilia\\layout\\_partial\\after-footer.ejs</code>两个文件，分别引入样式和脚本文件（如果你用的是其他主题，可参照对应）</p>\n<p>在head.ejs中引入样式</p>\n<pre><code class=\"js\">.....省略代码.......\n&lt;!--prettify代码高亮主题css引入--&gt;\n&lt;link href=&quot;/plugins/prettify/prettify.css&quot; rel=&quot;stylesheet&quot;&gt;\n.....省略代码.......\n</code></pre>\n<p>在after-footer.ejs中引入脚本</p>\n<pre><code class=\"js\">.....省略代码.......\n&lt;!--prettify代码高亮脚本引入--&gt;\n&lt;script src=&quot;/plugins/prettify/prettify.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n$(window).load(function(){\n$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);\n prettyPrint();\n})\n&lt;/script&gt;\n.....省略代码.......\n</code></pre>\n<p><strong>注意：脚本文件引入注意一定要在jquery脚本之后</strong></p>\n<p><strong>启动生成浏览</strong></p>\n<p>此时我们用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo server</code> 发布浏览，结果代码高亮怪怪的，如图:</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/7462786bgw1f5gnoo6byij210x0g5wi3.jpg\" alt=\"\"></p>\n<p>此时F12我们定位此块代码样式发现，刚第一步禁用的highlight高亮插件的样式还是会加载</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5gnphrzndj21es09kwj8.jpg\" alt=\"\"></p>\n<h2 id=\"第三步：对yilia主题调整修改\"><a href=\"#第三步：对yilia主题调整修改\" class=\"headerlink\" title=\"第三步：对yilia主题调整修改\"></a>第三步：对yilia主题调整修改</h2><p> 上一步高亮结果显示有问题，于是立马怀疑yilia主题没有对highlight配置项做开关控制，结果发现在<code>themes\\yilia\\source\\css\\style.styl</code>文件确实没有做开关设置，而是直接引入<br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5h231d2yjj20i60ccdhb.jpg\" alt=\"\"></p>\n<p>所以，接下来要稍微做下调整</p>\n<ol>\n<li>把上面的红框标记的那一行注释掉</li>\n<li>仔细观察发现还有样式文件的影响，继续找到<code>themes\\yilia\\source\\css\\_partial\\article.styl</code>文件先备份下，<br>然后将其中搜下所有pre,code 标签关联的样式删除之</li>\n<li><p>最后再在<code>themes\\yilia\\source\\css\\style.styl</code>文件中在加入下面几行调整样式</p>\n<pre><code class=\"ss\">/*解决prettyify在yilia主题下面行号显示问题*/\npre.prettyprint{\n padding-left: 20px;\n}\n\n/*代码自动换行*/\npre{\n   word-break: break-all;\n   word-wrap: break-word;\n }\n</code></pre>\n</li>\n</ol>\n<h3 id=\"大功告成\"><a href=\"#大功告成\" class=\"headerlink\" title=\"大功告成\"></a><strong>大功告成</strong></h3><p>总算不白折腾，重新hexo生成发布浏览，prettify就能正常高亮代码了<br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5h4twn7n2j210k0mitc3.jpg\" alt=\"\"></p>\n<p>但默认主题样式还不够炫(niu)酷(bi),这里给大家提供n套<a href=\"https://github.com/jmblog/color-themes-for-google-code-prettify/blob/master/dist/themes.zip\" target=\"_blank\" rel=\"external\">prettify主题</a>供大家下载,下载后解压，在themes目录下面有多套主题样式，如图：<br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5i9ibsy1uj20cd0jegp9.jpg\" alt=\"\"></p>\n<p>这里面每套主题都对应一个未压缩版和压缩版，而每套主题的效果，可以<a href=\"https://jmblog.github.io/color-themes-for-google-code-prettify/\" target=\"_blank\" rel=\"external\">点击此链接</a>查看，喜欢那套样式，就直接重命名为prettify替换原来的prettify.css应用即可</p>\n<h2 id=\"继续优化\"><a href=\"#继续优化\" class=\"headerlink\" title=\"继续优化\"></a>继续优化</h2><p>根据上述步骤，我们已经将默认高亮插件成功的替换成prettify高亮插件，但有两处不方便的地方</p>\n<ol>\n<li>prettify插件有很多高亮主题样式，如果以后我们想替换其他主题样式，没有提供可配置主题自动替换</li>\n<li>想换回默认高亮插件得手动还原回去，不灵活<br>基于上面的问题考虑，我们来通过加入几个配置项，使其能够做到灵活切换主题和插件</li>\n</ol>\n<h3 id=\"增加配置项\"><a href=\"#增加配置项\" class=\"headerlink\" title=\"增加配置项\"></a>增加配置项</h3><ol>\n<li><p>在hexo博客的根目录找到_config.yml,加入下面配置</p>\n<pre><code> #prettify 插件位置\n # enable 启用和不启用\n # theme 使用prettify高亮主题名称\n prettify:\n   enable: true\n   theme: &quot;这里你可以定义上面下载的themes主题包里面样式文件名，不带.css后缀&quot;\n</code></pre></li>\n<li><p>在你安装的主题根目录下面找到_config.yml,加入下面配置</p>\n<pre><code> #highlight启用和禁用\n highlight:\n   enable: false\n</code></pre></li>\n<li><p>将你上面下载的prettify主题包解压后拷贝到博客<code>source/plugins/</code>目录，如下：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5ia1mb52vj20bm01ka9y.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"加入主题开关判断\"><a href=\"#加入主题开关判断\" class=\"headerlink\" title=\"加入主题开关判断\"></a>加入主题开关判断</h3><ol>\n<li>修改 themes\\yilia\\source\\css_variables.styl 文件，在文件任意位置加入下面这行<pre><code> highlight = hexo-config(&quot;highlight.enable&quot;)\n</code></pre></li>\n<li>在themes\\yilia\\source\\css\\style.styl文件，加入开关判断<pre><code> if highlight{\n  @import &quot;_partial/highlight&quot;\n }\n</code></pre></li>\n<li><p>分别对<code>yilia\\layout\\_partial\\head.ejs</code>和<code>yilia\\layout\\_partial\\after-footer.ejs</code>两个文件做调整</p>\n<p>head.ejs调整如下：</p>\n<pre><code>&lt;% if (config.prettify.enable){ %&gt;\n  &lt;!--prettify代码高亮主题css引入--&gt;\n  &lt;link href=&quot;/plugins/prettify/themes/&lt;%= config.prettify.theme %&gt;.css&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;% } %&gt;\n</code></pre><p>after-footer.ejs调整如下：</p>\n<pre><code>&lt;!--prettify代码高亮js引入--&gt;\n&lt;% if (config.prettify.enable){ %&gt;\n&lt;script src=&quot;/plugins/prettify/prettify.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n$(window).load(function(){\n$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);\n prettyPrint();\n})\n&lt;/script&gt;\n&lt;%}%&gt;\n</code></pre><p>这里引用prettify的样式文件统一定位到/plugins/prettify/themes/下面，所以如果你用默认的prettify.css样式<br>只要要把默认样式也拷贝到/plugins/prettify/themes/目录下面即可</p>\n</li>\n</ol>\n<p>通过以上的配置，我们就可以灵活的切换prettify高亮主题了，并且通过配置可以来回切换高亮插件，只要你想要，就是这么任性！</p>\n","excerpt":"<p>使用hexo的默认高亮插件总感觉支持的太少，代码高亮显示的不够细，下面我们来看下怎么把它替换为prettify高亮插件</p>\n<h2 id=\"第一步：禁用默认高亮插件\"><a href=\"#第一步：禁用默认高亮插件\" class=\"headerlink\" title=\"第一步：禁用默认高亮插件\"></a>第一步：禁用默认高亮插件</h2><p>在hexo博客_config.yml中将highlight插件禁用</p>\n<pre><code>highlight:\n  enable: false\n  line_number: false\n  auto_detect: false\n  tab_replace:\n</code></pre>","more":"<h2 id=\"第二步：引用prettify插件\"><a href=\"#第二步：引用prettify插件\" class=\"headerlink\" title=\"第二步：引用prettify插件\"></a>第二步：引用prettify插件</h2><h3 id=\"下载插件\"><a href=\"#下载插件\" class=\"headerlink\" title=\"下载插件\"></a><strong>下载插件</strong></h3><p>从github下载<a href=\"https://github.com/google/code-prettify\">prettify</a>源码，解压后将src目录重命名(如prettify)，然后拷贝至你的hexo博客的source目录，建议在博客source目录单独建立一个插件目录(plugins)存放，以后所有的插件都放置到此目录，这里我就是拷贝到source/plugins目录下,如图<strong>（注：必须放在source目录下面，否则生成静态文章的时候无法输出到public目录）</strong><br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5h1gmp2m7j20k709bmzm.jpg\" alt=\"\"></p>\n<p>接着我们还要对hexo的_config.yml做如下配置</p>\n<pre><code class=\"yml\">skip_render:\n    - &quot;plugins/**&quot;\n</code></pre>\n<p>这个配置就是要告诉hexo对plugins目录下的所有文件跳过解析渲染，因为测试时发现如果不配置，加载prettify的相关js会报脚本错误，猜测hexo渲染造成的编码问题</p>\n<h3 id=\"引用插件\"><a href=\"#引用插件\" class=\"headerlink\" title=\"引用插件\"></a><strong>引用插件</strong></h3><p>在yilia的主题下面找到<code>yilia\\layout\\_partial\\head.ejs</code>和<code>yilia\\layout\\_partial\\after-footer.ejs</code>两个文件，分别引入样式和脚本文件（如果你用的是其他主题，可参照对应）</p>\n<p>在head.ejs中引入样式</p>\n<pre><code class=\"js\">.....省略代码.......\n&lt;!--prettify代码高亮主题css引入--&gt;\n&lt;link href=&quot;/plugins/prettify/prettify.css&quot; rel=&quot;stylesheet&quot;&gt;\n.....省略代码.......\n</code></pre>\n<p>在after-footer.ejs中引入脚本</p>\n<pre><code class=\"js\">.....省略代码.......\n&lt;!--prettify代码高亮脚本引入--&gt;\n&lt;script src=&quot;/plugins/prettify/prettify.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n$(window).load(function(){\n$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);\n prettyPrint();\n})\n&lt;/script&gt;\n.....省略代码.......\n</code></pre>\n<p><strong>注意：脚本文件引入注意一定要在jquery脚本之后</strong></p>\n<p><strong>启动生成浏览</strong></p>\n<p>此时我们用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo server</code> 发布浏览，结果代码高亮怪怪的，如图:</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/7462786bgw1f5gnoo6byij210x0g5wi3.jpg\" alt=\"\"></p>\n<p>此时F12我们定位此块代码样式发现，刚第一步禁用的highlight高亮插件的样式还是会加载</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5gnphrzndj21es09kwj8.jpg\" alt=\"\"></p>\n<h2 id=\"第三步：对yilia主题调整修改\"><a href=\"#第三步：对yilia主题调整修改\" class=\"headerlink\" title=\"第三步：对yilia主题调整修改\"></a>第三步：对yilia主题调整修改</h2><p> 上一步高亮结果显示有问题，于是立马怀疑yilia主题没有对highlight配置项做开关控制，结果发现在<code>themes\\yilia\\source\\css\\style.styl</code>文件确实没有做开关设置，而是直接引入<br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5h231d2yjj20i60ccdhb.jpg\" alt=\"\"></p>\n<p>所以，接下来要稍微做下调整</p>\n<ol>\n<li>把上面的红框标记的那一行注释掉</li>\n<li>仔细观察发现还有样式文件的影响，继续找到<code>themes\\yilia\\source\\css\\_partial\\article.styl</code>文件先备份下，<br>然后将其中搜下所有pre,code 标签关联的样式删除之</li>\n<li><p>最后再在<code>themes\\yilia\\source\\css\\style.styl</code>文件中在加入下面几行调整样式</p>\n<pre><code class=\"ss\">/*解决prettyify在yilia主题下面行号显示问题*/\npre.prettyprint{\n padding-left: 20px;\n}\n\n/*代码自动换行*/\npre{\n   word-break: break-all;\n   word-wrap: break-word;\n }\n</code></pre>\n</li>\n</ol>\n<h3 id=\"大功告成\"><a href=\"#大功告成\" class=\"headerlink\" title=\"大功告成\"></a><strong>大功告成</strong></h3><p>总算不白折腾，重新hexo生成发布浏览，prettify就能正常高亮代码了<br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5h4twn7n2j210k0mitc3.jpg\" alt=\"\"></p>\n<p>但默认主题样式还不够炫(niu)酷(bi),这里给大家提供n套<a href=\"https://github.com/jmblog/color-themes-for-google-code-prettify/blob/master/dist/themes.zip\">prettify主题</a>供大家下载,下载后解压，在themes目录下面有多套主题样式，如图：<br><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5i9ibsy1uj20cd0jegp9.jpg\" alt=\"\"></p>\n<p>这里面每套主题都对应一个未压缩版和压缩版，而每套主题的效果，可以<a href=\"https://jmblog.github.io/color-themes-for-google-code-prettify/\">点击此链接</a>查看，喜欢那套样式，就直接重命名为prettify替换原来的prettify.css应用即可</p>\n<h2 id=\"继续优化\"><a href=\"#继续优化\" class=\"headerlink\" title=\"继续优化\"></a>继续优化</h2><p>根据上述步骤，我们已经将默认高亮插件成功的替换成prettify高亮插件，但有两处不方便的地方</p>\n<ol>\n<li>prettify插件有很多高亮主题样式，如果以后我们想替换其他主题样式，没有提供可配置主题自动替换</li>\n<li>想换回默认高亮插件得手动还原回去，不灵活<br>基于上面的问题考虑，我们来通过加入几个配置项，使其能够做到灵活切换主题和插件</li>\n</ol>\n<h3 id=\"增加配置项\"><a href=\"#增加配置项\" class=\"headerlink\" title=\"增加配置项\"></a>增加配置项</h3><ol>\n<li><p>在hexo博客的根目录找到_config.yml,加入下面配置</p>\n<pre><code> #prettify 插件位置\n # enable 启用和不启用\n # theme 使用prettify高亮主题名称\n prettify:\n   enable: true\n   theme: &quot;这里你可以定义上面下载的themes主题包里面样式文件名，不带.css后缀&quot;\n</code></pre></li>\n<li><p>在你安装的主题根目录下面找到_config.yml,加入下面配置</p>\n<pre><code> #highlight启用和禁用\n highlight:\n   enable: false\n</code></pre></li>\n<li><p>将你上面下载的prettify主题包解压后拷贝到博客<code>source/plugins/</code>目录，如下：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7462786bgw1f5ia1mb52vj20bm01ka9y.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"加入主题开关判断\"><a href=\"#加入主题开关判断\" class=\"headerlink\" title=\"加入主题开关判断\"></a>加入主题开关判断</h3><ol>\n<li>修改 themes\\yilia\\source\\css_variables.styl 文件，在文件任意位置加入下面这行<pre><code> highlight = hexo-config(&quot;highlight.enable&quot;)\n</code></pre></li>\n<li>在themes\\yilia\\source\\css\\style.styl文件，加入开关判断<pre><code> if highlight{\n  @import &quot;_partial/highlight&quot;\n }\n</code></pre></li>\n<li><p>分别对<code>yilia\\layout\\_partial\\head.ejs</code>和<code>yilia\\layout\\_partial\\after-footer.ejs</code>两个文件做调整</p>\n<p>head.ejs调整如下：</p>\n<pre><code>&lt;% if (config.prettify.enable){ %&gt;\n  &lt;!--prettify代码高亮主题css引入--&gt;\n  &lt;link href=&quot;/plugins/prettify/themes/&lt;%= config.prettify.theme %&gt;.css&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;% } %&gt;\n</code></pre><p>after-footer.ejs调整如下：</p>\n<pre><code>&lt;!--prettify代码高亮js引入--&gt;\n&lt;% if (config.prettify.enable){ %&gt;\n&lt;script src=&quot;/plugins/prettify/prettify.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n$(window).load(function(){\n$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);\n prettyPrint();\n})\n&lt;/script&gt;\n&lt;%}%&gt;\n</code></pre><p>这里引用prettify的样式文件统一定位到/plugins/prettify/themes/下面，所以如果你用默认的prettify.css样式<br>只要要把默认样式也拷贝到/plugins/prettify/themes/目录下面即可</p>\n</li>\n</ol>\n<p>通过以上的配置，我们就可以灵活的切换prettify高亮主题了，并且通过配置可以来回切换高亮插件，只要你想要，就是这么任性！</p>"},{"title":"在windows,linux下搭建zookeeper集群环境","date":"2016-08-13T09:56:29.000Z","_content":"## Zookeeper简介\n\nZookeeper是一个分布式服务框架，它是 Apache Hadoop 的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。本文将介绍Zookeeper如何在windows和linux下的进行集群部署，以便为我们使用zookeeper的相关功能做好环境支持\n\n<!--more-->\n\n## 安装前提\n\nzookeeper本身要依赖java jdk环境，在搭建前需要确认你的系统安装了java jdk，并配置好了jdk环境变量\n\n## win下搭建zookeeper集群\n\n由于机器有限，本次教程准备在单台机器搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境\n\n### 安装包下载\n\n访问[https://zookeeper.apache.org/](https://zookeeper.apache.org/ 'zookeeper官网')找到并下载我们需要安装的版本，这里我选择下载[zookeeper 3.4.6版本](http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz)(注：zookeeper安装包不区分操作系统平台)\n\n### 安装包解压，集群节点建立\n\n1. 创建集群目录如`D:\\ProgramFiles\\zk_cluster`,并在集群目录下创建三个目录s1,s2,s3，代表三个zookeeper集群节点，如图:\n![三个zookeeper节点目录](http://oaefo3hoy.bkt.clouddn.com/16-8-13/78596671.jpg)\n\n2. 将下载的安装包解压到指定zookeeper节点目录，本教程我先解压到上文中新建的s1目录(D:\\ProgramFiles\\zk_cluster\\s1),并重命名zookeeper-3.4.6为zookeeper\n\n3. 在s1目录(D:\\ProgramFiles\\zk_cluster\\s1)新建data和dataLog两个目录(下文配置会用到)，最终s1目录结构如图：\n![s1目录结构](http://oaefo3hoy.bkt.clouddn.com/16-8-13/9287916.jpg)\n\n### 配置zoo.cfg文件参数\n\n在目录D:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\conf 有一个zoo_sample.cfg文件，先将其重命名或者复制为zoo.cfg(zookeeper在启动时会找这个文件作为默认配置文件),然后修改zoo.cfg为如下内容([zoo.cfg各个配置参数的含义](#zoo_cfg_table))\n```\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\dataLog\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n```\n除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。\n\n通过上述步骤，我们s1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将s1节点目录下面的所有内容分别复制到s2,s3节点目录下然后做如下调整\n1.  修改s2,s3各自myid文件内容\n    s2\\data\\myid -->2\n    s3\\data\\myid -->3\n2. 修改s2,s3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数\n   s2节点的zoo.cfg修改的内容如下\n  ```\n  dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\data\n  dataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\dataLog\n  clientPort=2182\n  ```\n  s3节点的zoo.cfg修改的内容如下\n  ```\n  dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\data\n  dataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\dataLog\n  clientPort=2183\n  ```\n\n### 启动集群中各个节点\n\n到此为止，我们所有节点配置已经完成，接下来在每个节点目录zookeeper/bin目录都有一个zkServer.cmd脚本，分别双击对应脚本，即可以启动每个节点，所有节点启动后，此时会看到集群节点建立的信息，如下图，从图中我们可以看到集群正常启动，s2为集群的Leader,s1、s3为Flower节点\n![集群节点](http://oaefo3hoy.bkt.clouddn.com/16-8-13/11539405.jpg)\n\n如果觉得每次都要到对应节点下启动各自zkServer.cmd麻烦的话，我们可以做一个bat脚本来批量执行各自节点的zkServer.cmd；如我在D:\\ProgramFiles\\zk_cluster添加了一个zk_cluster_start.bat，内容如下，这样可以快速启动集群节点\n```shell\nstart cmd /c call %~dp0%s1\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s2\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s3\\zookeeper\\bin\\zkServer.cmd\n```\n\n### 测试集群\n\n打开cmd窗口，切换到任意节点目录下zookeeper/bin, 输入zkCli.cmd -server host:port 连接集群任意节点测试，下面是我测试的结果,通过测试结果可以看出我们的集群可以正常工作，集群环境搭建成功\n```\nD:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\bin>zkCli.cmd -server 127.0.0.1:2183\n...省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 1] create  /test1  aaaa\nCreated /test1\n[zk: 127.0.0.1:2183(CONNECTED) 5] connect 127.0.0.1:2181\n...省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] get /test1\naaaa\ncZxid = 0x700000006\nctime = Sat Aug 13 21:44:50 CST 2016\nmZxid = 0x700000006\nmtime = Sat Aug 13 21:44:50 CST 2016\npZxid = 0x700000006\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 4\nnumChildren = 0\n[zk: 127.0.0.1:2181(CONNECTED) 1]\n```\n\nwindows上搭建zookeeper集群环境部署完毕！\n\n## linux下搭建zookeeper集群\n\n由于机器有限，本次教程准备在单台centos6.5虚拟机搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境\n\n### 安装包下载解压\n\n进入shell命令窗口,将安装包下载到/usr/local/src目录，zookeeper版本同样使用[3.4.6版本](http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz)\n\n```bash\n[root@centos ~]# cd /usr/local/src\n[root@centos src]# wget http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\n[root@centos src]# tar -zxvf zookeeper-3.4.6.tar.gz\n[root@centos src]# ll\n总用量 21332\n-rw-r--r--.  1 root root   392756 8月  10 11:31 man-db-2.7.5-3-x86_64.pkg.tar.xz\n-rw-r--r--.  1 root root   909077 8月  10 09:21 nginx-1.10.1.tar.gz\ndrwxrwxr-x.  6 root root     4096 4月   1 2015 redis-3.0.0\n-rw-r--r--.  1 root root  1358081 4月   1 2015 redis-3.0.0.tar.gz\ndrwxr-xr-x. 14 root root     4096 8月  10 11:07 xz-5.2.2\n-rw-r--r--.  1 root root  1464228 8月  10 11:04 xz-5.2.2.tar.gz\ndrwxr-xr-x. 10 1000 1000     4096 8月   8 11:13 zookeeper-3.4.6\n-rw-r--r--.  1 root root 17699306 8月   8 10:54 zookeeper-3.4.6.tar.gz\n```\n\n### 配置安装目录及环境变量\n```\n[root@centos src] ln -s zookeeper-3.4.6  /usr/local/zookeeper\n```\n这里我将zookeeper软连接到/usr/local/zookeeper下面，以后升级zookeeper版本可以不用修改让任何环境变量，直接更改软连接指向就可以完成升级\n\n配置环境变量\nvi 编辑/etc/profile文件，导入ZK_HOME环境变量，路径指向刚才的软连接目录，如下：\n```\n#export env path\nexport JAVA_HOME=/usr/local/java/jdk\nexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport PATH=$PATH:$CLASSPATH\nexport ZK_HOME=/usr/local/zookeeper\nexport PATH=$PATH:$ZK_HOME/bin\nfor i in /etc/profile.d/*.sh ; do\n    if [ -r \"$i\" ]; then\n        if [ \"${-#*i}\" != \"$-\" ]; then\n            . \"$i\"\n        else\n            . \"$i\" >/dev/null 2>&1\n        fi\n    fi\ndone\nunset i\nunset -f pathmunge\n```\n这里注意jdk环境变量和zookeeper环境变量，要配置在第8行的上面，因为下文我们的登录自动启动脚本会放到/etc/profile.d/下，所以要在脚本执行前导入环境变量\n\n### 配置集群节点\n\n创建集群目录\n\n1. 在/usr/local目录创建zookeeper_cluster目录，然后在zookeeper_cluster目录先创建一个集群节点目录server1\n2. 在server1目录创建data,logs目录\n3. 最后将/usr/local/zookeeper/conf/zoo_sample.cfg 拷贝重命名为zoo.cfg到server1目录\n\n操作过程如下\n```\n[root@centos local]# mkdir zookeeper_cluster\n[root@centos local]# cd zookeeper_cluster\n[root@centos zookeeper_cluster]# mkdir server1\n[root@centos zookeeper_cluster]# cd server1\n[root@centos server1]# mkdir data logs\n[root@centos server1]# cp /usr/local/zookeeper/conf/zoo_sample.cfg zoo.cfg\n```\n\n配置zoo.cfg文件参数\n\n修改server1节点目录下zoo.cfg文件的内容([zoo.cfg各个配置参数的含义](#zoo_cfg_table))\n```\n[root@centos server1]# vi zoo.cfg\n```\n内容修改如下\n```\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/usr/local/zookeeper_cluster/server1/data\ndataLogDir=/usr/local/zookeeper_cluster/server1/logs\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n```\n\n创建myid文件\n\n除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。\n```\n[root@centos server1]# echo 1 > data/myid\n```\n\n配置另外两个节点\n\n通过上述步骤，我们server1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将server1节点目录复制为server2,server3\n```\n[root@centos zookeeper_cluster] cp -rf server1  server2\n[root@centos zookeeper_cluster] cp -rf server1  server3\n\n```\n1.  修改server2,server3各自myid文件内容\n    ```\n    [root@centos zookeeper_cluster] echo 2 > server2/myid\n    [root@centos zookeeper_cluster] echo 3 > server3/myid\n    ```\n2. 修改server2,server3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数\n  server2节点zoo.cfg修改内容如下\n  ```\n  dataDir=/usr/local/zookeeper_cluster/server2/data\n  dataLogDir=/usr/local/zookeeper_cluster/server2/logs\n  clientPort=2182\n  ```\n  server3节点zoo.cfg修改内容如下\n  ```\n  dataDir=/usr/local/zookeeper_cluster/server3/data\n  dataLogDir=/usr/local/zookeeper_cluster/server3/logs\n  clientPort=2183\n  ```\n\n### 启动集群\n\n这里我们先在/etc/profile.d/ 创建一个集群启动的脚本zk_cluster_strat.sh，脚本内容如下：\n\n ```\n #!/bin/bash\n #description:auto start zookeeper cluster nodes when user login\n zkServer.sh start  /usr/local/zookeeper_cluster/server1/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server2/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server3/zoo.cfg\n ```\n 脚本创建好之后，我们来手动执行下此脚本\n ```\n[root@centos ~]# .  /etc/profile.d/zk_cluster_start.sh\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server1/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server2/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server3/zoo.cfg\nStarting zookeeper ... STARTED\n```\n\n### 测试集群\n接着我们用zkCli.sh测试每个节点连接\n```\n[root@centos ~]# zkCli.sh -server 127.0.0.1:2181\n省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] create /test  hello,world! #创建一个节点目录\nCreated /test\n[zk: 127.0.0.1:2181(CONNECTED) 0] connect 127.0.0.1:2182\n省略连接内容...\n[zk: 127.0.0.1:2182(CONNECTED) 4] get /test  #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n127.0.0.1:2181\n[zk: 127.0.0.1:2182(CONNECTED) 5] connect 127.0.0.1:2183\n省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 2] get /test #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n```\n\nlinux上搭建zookeeper集群环境部署完毕！\n\n<hr/>\n\n## <span id='zoo_cfg_table'>zoo.cfg各个配置参数的含义</span>\n\n|配置参数|含义|\n|:----:|:-----|\n|**tickTime**|这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。\n|**initLimit**|这个配置项是用来配置Zookeeper接受客户端（这里所说的客户端不是用户连接Zookeeper服务器的客户端，而是Zookeeper服务器集群中连接到Leader的Follower服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是tickTime）长度后Zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是5\\*2000=10秒\n|**syncLimit**|这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就2\\*2000=4 秒\n|**dataDir**|顾名思义就是Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。\n|**dataLogDir**|顾名思义就是Zookeeper记录数据变化的日志目录，如果不配置，默认日志文件会保存到dataDir数据目录中。\n|**clientPort**|这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。\n|**autopurge.snapRetainCount**|指定了需要保留的快照文件数目。默认是保留3个，需要和autopurge.purgeInterval搭配使用。\n|**autopurge.purgeInterval**|指定了自动清理快照和事务日志的频率，单位是小时，需要填写一个1或更大的整数，默认是0，表示不开启自己清理功能\n|**server.A=B：C：D**|其中A是一个数字，表示这个是第几号服务器；B是这个服务器的ip地址；C表示的是这个服务器与集群中的Leader服务器交换信息的端口；D 表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于B都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。\n\n\n## 参考资料\n\n1. [ZooKeeper 基础知识、部署和应用程序](http://www.ibm.com/developerworks/cn/data/library/bd-zookeeper/)\n2. [分布式服务框架 Zookeeper -- 管理分布式环境中的数据](https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/)\n","source":"_posts/zookeeper-install-deploy.md","raw":"---\ntitle: 在windows,linux下搭建zookeeper集群环境\ndate: 2016-08-13 17:56:29\ncategories: ['安装部署']\ntags: ['zookeeper','教程','环境搭建']\n---\n## Zookeeper简介\n\nZookeeper是一个分布式服务框架，它是 Apache Hadoop 的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。本文将介绍Zookeeper如何在windows和linux下的进行集群部署，以便为我们使用zookeeper的相关功能做好环境支持\n\n<!--more-->\n\n## 安装前提\n\nzookeeper本身要依赖java jdk环境，在搭建前需要确认你的系统安装了java jdk，并配置好了jdk环境变量\n\n## win下搭建zookeeper集群\n\n由于机器有限，本次教程准备在单台机器搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境\n\n### 安装包下载\n\n访问[https://zookeeper.apache.org/](https://zookeeper.apache.org/ 'zookeeper官网')找到并下载我们需要安装的版本，这里我选择下载[zookeeper 3.4.6版本](http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz)(注：zookeeper安装包不区分操作系统平台)\n\n### 安装包解压，集群节点建立\n\n1. 创建集群目录如`D:\\ProgramFiles\\zk_cluster`,并在集群目录下创建三个目录s1,s2,s3，代表三个zookeeper集群节点，如图:\n![三个zookeeper节点目录](http://oaefo3hoy.bkt.clouddn.com/16-8-13/78596671.jpg)\n\n2. 将下载的安装包解压到指定zookeeper节点目录，本教程我先解压到上文中新建的s1目录(D:\\ProgramFiles\\zk_cluster\\s1),并重命名zookeeper-3.4.6为zookeeper\n\n3. 在s1目录(D:\\ProgramFiles\\zk_cluster\\s1)新建data和dataLog两个目录(下文配置会用到)，最终s1目录结构如图：\n![s1目录结构](http://oaefo3hoy.bkt.clouddn.com/16-8-13/9287916.jpg)\n\n### 配置zoo.cfg文件参数\n\n在目录D:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\conf 有一个zoo_sample.cfg文件，先将其重命名或者复制为zoo.cfg(zookeeper在启动时会找这个文件作为默认配置文件),然后修改zoo.cfg为如下内容([zoo.cfg各个配置参数的含义](#zoo_cfg_table))\n```\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\dataLog\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n```\n除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。\n\n通过上述步骤，我们s1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将s1节点目录下面的所有内容分别复制到s2,s3节点目录下然后做如下调整\n1.  修改s2,s3各自myid文件内容\n    s2\\data\\myid -->2\n    s3\\data\\myid -->3\n2. 修改s2,s3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数\n   s2节点的zoo.cfg修改的内容如下\n  ```\n  dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\data\n  dataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\dataLog\n  clientPort=2182\n  ```\n  s3节点的zoo.cfg修改的内容如下\n  ```\n  dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\data\n  dataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\dataLog\n  clientPort=2183\n  ```\n\n### 启动集群中各个节点\n\n到此为止，我们所有节点配置已经完成，接下来在每个节点目录zookeeper/bin目录都有一个zkServer.cmd脚本，分别双击对应脚本，即可以启动每个节点，所有节点启动后，此时会看到集群节点建立的信息，如下图，从图中我们可以看到集群正常启动，s2为集群的Leader,s1、s3为Flower节点\n![集群节点](http://oaefo3hoy.bkt.clouddn.com/16-8-13/11539405.jpg)\n\n如果觉得每次都要到对应节点下启动各自zkServer.cmd麻烦的话，我们可以做一个bat脚本来批量执行各自节点的zkServer.cmd；如我在D:\\ProgramFiles\\zk_cluster添加了一个zk_cluster_start.bat，内容如下，这样可以快速启动集群节点\n```shell\nstart cmd /c call %~dp0%s1\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s2\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s3\\zookeeper\\bin\\zkServer.cmd\n```\n\n### 测试集群\n\n打开cmd窗口，切换到任意节点目录下zookeeper/bin, 输入zkCli.cmd -server host:port 连接集群任意节点测试，下面是我测试的结果,通过测试结果可以看出我们的集群可以正常工作，集群环境搭建成功\n```\nD:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\bin>zkCli.cmd -server 127.0.0.1:2183\n...省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 1] create  /test1  aaaa\nCreated /test1\n[zk: 127.0.0.1:2183(CONNECTED) 5] connect 127.0.0.1:2181\n...省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] get /test1\naaaa\ncZxid = 0x700000006\nctime = Sat Aug 13 21:44:50 CST 2016\nmZxid = 0x700000006\nmtime = Sat Aug 13 21:44:50 CST 2016\npZxid = 0x700000006\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 4\nnumChildren = 0\n[zk: 127.0.0.1:2181(CONNECTED) 1]\n```\n\nwindows上搭建zookeeper集群环境部署完毕！\n\n## linux下搭建zookeeper集群\n\n由于机器有限，本次教程准备在单台centos6.5虚拟机搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境\n\n### 安装包下载解压\n\n进入shell命令窗口,将安装包下载到/usr/local/src目录，zookeeper版本同样使用[3.4.6版本](http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz)\n\n```bash\n[root@centos ~]# cd /usr/local/src\n[root@centos src]# wget http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\n[root@centos src]# tar -zxvf zookeeper-3.4.6.tar.gz\n[root@centos src]# ll\n总用量 21332\n-rw-r--r--.  1 root root   392756 8月  10 11:31 man-db-2.7.5-3-x86_64.pkg.tar.xz\n-rw-r--r--.  1 root root   909077 8月  10 09:21 nginx-1.10.1.tar.gz\ndrwxrwxr-x.  6 root root     4096 4月   1 2015 redis-3.0.0\n-rw-r--r--.  1 root root  1358081 4月   1 2015 redis-3.0.0.tar.gz\ndrwxr-xr-x. 14 root root     4096 8月  10 11:07 xz-5.2.2\n-rw-r--r--.  1 root root  1464228 8月  10 11:04 xz-5.2.2.tar.gz\ndrwxr-xr-x. 10 1000 1000     4096 8月   8 11:13 zookeeper-3.4.6\n-rw-r--r--.  1 root root 17699306 8月   8 10:54 zookeeper-3.4.6.tar.gz\n```\n\n### 配置安装目录及环境变量\n```\n[root@centos src] ln -s zookeeper-3.4.6  /usr/local/zookeeper\n```\n这里我将zookeeper软连接到/usr/local/zookeeper下面，以后升级zookeeper版本可以不用修改让任何环境变量，直接更改软连接指向就可以完成升级\n\n配置环境变量\nvi 编辑/etc/profile文件，导入ZK_HOME环境变量，路径指向刚才的软连接目录，如下：\n```\n#export env path\nexport JAVA_HOME=/usr/local/java/jdk\nexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport PATH=$PATH:$CLASSPATH\nexport ZK_HOME=/usr/local/zookeeper\nexport PATH=$PATH:$ZK_HOME/bin\nfor i in /etc/profile.d/*.sh ; do\n    if [ -r \"$i\" ]; then\n        if [ \"${-#*i}\" != \"$-\" ]; then\n            . \"$i\"\n        else\n            . \"$i\" >/dev/null 2>&1\n        fi\n    fi\ndone\nunset i\nunset -f pathmunge\n```\n这里注意jdk环境变量和zookeeper环境变量，要配置在第8行的上面，因为下文我们的登录自动启动脚本会放到/etc/profile.d/下，所以要在脚本执行前导入环境变量\n\n### 配置集群节点\n\n创建集群目录\n\n1. 在/usr/local目录创建zookeeper_cluster目录，然后在zookeeper_cluster目录先创建一个集群节点目录server1\n2. 在server1目录创建data,logs目录\n3. 最后将/usr/local/zookeeper/conf/zoo_sample.cfg 拷贝重命名为zoo.cfg到server1目录\n\n操作过程如下\n```\n[root@centos local]# mkdir zookeeper_cluster\n[root@centos local]# cd zookeeper_cluster\n[root@centos zookeeper_cluster]# mkdir server1\n[root@centos zookeeper_cluster]# cd server1\n[root@centos server1]# mkdir data logs\n[root@centos server1]# cp /usr/local/zookeeper/conf/zoo_sample.cfg zoo.cfg\n```\n\n配置zoo.cfg文件参数\n\n修改server1节点目录下zoo.cfg文件的内容([zoo.cfg各个配置参数的含义](#zoo_cfg_table))\n```\n[root@centos server1]# vi zoo.cfg\n```\n内容修改如下\n```\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/usr/local/zookeeper_cluster/server1/data\ndataLogDir=/usr/local/zookeeper_cluster/server1/logs\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n```\n\n创建myid文件\n\n除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。\n```\n[root@centos server1]# echo 1 > data/myid\n```\n\n配置另外两个节点\n\n通过上述步骤，我们server1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将server1节点目录复制为server2,server3\n```\n[root@centos zookeeper_cluster] cp -rf server1  server2\n[root@centos zookeeper_cluster] cp -rf server1  server3\n\n```\n1.  修改server2,server3各自myid文件内容\n    ```\n    [root@centos zookeeper_cluster] echo 2 > server2/myid\n    [root@centos zookeeper_cluster] echo 3 > server3/myid\n    ```\n2. 修改server2,server3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数\n  server2节点zoo.cfg修改内容如下\n  ```\n  dataDir=/usr/local/zookeeper_cluster/server2/data\n  dataLogDir=/usr/local/zookeeper_cluster/server2/logs\n  clientPort=2182\n  ```\n  server3节点zoo.cfg修改内容如下\n  ```\n  dataDir=/usr/local/zookeeper_cluster/server3/data\n  dataLogDir=/usr/local/zookeeper_cluster/server3/logs\n  clientPort=2183\n  ```\n\n### 启动集群\n\n这里我们先在/etc/profile.d/ 创建一个集群启动的脚本zk_cluster_strat.sh，脚本内容如下：\n\n ```\n #!/bin/bash\n #description:auto start zookeeper cluster nodes when user login\n zkServer.sh start  /usr/local/zookeeper_cluster/server1/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server2/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server3/zoo.cfg\n ```\n 脚本创建好之后，我们来手动执行下此脚本\n ```\n[root@centos ~]# .  /etc/profile.d/zk_cluster_start.sh\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server1/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server2/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server3/zoo.cfg\nStarting zookeeper ... STARTED\n```\n\n### 测试集群\n接着我们用zkCli.sh测试每个节点连接\n```\n[root@centos ~]# zkCli.sh -server 127.0.0.1:2181\n省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] create /test  hello,world! #创建一个节点目录\nCreated /test\n[zk: 127.0.0.1:2181(CONNECTED) 0] connect 127.0.0.1:2182\n省略连接内容...\n[zk: 127.0.0.1:2182(CONNECTED) 4] get /test  #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n127.0.0.1:2181\n[zk: 127.0.0.1:2182(CONNECTED) 5] connect 127.0.0.1:2183\n省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 2] get /test #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n```\n\nlinux上搭建zookeeper集群环境部署完毕！\n\n<hr/>\n\n## <span id='zoo_cfg_table'>zoo.cfg各个配置参数的含义</span>\n\n|配置参数|含义|\n|:----:|:-----|\n|**tickTime**|这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。\n|**initLimit**|这个配置项是用来配置Zookeeper接受客户端（这里所说的客户端不是用户连接Zookeeper服务器的客户端，而是Zookeeper服务器集群中连接到Leader的Follower服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是tickTime）长度后Zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是5\\*2000=10秒\n|**syncLimit**|这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就2\\*2000=4 秒\n|**dataDir**|顾名思义就是Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。\n|**dataLogDir**|顾名思义就是Zookeeper记录数据变化的日志目录，如果不配置，默认日志文件会保存到dataDir数据目录中。\n|**clientPort**|这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。\n|**autopurge.snapRetainCount**|指定了需要保留的快照文件数目。默认是保留3个，需要和autopurge.purgeInterval搭配使用。\n|**autopurge.purgeInterval**|指定了自动清理快照和事务日志的频率，单位是小时，需要填写一个1或更大的整数，默认是0，表示不开启自己清理功能\n|**server.A=B：C：D**|其中A是一个数字，表示这个是第几号服务器；B是这个服务器的ip地址；C表示的是这个服务器与集群中的Leader服务器交换信息的端口；D 表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于B都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。\n\n\n## 参考资料\n\n1. [ZooKeeper 基础知识、部署和应用程序](http://www.ibm.com/developerworks/cn/data/library/bd-zookeeper/)\n2. [分布式服务框架 Zookeeper -- 管理分布式环境中的数据](https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/)\n","slug":"zookeeper-install-deploy","published":1,"updated":"2017-02-18T09:31:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj35obswg0020qk5coz4cvnp5","content":"<h2 id=\"Zookeeper简介\"><a href=\"#Zookeeper简介\" class=\"headerlink\" title=\"Zookeeper简介\"></a>Zookeeper简介</h2><p>Zookeeper是一个分布式服务框架，它是 Apache Hadoop 的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。本文将介绍Zookeeper如何在windows和linux下的进行集群部署，以便为我们使用zookeeper的相关功能做好环境支持</p>\n<a id=\"more\"></a>\n<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>zookeeper本身要依赖java jdk环境，在搭建前需要确认你的系统安装了java jdk，并配置好了jdk环境变量</p>\n<h2 id=\"win下搭建zookeeper集群\"><a href=\"#win下搭建zookeeper集群\" class=\"headerlink\" title=\"win下搭建zookeeper集群\"></a>win下搭建zookeeper集群</h2><p>由于机器有限，本次教程准备在单台机器搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境</p>\n<h3 id=\"安装包下载\"><a href=\"#安装包下载\" class=\"headerlink\" title=\"安装包下载\"></a>安装包下载</h3><p>访问<a href=\"https://zookeeper.apache.org/\" title=\"zookeeper官网\" target=\"_blank\" rel=\"external\">https://zookeeper.apache.org/</a>找到并下载我们需要安装的版本，这里我选择下载<a href=\"http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\" target=\"_blank\" rel=\"external\">zookeeper 3.4.6版本</a>(注：zookeeper安装包不区分操作系统平台)</p>\n<h3 id=\"安装包解压，集群节点建立\"><a href=\"#安装包解压，集群节点建立\" class=\"headerlink\" title=\"安装包解压，集群节点建立\"></a>安装包解压，集群节点建立</h3><ol>\n<li><p>创建集群目录如<code>D:\\ProgramFiles\\zk_cluster</code>,并在集群目录下创建三个目录s1,s2,s3，代表三个zookeeper集群节点，如图:<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-13/78596671.jpg\" alt=\"三个zookeeper节点目录\"></p>\n</li>\n<li><p>将下载的安装包解压到指定zookeeper节点目录，本教程我先解压到上文中新建的s1目录(D:\\ProgramFiles\\zk_cluster\\s1),并重命名zookeeper-3.4.6为zookeeper</p>\n</li>\n<li><p>在s1目录(D:\\ProgramFiles\\zk_cluster\\s1)新建data和dataLog两个目录(下文配置会用到)，最终s1目录结构如图：<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-13/9287916.jpg\" alt=\"s1目录结构\"></p>\n</li>\n</ol>\n<h3 id=\"配置zoo-cfg文件参数\"><a href=\"#配置zoo-cfg文件参数\" class=\"headerlink\" title=\"配置zoo.cfg文件参数\"></a>配置zoo.cfg文件参数</h3><p>在目录D:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\conf 有一个zoo_sample.cfg文件，先将其重命名或者复制为zoo.cfg(zookeeper在启动时会找这个文件作为默认配置文件),然后修改zoo.cfg为如下内容(<a href=\"#zoo_cfg_table\">zoo.cfg各个配置参数的含义</a>)</p>\n<pre><code>tickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\dataLog\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n</code></pre><p>除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。</p>\n<p>通过上述步骤，我们s1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将s1节点目录下面的所有内容分别复制到s2,s3节点目录下然后做如下调整</p>\n<ol>\n<li>修改s2,s3各自myid文件内容<br>s2\\data\\myid –&gt;2<br>s3\\data\\myid –&gt;3</li>\n<li>修改s2,s3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数<br>s2节点的zoo.cfg修改的内容如下<pre><code>dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\dataLog\nclientPort=2182\n</code></pre>s3节点的zoo.cfg修改的内容如下<pre><code>dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\dataLog\nclientPort=2183\n</code></pre></li>\n</ol>\n<h3 id=\"启动集群中各个节点\"><a href=\"#启动集群中各个节点\" class=\"headerlink\" title=\"启动集群中各个节点\"></a>启动集群中各个节点</h3><p>到此为止，我们所有节点配置已经完成，接下来在每个节点目录zookeeper/bin目录都有一个zkServer.cmd脚本，分别双击对应脚本，即可以启动每个节点，所有节点启动后，此时会看到集群节点建立的信息，如下图，从图中我们可以看到集群正常启动，s2为集群的Leader,s1、s3为Flower节点<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-13/11539405.jpg\" alt=\"集群节点\"></p>\n<p>如果觉得每次都要到对应节点下启动各自zkServer.cmd麻烦的话，我们可以做一个bat脚本来批量执行各自节点的zkServer.cmd；如我在D:\\ProgramFiles\\zk_cluster添加了一个zk_cluster_start.bat，内容如下，这样可以快速启动集群节点</p>\n<pre><code class=\"shell\">start cmd /c call %~dp0%s1\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s2\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s3\\zookeeper\\bin\\zkServer.cmd\n</code></pre>\n<h3 id=\"测试集群\"><a href=\"#测试集群\" class=\"headerlink\" title=\"测试集群\"></a>测试集群</h3><p>打开cmd窗口，切换到任意节点目录下zookeeper/bin, 输入zkCli.cmd -server host:port 连接集群任意节点测试，下面是我测试的结果,通过测试结果可以看出我们的集群可以正常工作，集群环境搭建成功</p>\n<pre><code>D:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\bin&gt;zkCli.cmd -server 127.0.0.1:2183\n...省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 1] create  /test1  aaaa\nCreated /test1\n[zk: 127.0.0.1:2183(CONNECTED) 5] connect 127.0.0.1:2181\n...省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] get /test1\naaaa\ncZxid = 0x700000006\nctime = Sat Aug 13 21:44:50 CST 2016\nmZxid = 0x700000006\nmtime = Sat Aug 13 21:44:50 CST 2016\npZxid = 0x700000006\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 4\nnumChildren = 0\n[zk: 127.0.0.1:2181(CONNECTED) 1]\n</code></pre><p>windows上搭建zookeeper集群环境部署完毕！</p>\n<h2 id=\"linux下搭建zookeeper集群\"><a href=\"#linux下搭建zookeeper集群\" class=\"headerlink\" title=\"linux下搭建zookeeper集群\"></a>linux下搭建zookeeper集群</h2><p>由于机器有限，本次教程准备在单台centos6.5虚拟机搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境</p>\n<h3 id=\"安装包下载解压\"><a href=\"#安装包下载解压\" class=\"headerlink\" title=\"安装包下载解压\"></a>安装包下载解压</h3><p>进入shell命令窗口,将安装包下载到/usr/local/src目录，zookeeper版本同样使用<a href=\"http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\" target=\"_blank\" rel=\"external\">3.4.6版本</a></p>\n<pre><code class=\"bash\">[root@centos ~]# cd /usr/local/src\n[root@centos src]# wget http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\n[root@centos src]# tar -zxvf zookeeper-3.4.6.tar.gz\n[root@centos src]# ll\n总用量 21332\n-rw-r--r--.  1 root root   392756 8月  10 11:31 man-db-2.7.5-3-x86_64.pkg.tar.xz\n-rw-r--r--.  1 root root   909077 8月  10 09:21 nginx-1.10.1.tar.gz\ndrwxrwxr-x.  6 root root     4096 4月   1 2015 redis-3.0.0\n-rw-r--r--.  1 root root  1358081 4月   1 2015 redis-3.0.0.tar.gz\ndrwxr-xr-x. 14 root root     4096 8月  10 11:07 xz-5.2.2\n-rw-r--r--.  1 root root  1464228 8月  10 11:04 xz-5.2.2.tar.gz\ndrwxr-xr-x. 10 1000 1000     4096 8月   8 11:13 zookeeper-3.4.6\n-rw-r--r--.  1 root root 17699306 8月   8 10:54 zookeeper-3.4.6.tar.gz\n</code></pre>\n<h3 id=\"配置安装目录及环境变量\"><a href=\"#配置安装目录及环境变量\" class=\"headerlink\" title=\"配置安装目录及环境变量\"></a>配置安装目录及环境变量</h3><pre><code>[root@centos src] ln -s zookeeper-3.4.6  /usr/local/zookeeper\n</code></pre><p>这里我将zookeeper软连接到/usr/local/zookeeper下面，以后升级zookeeper版本可以不用修改让任何环境变量，直接更改软连接指向就可以完成升级</p>\n<p>配置环境变量<br>vi 编辑/etc/profile文件，导入ZK_HOME环境变量，路径指向刚才的软连接目录，如下：</p>\n<pre><code>#export env path\nexport JAVA_HOME=/usr/local/java/jdk\nexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport PATH=$PATH:$CLASSPATH\nexport ZK_HOME=/usr/local/zookeeper\nexport PATH=$PATH:$ZK_HOME/bin\nfor i in /etc/profile.d/*.sh ; do\n    if [ -r &quot;$i&quot; ]; then\n        if [ &quot;${-#*i}&quot; != &quot;$-&quot; ]; then\n            . &quot;$i&quot;\n        else\n            . &quot;$i&quot; &gt;/dev/null 2&gt;&amp;1\n        fi\n    fi\ndone\nunset i\nunset -f pathmunge\n</code></pre><p>这里注意jdk环境变量和zookeeper环境变量，要配置在第8行的上面，因为下文我们的登录自动启动脚本会放到/etc/profile.d/下，所以要在脚本执行前导入环境变量</p>\n<h3 id=\"配置集群节点\"><a href=\"#配置集群节点\" class=\"headerlink\" title=\"配置集群节点\"></a>配置集群节点</h3><p>创建集群目录</p>\n<ol>\n<li>在/usr/local目录创建zookeeper_cluster目录，然后在zookeeper_cluster目录先创建一个集群节点目录server1</li>\n<li>在server1目录创建data,logs目录</li>\n<li>最后将/usr/local/zookeeper/conf/zoo_sample.cfg 拷贝重命名为zoo.cfg到server1目录</li>\n</ol>\n<p>操作过程如下</p>\n<pre><code>[root@centos local]# mkdir zookeeper_cluster\n[root@centos local]# cd zookeeper_cluster\n[root@centos zookeeper_cluster]# mkdir server1\n[root@centos zookeeper_cluster]# cd server1\n[root@centos server1]# mkdir data logs\n[root@centos server1]# cp /usr/local/zookeeper/conf/zoo_sample.cfg zoo.cfg\n</code></pre><p>配置zoo.cfg文件参数</p>\n<p>修改server1节点目录下zoo.cfg文件的内容(<a href=\"#zoo_cfg_table\">zoo.cfg各个配置参数的含义</a>)</p>\n<pre><code>[root@centos server1]# vi zoo.cfg\n</code></pre><p>内容修改如下</p>\n<pre><code>tickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/usr/local/zookeeper_cluster/server1/data\ndataLogDir=/usr/local/zookeeper_cluster/server1/logs\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n</code></pre><p>创建myid文件</p>\n<p>除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。</p>\n<pre><code>[root@centos server1]# echo 1 &gt; data/myid\n</code></pre><p>配置另外两个节点</p>\n<p>通过上述步骤，我们server1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将server1节点目录复制为server2,server3</p>\n<pre><code>[root@centos zookeeper_cluster] cp -rf server1  server2\n[root@centos zookeeper_cluster] cp -rf server1  server3\n</code></pre><ol>\n<li>修改server2,server3各自myid文件内容<pre><code>[root@centos zookeeper_cluster] echo 2 &gt; server2/myid\n[root@centos zookeeper_cluster] echo 3 &gt; server3/myid\n</code></pre></li>\n<li>修改server2,server3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数<br>server2节点zoo.cfg修改内容如下<pre><code>dataDir=/usr/local/zookeeper_cluster/server2/data\ndataLogDir=/usr/local/zookeeper_cluster/server2/logs\nclientPort=2182\n</code></pre>server3节点zoo.cfg修改内容如下<pre><code>dataDir=/usr/local/zookeeper_cluster/server3/data\ndataLogDir=/usr/local/zookeeper_cluster/server3/logs\nclientPort=2183\n</code></pre></li>\n</ol>\n<h3 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h3><p>这里我们先在/etc/profile.d/ 创建一个集群启动的脚本zk_cluster_strat.sh，脚本内容如下：</p>\n<pre><code> #!/bin/bash\n #description:auto start zookeeper cluster nodes when user login\n zkServer.sh start  /usr/local/zookeeper_cluster/server1/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server2/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server3/zoo.cfg\n</code></pre><p> 脚本创建好之后，我们来手动执行下此脚本</p>\n<pre><code>[root@centos ~]# .  /etc/profile.d/zk_cluster_start.sh\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server1/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server2/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server3/zoo.cfg\nStarting zookeeper ... STARTED\n</code></pre><h3 id=\"测试集群-1\"><a href=\"#测试集群-1\" class=\"headerlink\" title=\"测试集群\"></a>测试集群</h3><p>接着我们用zkCli.sh测试每个节点连接</p>\n<pre><code>[root@centos ~]# zkCli.sh -server 127.0.0.1:2181\n省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] create /test  hello,world! #创建一个节点目录\nCreated /test\n[zk: 127.0.0.1:2181(CONNECTED) 0] connect 127.0.0.1:2182\n省略连接内容...\n[zk: 127.0.0.1:2182(CONNECTED) 4] get /test  #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n127.0.0.1:2181\n[zk: 127.0.0.1:2182(CONNECTED) 5] connect 127.0.0.1:2183\n省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 2] get /test #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n</code></pre><p>linux上搭建zookeeper集群环境部署完毕！</p>\n<hr>\n\n<h2 id=\"zoo-cfg各个配置参数的含义\"><a href=\"#zoo-cfg各个配置参数的含义\" class=\"headerlink\" title=\"zoo.cfg各个配置参数的含义\"></a><span id=\"zoo_cfg_table\">zoo.cfg各个配置参数的含义</span></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">配置参数</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>tickTime</strong></td>\n<td style=\"text-align:left\">这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>initLimit</strong></td>\n<td style=\"text-align:left\">这个配置项是用来配置Zookeeper接受客户端（这里所说的客户端不是用户连接Zookeeper服务器的客户端，而是Zookeeper服务器集群中连接到Leader的Follower服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是tickTime）长度后Zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是5*2000=10秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>syncLimit</strong></td>\n<td style=\"text-align:left\">这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就2*2000=4 秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>dataDir</strong></td>\n<td style=\"text-align:left\">顾名思义就是Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>dataLogDir</strong></td>\n<td style=\"text-align:left\">顾名思义就是Zookeeper记录数据变化的日志目录，如果不配置，默认日志文件会保存到dataDir数据目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>clientPort</strong></td>\n<td style=\"text-align:left\">这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>autopurge.snapRetainCount</strong></td>\n<td style=\"text-align:left\">指定了需要保留的快照文件数目。默认是保留3个，需要和autopurge.purgeInterval搭配使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>autopurge.purgeInterval</strong></td>\n<td style=\"text-align:left\">指定了自动清理快照和事务日志的频率，单位是小时，需要填写一个1或更大的整数，默认是0，表示不开启自己清理功能</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>server.A=B：C：D</strong></td>\n<td style=\"text-align:left\">其中A是一个数字，表示这个是第几号服务器；B是这个服务器的ip地址；C表示的是这个服务器与集群中的Leader服务器交换信息的端口；D 表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于B都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://www.ibm.com/developerworks/cn/data/library/bd-zookeeper/\" target=\"_blank\" rel=\"external\">ZooKeeper 基础知识、部署和应用程序</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\" target=\"_blank\" rel=\"external\">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></li>\n</ol>\n","excerpt":"<h2 id=\"Zookeeper简介\"><a href=\"#Zookeeper简介\" class=\"headerlink\" title=\"Zookeeper简介\"></a>Zookeeper简介</h2><p>Zookeeper是一个分布式服务框架，它是 Apache Hadoop 的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。本文将介绍Zookeeper如何在windows和linux下的进行集群部署，以便为我们使用zookeeper的相关功能做好环境支持</p>","more":"<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>zookeeper本身要依赖java jdk环境，在搭建前需要确认你的系统安装了java jdk，并配置好了jdk环境变量</p>\n<h2 id=\"win下搭建zookeeper集群\"><a href=\"#win下搭建zookeeper集群\" class=\"headerlink\" title=\"win下搭建zookeeper集群\"></a>win下搭建zookeeper集群</h2><p>由于机器有限，本次教程准备在单台机器搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境</p>\n<h3 id=\"安装包下载\"><a href=\"#安装包下载\" class=\"headerlink\" title=\"安装包下载\"></a>安装包下载</h3><p>访问<a href=\"https://zookeeper.apache.org/\" title=\"zookeeper官网\">https://zookeeper.apache.org/</a>找到并下载我们需要安装的版本，这里我选择下载<a href=\"http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\">zookeeper 3.4.6版本</a>(注：zookeeper安装包不区分操作系统平台)</p>\n<h3 id=\"安装包解压，集群节点建立\"><a href=\"#安装包解压，集群节点建立\" class=\"headerlink\" title=\"安装包解压，集群节点建立\"></a>安装包解压，集群节点建立</h3><ol>\n<li><p>创建集群目录如<code>D:\\ProgramFiles\\zk_cluster</code>,并在集群目录下创建三个目录s1,s2,s3，代表三个zookeeper集群节点，如图:<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-13/78596671.jpg\" alt=\"三个zookeeper节点目录\"></p>\n</li>\n<li><p>将下载的安装包解压到指定zookeeper节点目录，本教程我先解压到上文中新建的s1目录(D:\\ProgramFiles\\zk_cluster\\s1),并重命名zookeeper-3.4.6为zookeeper</p>\n</li>\n<li><p>在s1目录(D:\\ProgramFiles\\zk_cluster\\s1)新建data和dataLog两个目录(下文配置会用到)，最终s1目录结构如图：<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-13/9287916.jpg\" alt=\"s1目录结构\"></p>\n</li>\n</ol>\n<h3 id=\"配置zoo-cfg文件参数\"><a href=\"#配置zoo-cfg文件参数\" class=\"headerlink\" title=\"配置zoo.cfg文件参数\"></a>配置zoo.cfg文件参数</h3><p>在目录D:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\conf 有一个zoo_sample.cfg文件，先将其重命名或者复制为zoo.cfg(zookeeper在启动时会找这个文件作为默认配置文件),然后修改zoo.cfg为如下内容(<a href=\"#zoo_cfg_table\">zoo.cfg各个配置参数的含义</a>)</p>\n<pre><code>tickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s1\\\\dataLog\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n</code></pre><p>除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。</p>\n<p>通过上述步骤，我们s1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将s1节点目录下面的所有内容分别复制到s2,s3节点目录下然后做如下调整</p>\n<ol>\n<li>修改s2,s3各自myid文件内容<br>s2\\data\\myid –&gt;2<br>s3\\data\\myid –&gt;3</li>\n<li>修改s2,s3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数<br>s2节点的zoo.cfg修改的内容如下<pre><code>dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s2\\\\dataLog\nclientPort=2182\n</code></pre>s3节点的zoo.cfg修改的内容如下<pre><code>dataDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\data\ndataLogDir=D:\\\\ProgramFiles\\\\zk_cluster\\\\s3\\\\dataLog\nclientPort=2183\n</code></pre></li>\n</ol>\n<h3 id=\"启动集群中各个节点\"><a href=\"#启动集群中各个节点\" class=\"headerlink\" title=\"启动集群中各个节点\"></a>启动集群中各个节点</h3><p>到此为止，我们所有节点配置已经完成，接下来在每个节点目录zookeeper/bin目录都有一个zkServer.cmd脚本，分别双击对应脚本，即可以启动每个节点，所有节点启动后，此时会看到集群节点建立的信息，如下图，从图中我们可以看到集群正常启动，s2为集群的Leader,s1、s3为Flower节点<br><img src=\"http://oaefo3hoy.bkt.clouddn.com/16-8-13/11539405.jpg\" alt=\"集群节点\"></p>\n<p>如果觉得每次都要到对应节点下启动各自zkServer.cmd麻烦的话，我们可以做一个bat脚本来批量执行各自节点的zkServer.cmd；如我在D:\\ProgramFiles\\zk_cluster添加了一个zk_cluster_start.bat，内容如下，这样可以快速启动集群节点</p>\n<pre><code class=\"shell\">start cmd /c call %~dp0%s1\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s2\\zookeeper\\bin\\zkServer.cmd\nstart cmd /c call %~dp0%s3\\zookeeper\\bin\\zkServer.cmd\n</code></pre>\n<h3 id=\"测试集群\"><a href=\"#测试集群\" class=\"headerlink\" title=\"测试集群\"></a>测试集群</h3><p>打开cmd窗口，切换到任意节点目录下zookeeper/bin, 输入zkCli.cmd -server host:port 连接集群任意节点测试，下面是我测试的结果,通过测试结果可以看出我们的集群可以正常工作，集群环境搭建成功</p>\n<pre><code>D:\\ProgramFiles\\zk_cluster\\s1\\zookeeper\\bin&gt;zkCli.cmd -server 127.0.0.1:2183\n...省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 1] create  /test1  aaaa\nCreated /test1\n[zk: 127.0.0.1:2183(CONNECTED) 5] connect 127.0.0.1:2181\n...省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] get /test1\naaaa\ncZxid = 0x700000006\nctime = Sat Aug 13 21:44:50 CST 2016\nmZxid = 0x700000006\nmtime = Sat Aug 13 21:44:50 CST 2016\npZxid = 0x700000006\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 4\nnumChildren = 0\n[zk: 127.0.0.1:2181(CONNECTED) 1]\n</code></pre><p>windows上搭建zookeeper集群环境部署完毕！</p>\n<h2 id=\"linux下搭建zookeeper集群\"><a href=\"#linux下搭建zookeeper集群\" class=\"headerlink\" title=\"linux下搭建zookeeper集群\"></a>linux下搭建zookeeper集群</h2><p>由于机器有限，本次教程准备在单台centos6.5虚拟机搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境</p>\n<h3 id=\"安装包下载解压\"><a href=\"#安装包下载解压\" class=\"headerlink\" title=\"安装包下载解压\"></a>安装包下载解压</h3><p>进入shell命令窗口,将安装包下载到/usr/local/src目录，zookeeper版本同样使用<a href=\"http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\">3.4.6版本</a></p>\n<pre><code class=\"bash\">[root@centos ~]# cd /usr/local/src\n[root@centos src]# wget http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz\n[root@centos src]# tar -zxvf zookeeper-3.4.6.tar.gz\n[root@centos src]# ll\n总用量 21332\n-rw-r--r--.  1 root root   392756 8月  10 11:31 man-db-2.7.5-3-x86_64.pkg.tar.xz\n-rw-r--r--.  1 root root   909077 8月  10 09:21 nginx-1.10.1.tar.gz\ndrwxrwxr-x.  6 root root     4096 4月   1 2015 redis-3.0.0\n-rw-r--r--.  1 root root  1358081 4月   1 2015 redis-3.0.0.tar.gz\ndrwxr-xr-x. 14 root root     4096 8月  10 11:07 xz-5.2.2\n-rw-r--r--.  1 root root  1464228 8月  10 11:04 xz-5.2.2.tar.gz\ndrwxr-xr-x. 10 1000 1000     4096 8月   8 11:13 zookeeper-3.4.6\n-rw-r--r--.  1 root root 17699306 8月   8 10:54 zookeeper-3.4.6.tar.gz\n</code></pre>\n<h3 id=\"配置安装目录及环境变量\"><a href=\"#配置安装目录及环境变量\" class=\"headerlink\" title=\"配置安装目录及环境变量\"></a>配置安装目录及环境变量</h3><pre><code>[root@centos src] ln -s zookeeper-3.4.6  /usr/local/zookeeper\n</code></pre><p>这里我将zookeeper软连接到/usr/local/zookeeper下面，以后升级zookeeper版本可以不用修改让任何环境变量，直接更改软连接指向就可以完成升级</p>\n<p>配置环境变量<br>vi 编辑/etc/profile文件，导入ZK_HOME环境变量，路径指向刚才的软连接目录，如下：</p>\n<pre><code>#export env path\nexport JAVA_HOME=/usr/local/java/jdk\nexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport PATH=$PATH:$CLASSPATH\nexport ZK_HOME=/usr/local/zookeeper\nexport PATH=$PATH:$ZK_HOME/bin\nfor i in /etc/profile.d/*.sh ; do\n    if [ -r &quot;$i&quot; ]; then\n        if [ &quot;${-#*i}&quot; != &quot;$-&quot; ]; then\n            . &quot;$i&quot;\n        else\n            . &quot;$i&quot; &gt;/dev/null 2&gt;&amp;1\n        fi\n    fi\ndone\nunset i\nunset -f pathmunge\n</code></pre><p>这里注意jdk环境变量和zookeeper环境变量，要配置在第8行的上面，因为下文我们的登录自动启动脚本会放到/etc/profile.d/下，所以要在脚本执行前导入环境变量</p>\n<h3 id=\"配置集群节点\"><a href=\"#配置集群节点\" class=\"headerlink\" title=\"配置集群节点\"></a>配置集群节点</h3><p>创建集群目录</p>\n<ol>\n<li>在/usr/local目录创建zookeeper_cluster目录，然后在zookeeper_cluster目录先创建一个集群节点目录server1</li>\n<li>在server1目录创建data,logs目录</li>\n<li>最后将/usr/local/zookeeper/conf/zoo_sample.cfg 拷贝重命名为zoo.cfg到server1目录</li>\n</ol>\n<p>操作过程如下</p>\n<pre><code>[root@centos local]# mkdir zookeeper_cluster\n[root@centos local]# cd zookeeper_cluster\n[root@centos zookeeper_cluster]# mkdir server1\n[root@centos zookeeper_cluster]# cd server1\n[root@centos server1]# mkdir data logs\n[root@centos server1]# cp /usr/local/zookeeper/conf/zoo_sample.cfg zoo.cfg\n</code></pre><p>配置zoo.cfg文件参数</p>\n<p>修改server1节点目录下zoo.cfg文件的内容(<a href=\"#zoo_cfg_table\">zoo.cfg各个配置参数的含义</a>)</p>\n<pre><code>[root@centos server1]# vi zoo.cfg\n</code></pre><p>内容修改如下</p>\n<pre><code>tickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/usr/local/zookeeper_cluster/server1/data\ndataLogDir=/usr/local/zookeeper_cluster/server1/logs\nclientPort=2181\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=1\nserver.1=127.0.0.1:2887:3887\nserver.2=127.0.0.1:2888:3888\nserver.3=127.0.0.1:2889:3889\n</code></pre><p>创建myid文件</p>\n<p>除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。</p>\n<pre><code>[root@centos server1]# echo 1 &gt; data/myid\n</code></pre><p>配置另外两个节点</p>\n<p>通过上述步骤，我们server1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将server1节点目录复制为server2,server3</p>\n<pre><code>[root@centos zookeeper_cluster] cp -rf server1  server2\n[root@centos zookeeper_cluster] cp -rf server1  server3\n</code></pre><ol>\n<li>修改server2,server3各自myid文件内容<pre><code>[root@centos zookeeper_cluster] echo 2 &gt; server2/myid\n[root@centos zookeeper_cluster] echo 3 &gt; server3/myid\n</code></pre></li>\n<li>修改server2,server3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数<br>server2节点zoo.cfg修改内容如下<pre><code>dataDir=/usr/local/zookeeper_cluster/server2/data\ndataLogDir=/usr/local/zookeeper_cluster/server2/logs\nclientPort=2182\n</code></pre>server3节点zoo.cfg修改内容如下<pre><code>dataDir=/usr/local/zookeeper_cluster/server3/data\ndataLogDir=/usr/local/zookeeper_cluster/server3/logs\nclientPort=2183\n</code></pre></li>\n</ol>\n<h3 id=\"启动集群\"><a href=\"#启动集群\" class=\"headerlink\" title=\"启动集群\"></a>启动集群</h3><p>这里我们先在/etc/profile.d/ 创建一个集群启动的脚本zk_cluster_strat.sh，脚本内容如下：</p>\n<pre><code> #!/bin/bash\n #description:auto start zookeeper cluster nodes when user login\n zkServer.sh start  /usr/local/zookeeper_cluster/server1/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server2/zoo.cfg\n zkServer.sh start  /usr/local/zookeeper_cluster/server3/zoo.cfg\n</code></pre><p> 脚本创建好之后，我们来手动执行下此脚本</p>\n<pre><code>[root@centos ~]# .  /etc/profile.d/zk_cluster_start.sh\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server1/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server2/zoo.cfg\nStarting zookeeper ... STARTED\nJMX enabled by default\nUsing config: /usr/local/zookeeper_cluster/server3/zoo.cfg\nStarting zookeeper ... STARTED\n</code></pre><h3 id=\"测试集群-1\"><a href=\"#测试集群-1\" class=\"headerlink\" title=\"测试集群\"></a>测试集群</h3><p>接着我们用zkCli.sh测试每个节点连接</p>\n<pre><code>[root@centos ~]# zkCli.sh -server 127.0.0.1:2181\n省略连接内容...\n[zk: 127.0.0.1:2181(CONNECTED) 0] create /test  hello,world! #创建一个节点目录\nCreated /test\n[zk: 127.0.0.1:2181(CONNECTED) 0] connect 127.0.0.1:2182\n省略连接内容...\n[zk: 127.0.0.1:2182(CONNECTED) 4] get /test  #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n127.0.0.1:2181\n[zk: 127.0.0.1:2182(CONNECTED) 5] connect 127.0.0.1:2183\n省略连接内容...\n[zk: 127.0.0.1:2183(CONNECTED) 2] get /test #获取刚才在127.0.0.1:2181创建/test节点内容\nhello,world!\ncZxid = 0x900000002\nctime = Sun Aug 14 11:51:05 CST 2016\nmZxid = 0x900000002\nmtime = Sun Aug 14 11:51:05 CST 2016\npZxid = 0x900000002\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 12\nnumChildren = 0\n</code></pre><p>linux上搭建zookeeper集群环境部署完毕！</p>\n<hr/>\n\n<h2 id=\"zoo-cfg各个配置参数的含义\"><a href=\"#zoo-cfg各个配置参数的含义\" class=\"headerlink\" title=\"zoo.cfg各个配置参数的含义\"></a><span id='zoo_cfg_table'>zoo.cfg各个配置参数的含义</span></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">配置参数</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>tickTime</strong></td>\n<td style=\"text-align:left\">这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>initLimit</strong></td>\n<td style=\"text-align:left\">这个配置项是用来配置Zookeeper接受客户端（这里所说的客户端不是用户连接Zookeeper服务器的客户端，而是Zookeeper服务器集群中连接到Leader的Follower服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是tickTime）长度后Zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是5*2000=10秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>syncLimit</strong></td>\n<td style=\"text-align:left\">这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就2*2000=4 秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>dataDir</strong></td>\n<td style=\"text-align:left\">顾名思义就是Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>dataLogDir</strong></td>\n<td style=\"text-align:left\">顾名思义就是Zookeeper记录数据变化的日志目录，如果不配置，默认日志文件会保存到dataDir数据目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>clientPort</strong></td>\n<td style=\"text-align:left\">这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>autopurge.snapRetainCount</strong></td>\n<td style=\"text-align:left\">指定了需要保留的快照文件数目。默认是保留3个，需要和autopurge.purgeInterval搭配使用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>autopurge.purgeInterval</strong></td>\n<td style=\"text-align:left\">指定了自动清理快照和事务日志的频率，单位是小时，需要填写一个1或更大的整数，默认是0，表示不开启自己清理功能</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>server.A=B：C：D</strong></td>\n<td style=\"text-align:left\">其中A是一个数字，表示这个是第几号服务器；B是这个服务器的ip地址；C表示的是这个服务器与集群中的Leader服务器交换信息的端口；D 表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于B都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://www.ibm.com/developerworks/cn/data/library/bd-zookeeper/\">ZooKeeper 基础知识、部署和应用程序</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj35obsuq0008qk5cz7gp8wni","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsv1000dqk5cbuivxckv"},{"post_id":"cj35obsua0001qk5c9j54wh5j","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsv6000hqk5ch4vdx9wv"},{"post_id":"cj35obsus000aqk5c5z4ljlrr","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsv9000kqk5chlspcudr"},{"post_id":"cj35obsuy000cqk5ci23cde3m","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsvb000oqk5c4sjreonv"},{"post_id":"cj35obsuf0003qk5ceylbzee0","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsvd000qqk5cxdzk6rom"},{"post_id":"cj35obsv2000eqk5cs4oums3y","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsvh000tqk5c8ipqnz95"},{"post_id":"cj35obsv7000jqk5c8vgxj63v","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsvs000wqk5c95d7c2oj"},{"post_id":"cj35obsun0007qk5cjabb66ri","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsvv000zqk5cjjiunl5y"},{"post_id":"cj35obsv9000mqk5cp7iildfe","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsvy0012qk5cukc5krom"},{"post_id":"cj35obsvc000pqk5cqdts7v11","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsvz0015qk5cxsqc37sg"},{"post_id":"cj35obsve000rqk5cyhdo2j23","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsw00018qk5cxf6w96lc"},{"post_id":"cj35obsvh000uqk5cmpkrsemv","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsw3001bqk5cvnzgs02k"},{"post_id":"cj35obsvs000xqk5c8tspar24","category_id":"cj35obsuk0005qk5cvp0px1qh","_id":"cj35obsw4001gqk5c64a9le50"},{"post_id":"cj35obsvw0011qk5c4we1bz7g","category_id":"cj35obsvz0014qk5czrw30kmv","_id":"cj35obsw5001iqk5cnapv39z7"},{"post_id":"cj35obsvy0013qk5c8uyah2cy","category_id":"cj35obsw3001eqk5cfq44bspj","_id":"cj35obswa001pqk5c7dwfdme7"},{"post_id":"cj35obsw00016qk5c7y0w8eij","category_id":"cj35obsw6001kqk5cqjm3rmv9","_id":"cj35obswe001vqk5cll1pc0s5"},{"post_id":"cj35obsw0001aqk5cd82wadf4","category_id":"cj35obswb001rqk5cax7gai62","_id":"cj35obswh0021qk5cswf49hlr"},{"post_id":"cj35obsw4001hqk5cjgazfegy","category_id":"cj35obswe001wqk5cgkt1q0jc","_id":"cj35obswj0025qk5cdmu8mgqi"},{"post_id":"cj35obsw5001jqk5cbjyir2h2","category_id":"cj35obswi0023qk5c927ctg65","_id":"cj35obswj0029qk5c0buyxnh4"},{"post_id":"cj35obsw6001mqk5cegb7548r","category_id":"cj35obswj0026qk5ch2wgln1z","_id":"cj35obswk002dqk5cixybij69"},{"post_id":"cj35obsw7001oqk5cyf12xcmp","category_id":"cj35obswb001rqk5cax7gai62","_id":"cj35obswk002hqk5cuhxpyzyg"},{"post_id":"cj35obswc001tqk5c8grn0ik3","category_id":"cj35obswk002eqk5c0djnrg7s","_id":"cj35obswl002lqk5cp658ga0l"},{"post_id":"cj35obswd001uqk5cg7ylkho4","category_id":"cj35obswk002eqk5c0djnrg7s","_id":"cj35obswl002pqk5cg2flgxmz"},{"post_id":"cj35obswf001yqk5cn6r3z3uu","category_id":"cj35obswl002mqk5c7dwz3kqv","_id":"cj35obswm002tqk5c3uw1kj9c"},{"post_id":"cj35obswg0020qk5coz4cvnp5","category_id":"cj35obswl002qqk5c1yu25ffx","_id":"cj35obswm002wqk5czi2oa8yo"}],"PostTag":[{"post_id":"cj35obsua0001qk5c9j54wh5j","tag_id":"cj35obsuh0004qk5c77fli00a","_id":"cj35obsv7000iqk5cx73yk13k"},{"post_id":"cj35obsua0001qk5c9j54wh5j","tag_id":"cj35obsus0009qk5cz6s78h7w","_id":"cj35obsv9000lqk5chjj4m8r9"},{"post_id":"cj35obsuf0003qk5ceylbzee0","tag_id":"cj35obsv5000gqk5c8jvvpre1","_id":"cj35obsvs000vqk5cl5onvase"},{"post_id":"cj35obsuf0003qk5ceylbzee0","tag_id":"cj35obsvb000nqk5c61513ad5","_id":"cj35obsvv000yqk5cwq0uy7g5"},{"post_id":"cj35obsun0007qk5cjabb66ri","tag_id":"cj35obsvg000sqk5ccr0bt2ot","_id":"cj35obsw00019qk5cgb20kmqn"},{"post_id":"cj35obsun0007qk5cjabb66ri","tag_id":"cj35obsvv0010qk5cfl8c7j77","_id":"cj35obsw3001cqk5cmicm7qp5"},{"post_id":"cj35obsuq0008qk5cz7gp8wni","tag_id":"cj35obsw00017qk5c1lgmrynv","_id":"cj35obsw7001nqk5c0psfv4if"},{"post_id":"cj35obsuq0008qk5cz7gp8wni","tag_id":"cj35obsw4001fqk5c2l8ro24d","_id":"cj35obswa001qqk5ck954bi6u"},{"post_id":"cj35obsus000aqk5c5z4ljlrr","tag_id":"cj35obsw00017qk5c1lgmrynv","_id":"cj35obswg001zqk5c5quq0dl2"},{"post_id":"cj35obsus000aqk5c5z4ljlrr","tag_id":"cj35obswb001sqk5ct1vh2m5m","_id":"cj35obswh0022qk5c0dc56q47"},{"post_id":"cj35obsuy000cqk5ci23cde3m","tag_id":"cj35obswf001xqk5cfiq0ltlp","_id":"cj35obswj0028qk5cnydwri44"},{"post_id":"cj35obsuy000cqk5ci23cde3m","tag_id":"cj35obswi0024qk5cri9df62s","_id":"cj35obswj002aqk5cjnzxatqp"},{"post_id":"cj35obsv2000eqk5cs4oums3y","tag_id":"cj35obswj0027qk5ci7ghzynf","_id":"cj35obswk002gqk5c8wvoul9h"},{"post_id":"cj35obsv2000eqk5cs4oums3y","tag_id":"cj35obswk002cqk5cvsg3jzu3","_id":"cj35obswl002iqk5ccvyqj6zw"},{"post_id":"cj35obsv7000jqk5c8vgxj63v","tag_id":"cj35obswk002fqk5clhpqfjue","_id":"cj35obswl002oqk5cmy27ynwo"},{"post_id":"cj35obsv7000jqk5c8vgxj63v","tag_id":"cj35obswl002kqk5cg45xkd31","_id":"cj35obswm002rqk5cjxe0xbo8"},{"post_id":"cj35obsv9000mqk5cp7iildfe","tag_id":"cj35obswl002nqk5c7wotzj2p","_id":"cj35obswm002vqk5cdwqt4dwy"},{"post_id":"cj35obsv9000mqk5cp7iildfe","tag_id":"cj35obswm002sqk5cttu0bhux","_id":"cj35obswm002xqk5c1kwvdty9"},{"post_id":"cj35obsvc000pqk5cqdts7v11","tag_id":"cj35obswm002uqk5cy4b252i3","_id":"cj35obswn0030qk5cworfi8do"},{"post_id":"cj35obsvc000pqk5cqdts7v11","tag_id":"cj35obswm002yqk5c9za0lr3y","_id":"cj35obswn0031qk5crovf6ycr"},{"post_id":"cj35obsve000rqk5cyhdo2j23","tag_id":"cj35obswn002zqk5cwrv60rcm","_id":"cj35obswn0034qk5c15p0zvwc"},{"post_id":"cj35obsve000rqk5cyhdo2j23","tag_id":"cj35obswn0032qk5cvrmzcxz5","_id":"cj35obswn0035qk5cxllwp7zr"},{"post_id":"cj35obsvh000uqk5cmpkrsemv","tag_id":"cj35obswn0033qk5c8e6g1qjd","_id":"cj35obswo0038qk5c86d6bsc1"},{"post_id":"cj35obsvh000uqk5cmpkrsemv","tag_id":"cj35obswn0036qk5c4gygvon0","_id":"cj35obswo0039qk5cesv91ry0"},{"post_id":"cj35obsvs000xqk5c8tspar24","tag_id":"cj35obswn0037qk5ckzeltc0s","_id":"cj35obswp003cqk5cm3h055gy"},{"post_id":"cj35obsvs000xqk5c8tspar24","tag_id":"cj35obswo003aqk5crjcowxxg","_id":"cj35obswp003dqk5c6ehfn56w"},{"post_id":"cj35obsvw0011qk5c4we1bz7g","tag_id":"cj35obswo003bqk5c8k1wdmsp","_id":"cj35obswp003gqk5cafzp6ej8"},{"post_id":"cj35obsvw0011qk5c4we1bz7g","tag_id":"cj35obswp003eqk5cdqvz4azg","_id":"cj35obswp003hqk5cnrtk7k8f"},{"post_id":"cj35obsvy0013qk5c8uyah2cy","tag_id":"cj35obswp003fqk5ceejjoc4a","_id":"cj35obswr003lqk5cxnedw5jp"},{"post_id":"cj35obsvy0013qk5c8uyah2cy","tag_id":"cj35obswp003iqk5c30mgh6nd","_id":"cj35obswr003mqk5cfybez6r8"},{"post_id":"cj35obsvy0013qk5c8uyah2cy","tag_id":"cj35obswq003jqk5cus6jftco","_id":"cj35obsws003oqk5cpp1jjghd"},{"post_id":"cj35obsw00016qk5c7y0w8eij","tag_id":"cj35obswq003kqk5cbjeyqjxb","_id":"cj35obsws003qqk5cqkgeri9w"},{"post_id":"cj35obsw00016qk5c7y0w8eij","tag_id":"cj35obswr003nqk5cddcwlf90","_id":"cj35obsws003rqk5canlbifeu"},{"post_id":"cj35obsw0001aqk5cd82wadf4","tag_id":"cj35obsws003pqk5c4dssnjh3","_id":"cj35obswt003vqk5caf3nvr7y"},{"post_id":"cj35obsw0001aqk5cd82wadf4","tag_id":"cj35obsws003sqk5c3ajdiige","_id":"cj35obswt003wqk5clw68sq78"},{"post_id":"cj35obsw0001aqk5cd82wadf4","tag_id":"cj35obswt003tqk5csf7klbsm","_id":"cj35obswt003yqk5c4152karw"},{"post_id":"cj35obsw4001hqk5cjgazfegy","tag_id":"cj35obswt003uqk5c63jk20hs","_id":"cj35obswu003zqk5cj5q4jpc8"},{"post_id":"cj35obsw5001jqk5cbjyir2h2","tag_id":"cj35obswt003xqk5cetm78ouj","_id":"cj35obswu0042qk5cjiv0nnyr"},{"post_id":"cj35obsw5001jqk5cbjyir2h2","tag_id":"cj35obswu0040qk5cunhfvrr5","_id":"cj35obswu0043qk5cf54jb8r7"},{"post_id":"cj35obsw6001mqk5cegb7548r","tag_id":"cj35obswu0041qk5cibtgdcur","_id":"cj35obswv0047qk5cbgzxrerr"},{"post_id":"cj35obsw6001mqk5cegb7548r","tag_id":"cj35obswu0044qk5caf4qs8gh","_id":"cj35obswv0048qk5ct6w1j4by"},{"post_id":"cj35obsw6001mqk5cegb7548r","tag_id":"cj35obswu0045qk5cm19n9b0v","_id":"cj35obswv004aqk5c9y84yq7z"},{"post_id":"cj35obsw7001oqk5cyf12xcmp","tag_id":"cj35obsws003sqk5c3ajdiige","_id":"cj35obsww004cqk5cod8svvgt"},{"post_id":"cj35obsw7001oqk5cyf12xcmp","tag_id":"cj35obswv0049qk5czu214b9q","_id":"cj35obsww004dqk5c66cpj1qf"},{"post_id":"cj35obswc001tqk5c8grn0ik3","tag_id":"cj35obsww004bqk5cusf4i0e5","_id":"cj35obswx004jqk5cgetdjyjm"},{"post_id":"cj35obswc001tqk5c8grn0ik3","tag_id":"cj35obswp003eqk5cdqvz4azg","_id":"cj35obswx004kqk5cytv4rcwk"},{"post_id":"cj35obswc001tqk5c8grn0ik3","tag_id":"cj35obsww004fqk5cu9u8vkn9","_id":"cj35obswy004mqk5c9q8o5kem"},{"post_id":"cj35obswc001tqk5c8grn0ik3","tag_id":"cj35obswx004gqk5cbedt3p1z","_id":"cj35obswy004nqk5czch8q0a2"},{"post_id":"cj35obswc001tqk5c8grn0ik3","tag_id":"cj35obswq003jqk5cus6jftco","_id":"cj35obswy004pqk5chwfxfk35"},{"post_id":"cj35obswd001uqk5cg7ylkho4","tag_id":"cj35obswx004iqk5ct602juv2","_id":"cj35obswy004rqk5csw1w6k53"},{"post_id":"cj35obswd001uqk5cg7ylkho4","tag_id":"cj35obswx004lqk5c4fb7ud9d","_id":"cj35obswy004sqk5c5hb3bcp4"},{"post_id":"cj35obswd001uqk5cg7ylkho4","tag_id":"cj35obswq003jqk5cus6jftco","_id":"cj35obswy004uqk5c081om9kj"},{"post_id":"cj35obswf001yqk5cn6r3z3uu","tag_id":"cj35obswy004qqk5cw5sljshf","_id":"cj35obswz004xqk5c4l1675ir"},{"post_id":"cj35obswf001yqk5cn6r3z3uu","tag_id":"cj35obswy004tqk5cvpe7exu1","_id":"cj35obswz004yqk5cqsirelzh"},{"post_id":"cj35obswf001yqk5cn6r3z3uu","tag_id":"cj35obswy004vqk5cxp8dr5bt","_id":"cj35obswz0050qk5ckgnc3vsu"},{"post_id":"cj35obswg0020qk5coz4cvnp5","tag_id":"cj35obswz004wqk5c1cwmw57l","_id":"cj35obswz0052qk5c3wqr6b13"},{"post_id":"cj35obswg0020qk5coz4cvnp5","tag_id":"cj35obswz004zqk5cvpf4jkho","_id":"cj35obswz0053qk5czr9hebnm"},{"post_id":"cj35obswg0020qk5coz4cvnp5","tag_id":"cj35obswz0051qk5c0ci8glvh","_id":"cj35obswz0054qk5c16m1cl91"}],"Tag":[{"name":"AbstractFactory","_id":"cj35obsuh0004qk5c77fli00a"},{"name":"抽象工厂模式","_id":"cj35obsus0009qk5cz6s78h7w"},{"name":"Adapter","_id":"cj35obsv5000gqk5c8jvvpre1"},{"name":"适配器模式","_id":"cj35obsvb000nqk5c61513ad5"},{"name":"Builder","_id":"cj35obsvg000sqk5ccr0bt2ot"},{"name":"生成器模式","_id":"cj35obsvv0010qk5cfl8c7j77"},{"name":"Decorator","_id":"cj35obsw00017qk5c1lgmrynv"},{"name":"组合模式","_id":"cj35obsw4001fqk5c2l8ro24d"},{"name":"装饰模式","_id":"cj35obswb001sqk5ct1vh2m5m"},{"name":"Facade","_id":"cj35obswf001xqk5cfiq0ltlp"},{"name":"外观模式","_id":"cj35obswi0024qk5cri9df62s"},{"name":"FactoryMethod","_id":"cj35obswj0027qk5ci7ghzynf"},{"name":"工厂方法模式","_id":"cj35obswk002cqk5cvsg3jzu3"},{"name":"享元模式","_id":"cj35obswk002fqk5clhpqfjue"},{"name":"Flyweight","_id":"cj35obswl002kqk5cg45xkd31"},{"name":"解释器模式","_id":"cj35obswl002nqk5c7wotzj2p"},{"name":"Interpreter","_id":"cj35obswm002sqk5cttu0bhux"},{"name":"Prototype","_id":"cj35obswm002uqk5cy4b252i3"},{"name":"原型模式","_id":"cj35obswm002yqk5c9za0lr3y"},{"name":"Singleton","_id":"cj35obswn002zqk5cwrv60rcm"},{"name":"单例模式","_id":"cj35obswn0032qk5cvrmzcxz5"},{"name":"模板方法","_id":"cj35obswn0033qk5c8e6g1qjd"},{"name":"TemplateMethod","_id":"cj35obswn0036qk5c4gygvon0"},{"name":"Bridge","_id":"cj35obswn0037qk5ckzeltc0s"},{"name":"桥接模式","_id":"cj35obswo003aqk5crjcowxxg"},{"name":"hibernate","_id":"cj35obswo003bqk5c8k1wdmsp"},{"name":"java","_id":"cj35obswp003eqk5cdqvz4azg"},{"name":"Swagger","_id":"cj35obswp003fqk5ceejjoc4a"},{"name":"RESTful Service","_id":"cj35obswp003iqk5c30mgh6nd"},{"name":"原创翻译","_id":"cj35obswq003jqk5cus6jftco"},{"name":"gradle","_id":"cj35obswq003kqk5cbjeyqjxb"},{"name":"构建工具","_id":"cj35obswr003nqk5cddcwlf90"},{"name":"CmdMarkdown","_id":"cj35obsws003pqk5c4dssnjh3"},{"name":"markdown","_id":"cj35obsws003sqk5c3ajdiige"},{"name":"test","_id":"cj35obswt003tqk5csf7klbsm"},{"name":"js","_id":"cj35obswt003uqk5c63jk20hs"},{"name":"linux","_id":"cj35obswt003xqk5cetm78ouj"},{"name":"linux命令","_id":"cj35obswu0040qk5cunhfvrr5"},{"name":"maven","_id":"cj35obswu0041qk5cibtgdcur"},{"name":"随笔","_id":"cj35obswu0044qk5caf4qs8gh"},{"name":"maven使用教程","_id":"cj35obswu0045qk5cm19n9b0v"},{"name":"markdown语法","_id":"cj35obswv0049qk5czu214b9q"},{"name":"Spring Boot","_id":"cj35obsww004bqk5cusf4i0e5"},{"name":"文件上传","_id":"cj35obsww004fqk5cu9u8vkn9"},{"name":"示例","_id":"cj35obswx004gqk5cbedt3p1z"},{"name":"SpringBoot","_id":"cj35obswx004iqk5ct602juv2"},{"name":"Java","_id":"cj35obswx004lqk5c4fb7ud9d"},{"name":"hexo","_id":"cj35obswy004qqk5cw5sljshf"},{"name":"prettify","_id":"cj35obswy004tqk5cvpe7exu1"},{"name":"高亮插件","_id":"cj35obswy004vqk5cxp8dr5bt"},{"name":"zookeeper","_id":"cj35obswz004wqk5c1cwmw57l"},{"name":"教程","_id":"cj35obswz004zqk5cvpf4jkho"},{"name":"环境搭建","_id":"cj35obswz0051qk5c0ci8glvh"}]}}